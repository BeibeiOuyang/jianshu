(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["BizCharts"] = factory(require("react"));
	else
		root["BizCharts"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_42__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 546);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The util method based on the lodash.
 * @author dxq613@gmail.com
 * @see https://github.com/lodash/lodash
 */
var Utils = __webpack_require__(166);

var G = __webpack_require__(16);

var Util = Utils.mix({}, Utils, {
  assign: Utils.mix,
  // simple mix
  merge: Utils.deepMix,
  // deep mix
  cloneDeep: Utils.clone,
  isFinite: isFinite,
  isNaN: isNaN,
  snapEqual: Utils.isNumberEqual,
  remove: Utils.pull,
  inArray: Utils.contains,

  /**
   * 灏嗙敤鎴疯緭鍏ョ殑 padding 杞崲鎴� [top, right, bottom, right] 鐨勬ā寮�
   * @param  {Number|Array} padding 杈撳叆鐨刾adding
   * @return {Array} 鍥涗釜padding 鍊�
   */
  toAllPadding: function toAllPadding(padding) {
    var top = 0;
    var left = 0;
    var right = 0;
    var bottom = 0;

    if (Util.isNumber(padding) || Util.isString(padding)) {
      top = left = right = bottom = padding;
    } else if (Util.isArray(padding)) {
      top = padding[0];
      right = !Util.isNil(padding[1]) ? padding[1] : padding[0];
      bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];
      left = !Util.isNil(padding[3]) ? padding[3] : right;
    } else if (Util.isObject(padding)) {
      top = padding.top || 0;
      right = padding.right || 0;
      bottom = padding.bottom || 0;
      left = padding.left || 0;
    }

    return [top, right, bottom, left];
  },
  getClipByRange: function getClipByRange(plotRange) {
    var tl = plotRange.tl,
        br = plotRange.br;
    var clip = new G.Rect({
      attrs: {
        x: tl.x,
        y: tl.y,
        width: br.x - tl.x,
        height: br.y - tl.y
      }
    });
    return clip;
  }
});
Util.Array = {
  groupToMap: Utils.groupToMap,
  group: Utils.group,
  merge: Utils.merge,
  values: Utils.valuesOfKey,
  getRange: Utils.getRange,
  firstValue: Utils.firstValue,
  remove: Utils.pull
};
module.exports = Util;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var CommonUtil = __webpack_require__(150);

var Util = {};
CommonUtil.merge(Util, CommonUtil, {
  mixin: function mixin(c, mixins) {
    var Param = c.CFG ? 'CFG' : 'ATTRS';

    if (c && mixins) {
      c._mixins = mixins;
      c[Param] = c[Param] || {};
      var temp = {};
      Util.each(mixins, function (mixin) {
        Util.augment(c, mixin);
        var attrs = mixin[Param];

        if (attrs) {
          Util.merge(temp, attrs);
        }
      });
      c[Param] = Util.merge(temp, c[Param]);
    }
  }
});
module.exports = Util;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39);
var isArray = __webpack_require__(4);

var each = function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst = void 0;
  if (isArray(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
};

module.exports = each;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The util method based on the lodash.
 * @author dxq613@gmail.com
 */
var G = __webpack_require__(31);

var Utils = __webpack_require__(166);

var Util = Utils.mix({
  assign: Utils.mix,
  isFinite: isFinite,
  isNaN: isNaN,
  Group: G.Group,
  Event: G.Event
}, Utils);
module.exports = Util;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(17);

var isArray = Array.isArray ? Array.isArray : function (value) {
  return isType(value, 'Array');
};

module.exports = isArray;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 鍏ㄥ眬鍙橀噺
 * @author dxq613
 */
var Util = __webpack_require__(0);

var Theme = __webpack_require__(132);

var Global = {
  version: '3.5.12',
  renderer: 'canvas',
  // trackable: false,
  trackingInfo: {},
  animate: true,
  widthRatio: {
    // 瀹藉害鎵€鍗犵殑鍒嗙被鐨勬瘮渚�
    column: 1 / 2,
    // 涓€鑸殑鏌辩姸鍥惧崰姣� 1/2
    rose: 0.9999999,
    // 鐜懓鍥炬煴鐘跺崰姣� 1
    multiplePie: 1 / 1.3 // 澶氬眰鐨勯ゼ鍥俱€佺幆鍥�

  },
  // 鎶樼嚎鍥俱€佸尯鍩熷浘銆乸ath 褰撳彧鏈変竴涓暟鎹椂锛屾槸鍚︽樉绀烘垚鐐�
  showSinglePoint: false,
  connectNulls: false,
  scales: {},
  registerTheme: function registerTheme(name, theme) {
    Theme[name] = theme;
  },
  setTheme: function setTheme(theme) {
    var newTheme = {};

    if (Util.isObject(theme)) {
      newTheme = theme;
    } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {
      newTheme = Theme[theme];
    } else {
      newTheme = Theme.default;
    }

    Util.deepMix(Global, newTheme);
  }
};
Global.setTheme('default');
module.exports = Global;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

// isFinite,
var isNil = function isNil(value) {
  /**
   * isNil(null) => true
   * isNil() => true
   */
  return value === null || value === undefined;
};

module.exports = isNil;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var isPointInPath = __webpack_require__(331);

var Element = __webpack_require__(133);

var Inside = __webpack_require__(76);

var Shape = function Shape(cfg) {
  Shape.superclass.constructor.call(this, cfg);
};

Shape.ATTRS = {};
Util.extend(Shape, Element);
var ARRAY_ATTRS = {
  matrix: 'matrix',
  path: 'path',
  points: 'points',
  lineDash: 'lineDash'
};

function _cloneArrayAttr(arr) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    if (Util.isArray(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }

  return result;
}

Util.augment(Shape, isPointInPath, {
  isShape: true,
  drawInner: function drawInner(context) {
    var self = this;
    var attrs = self._attrs;
    self.createPath(context);
    var originOpacity = context.globalAlpha;

    if (self.hasFill()) {
      var fillOpacity = attrs.fillOpacity;

      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        context.fill();
        context.globalAlpha = originOpacity;
      } else {
        context.fill();
      }
    }

    if (self.hasStroke()) {
      var lineWidth = self._attrs.lineWidth;

      if (lineWidth > 0) {
        var strokeOpacity = attrs.strokeOpacity;

        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }

        context.stroke();
      }
    }

    self.afterPath(context);
  },
  afterPath: function afterPath() {},

  /**
   * 鍑讳腑鍥惧舰鏃舵槸鍚﹁繘琛屽寘鍥寸洅鍒ゆ柇
   * @return {Boolean} [description]
   */
  isHitBox: function isHitBox() {
    return true;
  },

  /**
   * 鑺傜偣鏄惁鑳藉琚嚮涓�
   * @param {Number} x x鍧愭爣
   * @param {Number} y y鍧愭爣
   * @return {Boolean} 鏄惁鍦ㄥ浘褰腑
   */
  isHit: function isHit(x, y) {
    var self = this;
    var v = [x, y, 1];
    self.invert(v); // canvas

    if (self.isHitBox()) {
      var box = self.getBBox();

      if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {
        return false;
      }
    }

    var clip = self._attrs.clip;

    if (clip) {
      clip.invert(v, self.get('canvas'));

      if (clip.isPointInPath(v[0], v[1])) {
        return self.isPointInPath(v[0], v[1]);
      }
    } else {
      return self.isPointInPath(v[0], v[1]);
    }

    return false;
  },

  /**
   * @protected
   * 璁＄畻鍖呭洿鐩�
   * @return {Object} 鍖呭洿鐩�
   */
  calculateBox: function calculateBox() {
    return null;
  },
  // 鑾峰彇鎷惧彇鏃剁嚎鐨勫搴︼紝闇€瑕佽€冭檻闄勫姞鐨勭嚎鐨勫搴�
  getHitLineWidth: function getHitLineWidth() {
    var attrs = this._attrs; // if (!attrs.stroke) {
    //   return 0;
    // }

    var lineAppendWidth = attrs.lineAppendWidth || 0;
    var lineWidth = attrs.lineWidth || 0;
    return lineWidth + lineAppendWidth;
  },
  // 娓呴櫎褰撳墠鐨勭煩闃�
  clearTotalMatrix: function clearTotalMatrix() {
    this._cfg.totalMatrix = null;
    this._cfg.region = null;
  },
  clearBBox: function clearBBox() {
    this._cfg.box = null;
    this._cfg.region = null;
  },
  getBBox: function getBBox() {
    var box = this._cfg.box; // 寤惰繜璁＄畻

    if (!box) {
      box = this.calculateBox();

      if (box) {
        box.x = box.minX;
        box.y = box.minY;
        box.width = box.maxX - box.minX;
        box.height = box.maxY - box.minY;
      }

      this._cfg.box = box;
    }

    return box;
  },
  clone: function clone() {
    var self = this;
    var clone = null;
    var _attrs = self._attrs;
    var attrs = {};
    Util.each(_attrs, function (i, k) {
      if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {
        attrs[k] = _cloneArrayAttr(_attrs[k]);
      } else {
        attrs[k] = _attrs[k];
      }
    });
    clone = new self.constructor({
      attrs: attrs
    }); // zIndex涔熸槸缁樺浘灞炴€э紝浣嗘槸鍦╟fg涓紝鐗规畩澶勭悊

    clone._cfg.zIndex = self._cfg.zIndex;
    return clone;
  }
});
module.exports = Shape;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 鎵€鏈� Geometry 鐨勫熀绫�
 * @author dxq613@gmail.com
 */
var Attr = __webpack_require__(65);

var Adjust = __webpack_require__(227);

var Base = __webpack_require__(120);

var Util = __webpack_require__(0);

var Global = __webpack_require__(5);

var Labels = __webpack_require__(294);

var Shape = __webpack_require__(9);

var TooltipMixin = __webpack_require__(300);

var ActiveMixin = __webpack_require__(298);

var SelectMixin = __webpack_require__(299);

var parseFields = __webpack_require__(313);

var GROUP_ATTRS = ['color', 'shape', 'size'];
var FIELD_ORIGIN = '_origin'; // 杞崲鎴愬璞＄殑鏁扮粍 [{type: 'adjust'}]

function parseAdjusts(adjusts) {
  // 濡傛灉鏄瓧绗︿覆鎴栬€呭璞¤浆鎹㈡垚鏁扮粍
  if (Util.isString(adjusts) || Util.isPlainObject(adjusts)) {
    adjusts = [adjusts];
  }

  Util.each(adjusts, function (adjust, index) {
    if (!Util.isObject(adjust)) {
      adjusts[index] = {
        type: adjust
      };
    }
  });
  return adjusts;
}
/**
 * 鍑犱綍鏍囪
 * @class Geom
 */


var GeomBase = /*#__PURE__*/function (_Base) {
  _inheritsLoose(GeomBase, _Base);

  var _proto = GeomBase.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      /**
       * 鏍囪 _id 鐢ㄤ簬鍖哄垎鎵ц鍔ㄧ敾
       * @type {String}
       */
      _id: null,

      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'base',

      /**
       * 鍧愭爣绯�
       * @type {Object}
       */
      coord: null,

      /**
       * 灞炴€ф槧灏勯泦
       * @protected
       * @type {Object}
       */
      attrs: {},

      /**
       * 鎵€灞炵殑View
       * @type {View}
       */
      view: null,

      /**
       * 鍑犱綍鏍囪鏄剧ず鐨勬暟鎹�
       * @type {Array}
       */
      data: [],

      /**
       * 鐩稿叧鐨勫害閲�
       * @type {Object}
       */
      scales: {},

      /**
       * 缁樺浘瀹瑰櫒
       * @type {Object}
       */
      container: null,

      /**
       * 鏂囨湰瀹瑰櫒
       * @type {Object}
       */
      labelContainer: null,

      /**
       * 鍥惧舰瀹瑰櫒
       * @type {Object}
       */
      shapeContainer: null,

      /**
       * 鍑犱綍鏍囪鐨勪竴浜涢厤缃」锛岀敤浜庡欢杩熺敓鎴愬浘琛�
       * @type {Object}
       */
      attrOptions: {},
      // 鏍峰紡閰嶇疆椤�
      styleOptions: null,
      // 閫変腑鏃剁殑閰嶇疆椤�
      selectedOptions: null,
      // active 鏃剁殑閰嶇疆椤�
      activedOptions: null,

      /**
       * 鏌愪簺绫诲瓨鍦ㄩ粯璁ょ殑adjust锛屼笉鑳芥洿鏀� adjust
       * @type {Boolean}
       */
      hasDefaultAdjust: false,
      // 鏁版嵁璋冩暣绫诲瀷
      adjusts: null,

      /**
       * 浣跨敤褰㈢姸鐨勭被鍨�
       * @protected
       * @type {String}
       */
      shapeType: null,

      /**
       * 鏄惁鐢熸垚澶氫釜鐐规潵缁樺埗鍥惧舰
       * @protected
       * @type {Boolean}
       */
      generatePoints: false,

      /**
       * 鏁版嵁鏄惁杩涜鎺掑簭
       * @type {Boolean}
       */
      sortable: false,
      labelCfg: null,

      /**
       * 鏄惁鍏变韩 tooltip
       * @type {Boolean}
       */
      shareTooltip: true,
      tooltipCfg: null,

      /**
       * 鏄惁鎵ц鍔ㄧ敾锛岄粯璁ゆ墽琛�
       * @type {Boolean}
       */
      animate: true,

      /**
       * 鍔ㄧ敾閰嶇疆
       * @type {[type]}
       */
      animateCfg: null,
      visible: true
    };
  };

  function GeomBase(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.viewTheme = _this.get('viewTheme');
    Util.assign(_assertThisInitialized(_this), TooltipMixin, ActiveMixin, SelectMixin);

    if (_this.get('container')) {
      _this._initContainer();
    }

    _this._initOptions();

    return _this;
  } // 鍒濆鍖栨椂瀵归厤缃」鐨勬牸寮忓寲


  _proto._initOptions = function _initOptions() {
    var adjusts = this.get('adjusts');

    if (adjusts) {
      adjusts = parseAdjusts(adjusts);
      this.set('adjusts', adjusts);
    }
  };

  _proto._createScale = function _createScale(field, data) {
    var scales = this.get('scales');
    var scale = scales[field];

    if (!scale) {
      scale = this.get('view').createScale(field, data);
      scales[field] = scale;
    }

    return scale;
  };

  _proto._setAttrOptions = function _setAttrOptions(attrName, attrCfg) {
    var options = this.get('attrOptions');
    options[attrName] = attrCfg;
  };

  _proto._createAttrOption = function _createAttrOption(attrName, field, cfg, defaultValues) {
    var attrCfg = {};
    attrCfg.field = field;

    if (cfg) {
      if (Util.isFunction(cfg)) {
        attrCfg.callback = cfg;
      } else {
        attrCfg.values = cfg;
      }
    } else if (attrName !== 'color') {
      attrCfg.values = defaultValues;
    }

    this._setAttrOptions(attrName, attrCfg);
  }
  /**
   * 浣嶇疆灞炴€ф槧灏�
   * @chainable
   * @param  {String} field 瀛楁鍚�
   * @return {Geom} geom 褰撳墠鍑犱綍鏍囪
   */
  ;

  _proto.position = function position(field) {
    this._setAttrOptions('position', {
      field: field
    });

    return this;
  }
  /**
   * 棰滆壊灞炴€ф槧灏�
   * @chainable
   * @param  {String} field 瀛楁鍚�
   * @param  {Array|Function} values 棰滆壊鐨勬暟缁勬垨鑰呭洖璋冨嚱鏁�
   * @return {Geom} geom 褰撳墠鍑犱綍鏍囪
   */
  ;

  _proto.color = function color(field, values) {
    var viewTheme = this.viewTheme || Global;

    this._createAttrOption('color', field, values, viewTheme.colors);

    return this;
  }
  /**
   * 澶у皬灞炴€ф槧灏�
   * @chainable
   * @param  {String} field 瀛楁鍚�
   * @param  {Array|Function} values 澶у皬鐨勬暟缁勬垨鑰呭洖璋冨嚱鏁�
   * @return {Geom} geom 褰撳墠鍑犱綍鏍囪
   */
  ;

  _proto.size = function size(field, values) {
    var viewTheme = this.viewTheme || Global;

    this._createAttrOption('size', field, values, viewTheme.sizes);

    return this;
  }
  /**
   * 褰㈢姸灞炴€ф槧灏�
   * @chainable
   * @param  {String} field 瀛楁鍚�
   * @param  {Array|Function} values 澶у皬鐨勬暟缁勬垨鑰呭洖璋冨嚱鏁�
   * @return {Geom} geom 褰撳墠鍑犱綍鏍囪
   */
  ;

  _proto.shape = function shape(field, values) {
    var viewTheme = this.viewTheme || Global;
    var type = this.get('type');
    var shapes = viewTheme.shapes[type] || [];

    this._createAttrOption('shape', field, values, shapes);

    return this;
  }
  /**
   * 閫忔槑搴﹀睘鎬ф槧灏�
   * @chainable
   * @param  {String} field 瀛楁鍚�
   * @param  {Array|Function} values 閫忔槑搴︾殑鏁扮粍鎴栬€呭洖璋冨嚱鏁�
   * @return {Geom} geom 褰撳墠鍑犱綍鏍囪
   */
  ;

  _proto.opacity = function opacity(field, values) {
    var viewTheme = this.viewTheme || Global;

    this._createAttrOption('opacity', field, values, viewTheme.opacities);

    return this;
  };

  _proto.style = function style(field, cfg) {
    var styleOptions = this.get('styleOptions');

    if (!styleOptions) {
      styleOptions = {};
      this.set('styleOptions', styleOptions);
    }

    if (Util.isObject(field)) {
      cfg = field;
      field = null;
    }

    var fields;

    if (field) {
      fields = parseFields(field);
    }

    styleOptions.fields = fields;
    styleOptions.style = cfg;
    return this;
  };

  _proto.label = function label(field, callback, cfg) {
    var self = this;
    var labelCfg = self.get('labelCfg'); // const scales = Util.map(self.get('labelCfg').fields, field => self._createScale(field));

    if (!labelCfg) {
      labelCfg = {};
      self.set('labelCfg', labelCfg);
    }

    var fields;

    if (field) {
      fields = parseFields(field);
    }

    labelCfg.fields = fields; // 濡傛灉瀛樺湪鍥炶皟鍑芥暟

    if (Util.isFunction(callback)) {
      if (!cfg) {
        cfg = {};
      }

      labelCfg.callback = callback;
    } else if (Util.isObject(callback)) {
      // 濡傛灉娌℃湁璁剧疆鍥炶皟鍑芥暟
      cfg = callback;
    }

    labelCfg.globalCfg = cfg;
    return this;
  };

  _proto.tooltip = function tooltip(field, cfg) {
    var tooltipCfg = this.get('tooltipCfg');

    if (!tooltipCfg) {
      tooltipCfg = {};
    }

    if (field === false) {
      // geom 鍏抽棴 tooltip
      this.set('tooltipCfg', false);
    } else {
      var tooltipFields;

      if (field) {
        tooltipFields = parseFields(field);
      }

      tooltipCfg.fields = tooltipFields;
      tooltipCfg.cfg = cfg;
    }

    this.set('tooltipCfg', tooltipCfg);
    return this;
  };

  _proto.animate = function animate(cfg) {
    this.set('animateCfg', cfg);
    return this;
  }
  /**
   * 鏄惁鍏佽浣跨敤榛樿鐨勫浘褰㈡縺娲讳氦浜�
   * @param  {Boolean} enable 鏄惁鍏佽婵€娲诲紑鍏�
   * @param {Object} cfg 婵€娲荤殑閰嶇疆椤�
   * @return {Geom}    杩斿洖 geom 鑷韩
   */
  ;

  _proto.active = function active(enable, cfg) {
    if (enable === false) {
      this.set('allowActive', false);
    } else if (Util.isObject(enable)) {
      this.set('allowActive', true);
      this.set('activedOptions', enable);
    } else {
      this.set('allowActive', true);
      this.set('activedOptions', cfg);
    }

    return this;
  }
  /**
   * 瀵� geometry 杩涜鏁版嵁璋冩暣
   * @chainable
   * @param  {String|Array|null} adjusts 鏁版嵁璋冩暣鐨勭被鍨�
   * @return {Object} geometry 瀵硅薄
   */
  ;

  _proto.adjust = function adjust(adjusts) {
    if (!this.get('hasDefaultAdjust')) {
      if (adjusts) {
        adjusts = parseAdjusts(adjusts);
      }

      this.set('adjusts', adjusts);
    }

    return this;
  }
  /**
   * 璁剧疆鍥惧舰鐨勯€変腑妯″紡
   * @param  {Boolean|Object} enable 甯冨皵绫诲瀷鐢ㄤ簬妯″紡寮€鍏筹紝瀵硅薄绫诲瀷鐢ㄤ簬閰嶇疆
   * @param  {Object} cfg    閫変腑閰嶇疆椤�
   * @return {Geom}          杩斿洖 geom 鑷韩
   */
  ;

  _proto.select = function select(enable, cfg) {
    if (enable === false) {
      this.set('allowSelect', false);
    } else if (Util.isObject(enable)) {
      this.set('allowSelect', true);
      this.set('selectedOptions', enable);
    } else {
      this.set('allowSelect', true);
      this.set('selectedOptions', cfg);
    }

    return this;
  };

  _proto.hasAdjust = function hasAdjust(adjustType) {
    var self = this;
    var adjusts = self.get('adjusts');

    if (!adjustType) {
      return false;
    }

    var rst = false;
    Util.each(adjusts, function (adjust) {
      if (adjust.type === adjustType) {
        rst = true;
        return false;
      }
    });
    return rst;
  };

  _proto.hasStack = function hasStack() {
    var isStacked = this.get('isStacked');

    if (Util.isNil(isStacked)) {
      isStacked = this.hasAdjust('stack');
      this.set('isStacked', isStacked);
    }

    return isStacked;
  };

  _proto.isInCircle = function isInCircle() {
    var coord = this.get('coord');
    return coord && coord.isPolar;
  };

  _proto._initContainer = function _initContainer() {
    var self = this;
    var shapeContainer = self.get('shapeContainer');

    if (!shapeContainer) {
      var container = self.get('container');
      var view = self.get('view');
      var viewId = view && view.get('_id');
      shapeContainer = container.addGroup({
        viewId: viewId,
        visible: self.get('visible')
      });
      self.set('shapeContainer', shapeContainer);
    }
  };

  _proto.init = function init() {
    var self = this;

    self._initContainer();

    self._initAttrs();

    if (self.get('tooltipCfg') && self.get('tooltipCfg').fields) {
      var tooltipFields = self.get('tooltipCfg').fields;
      Util.each(tooltipFields, function (field) {
        self._createScale(field);
      });
    }

    var dataArray = self._processData();

    if (self.get('adjusts')) {
      self._adjust(dataArray);
    }

    self.set('dataArray', dataArray);
  } // step 1: init attrs
  ;

  _proto._initAttrs = function _initAttrs() {
    var self = this;
    var attrs = self.get('attrs');
    var attrOptions = self.get('attrOptions');
    var coord = self.get('coord');
    var viewTheme = self.viewTheme || Global;
    var isPie = false;

    for (var type in attrOptions) {
      if (attrOptions.hasOwnProperty(type)) {
        var option = attrOptions[type];
        var className = Util.upperFirst(type);
        var fields = parseFields(option.field);

        if (type === 'position') {
          option.coord = coord; // 楗煎浘鍧愭爣绯讳笅锛屽～鍏呬竴缁�

          if (fields.length === 1 && coord.type === 'theta') {
            fields.unshift('1');
            isPie = true;
          }
        }

        var scales = [];

        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];

          var scale = self._createScale(field);

          if (type === 'color' && Util.isNil(option.values)) {
            // 璁剧疆 color 鐨勯粯璁よ壊鍊�
            if (scale.values.length <= 8) {
              option.values = isPie ? viewTheme.colors_pie : viewTheme.colors;
            } else if (scale.values.length <= 16) {
              option.values = isPie ? viewTheme.colors_pie_16 : viewTheme.colors_16;
            } else {
              option.values = viewTheme.colors_24;
            }

            if (Util.isNil(option.values)) {
              option.values = viewTheme.colors; // 闃叉涓婚娌℃湁澹版槑璇稿 colors_pie 鐨勫睘鎬�
            }
          }

          scales.push(scale);
        } // 楗煎浘闇€瑕佸～鍏呮弧鏁翠釜绌洪棿


        if (coord.type === 'theta' && type === 'position' && scales.length > 1) {
          var yScale = scales[1];
          var min = 0;
          var max = Math.max.apply(null, yScale.values);

          if (!isFinite(max)) {
            max = 1;
          }

          yScale.change({
            nice: false,
            min: min,
            max: max
          });
        }

        option.scales = scales;
        var attr = new Attr[className](option);
        attrs[type] = attr;
      }
    }
  } // step 2: 澶勭悊鏁版嵁
  ;

  _proto._processData = function _processData() {
    var self = this;
    var data = this.get('data');
    var dataArray = [];

    var groupedArray = this._groupData(data);

    for (var i = 0; i < groupedArray.length; i++) {
      var subData = groupedArray[i];

      var tempData = self._saveOrigin(subData);

      dataArray.push(self._numberic(tempData));
    }

    return dataArray;
  } // step 2.1 鏁版嵁鍒嗙粍
  ;

  _proto._groupData = function _groupData(data) {
    var groupScales = this._getGroupScales();

    var fields = groupScales.map(function (scale) {
      return scale.field;
    });
    return Util.Array.group(data, fields);
  } // step 2.2 鏁版嵁璋冩暣鍓嶄繚瀛樺師濮嬫暟鎹�
  ;

  _proto._saveOrigin = function _saveOrigin(data) {
    var rst = [];

    for (var i = 0; i < data.length; i++) {
      var origin = data[i];
      var obj = {};

      for (var k in origin) {
        obj[k] = origin[k];
      } // const obj = Util.mix({}, origin);


      obj[FIELD_ORIGIN] = origin;
      rst.push(obj);
    }

    return rst;
  } // step 2.3 灏嗗垎绫绘暟鎹炕璇戞垚鏁版嵁, 浠呭浣嶇疆鐩稿叧鐨勫害閲忚繘琛屾暟瀛楀寲澶勭悊
  ;

  _proto._numberic = function _numberic(data) {
    var positionAttr = this.getAttr('position');
    var scales = positionAttr.scales;
    var result = [];

    for (var j = 0; j < data.length; j++) {
      var obj = data[j];
      var isValidate = true;

      for (var i = 0; i < Math.min(2, scales.length); i++) {
        var scale = scales[i];

        if (scale.isCategory) {
          var field = scale.field;
          obj[field] = scale.translate(obj[field]);

          if (Number.isNaN(obj[field])) {
            // 褰撳垎绫讳负 NaN 鏃讹紝璇存槑璇ユ潯鏁版嵁涓嶅湪瀹氫箟鍩熷唴锛岄渶瑕佽繃婊ゆ帀
            isValidate = false;
          }
        }
      }

      if (isValidate) {
        result.push(obj);
      }
    }

    return result;
  };

  _proto._getGroupScales = function _getGroupScales() {
    var self = this;
    var scales = self.get('groupScales');

    if (!scales) {
      scales = [];
      var attrs = self.get('attrs');
      Util.each(attrs, function (attr) {
        if (GROUP_ATTRS.includes(attr.type)) {
          var attrScales = attr.scales;
          Util.each(attrScales, function (scale) {
            if (scale.isCategory && Util.indexOf(scales, scale) === -1) {
              scales.push(scale);
            }
          });
        }
      });
      self.set('groupScales', scales);
    }

    return scales;
  };

  _proto._updateStackRange = function _updateStackRange(field, scale, dataArray) {
    var mergeArray = Util.Array.merge(dataArray);
    var min = scale.min;
    var max = scale.max;

    for (var i = 0; i < mergeArray.length; i++) {
      var obj = mergeArray[i]; // 杩囨护鎺夐潪娉曟暟鎹�

      if (!Util.isArray(obj[field])) {
        continue;
      }

      var tmpMin = Math.min.apply(null, obj[field]);
      var tmpMax = Math.max.apply(null, obj[field]);

      if (tmpMin < min) {
        min = tmpMin;
      }

      if (tmpMax > max) {
        max = tmpMax;
      }
    }

    if (min < scale.min || max > scale.max) {
      scale.change({
        min: min,
        max: max
      });
    }
  } // step 2.2 璋冩暣鏁版嵁
  ;

  _proto._adjust = function _adjust(dataArray) {
    // 褰撴暟鎹负绌虹殑鏃跺€欙紝灏变笉闇€瑕佸鏁版嵁杩涜璋冩暣浜�
    if (!dataArray || !dataArray.length) {
      return;
    }

    var self = this;
    var adjusts = self.get('adjusts');
    var viewTheme = this.viewTheme || Global;
    var yScale = self.getYScale();
    var xScale = self.getXScale();
    var xField = xScale.field;
    var yField = yScale ? yScale.field : null;
    Util.each(adjusts, function (adjust) {
      var adjustCfg = Util.mix({
        xField: xField,
        yField: yField
      }, adjust);
      var adjustType = Util.upperFirst(adjust.type);

      if (adjustType === 'Dodge') {
        var adjustNames = [];

        if (xScale.isCategory || xScale.isIdentity) {
          adjustNames.push('x');
        } else if (!yScale) {
          adjustNames.push('y');
        } else {
          throw new Error('dodge is not support linear attribute, please use category attribute!');
        }

        adjustCfg.adjustNames = adjustNames;
        adjustCfg.dodgeRatio = adjustCfg.dodgeRatio || viewTheme.widthRatio.column;
        /* if (self.isInCircle()) {
          adjustCfg.dodgeRatio = 1;
          adjustCfg.marginRatio = 0;
        }*/
      } else if (adjustType === 'Stack') {
        var coord = self.get('coord');

        if (!yScale) {
          // 涓€缁寸殑鎯呭喌涓嬭幏鍙栭珮搴﹀拰榛樿size
          adjustCfg.height = coord.getHeight();
          var size = self.getDefaultValue('size') || 3;
          adjustCfg.size = size;
        } // 涓嶈繘琛� transpose 鏃讹紝鐢ㄦ埛鍙堟病鏈夎缃繖涓弬鏁版椂锛岄粯璁や粠涓婂悜涓�


        if (!coord.isTransposed && Util.isNil(adjustCfg.reverseOrder)) {
          adjustCfg.reverseOrder = true;
        }
      }

      var adjustElement = new Adjust[adjustType](adjustCfg);
      adjustElement.processAdjust(dataArray);

      if (adjustType === 'Stack' && yScale) {
        self._updateStackRange(yField, yScale, dataArray);
      }
    });
  }
  /**
   * @internal 璁剧疆coord锛岄€氬父澶栭儴瀹瑰櫒鍙樺寲鏃讹紝coord 浼氬彂鐢熷彉鍖�
   * @param {Object} coord 鍧愭爣绯�
   */
  ;

  _proto.setCoord = function setCoord(coord) {
    this.set('coord', coord);
    var position = this.getAttr('position');
    var shapeContainer = this.get('shapeContainer');
    shapeContainer.setMatrix(coord.matrix);

    if (position) {
      position.coord = coord;
    }
  } // step 3 缁樺埗
  ;

  _proto.paint = function paint() {
    var self = this;
    var dataArray = self.get('dataArray');
    var mappedArray = [];
    var shapeFactory = self.getShapeFactory();
    shapeFactory.setCoord(self.get('coord'));
    self.set('shapeFactory', shapeFactory);
    var shapeContainer = self.get('shapeContainer');

    self._beforeMapping(dataArray);

    for (var i = 0; i < dataArray.length; i++) {
      var data = dataArray[i];
      var index = i;
      data = self._mapping(data);
      mappedArray.push(data);
      self.draw(data, shapeContainer, shapeFactory, index);
    }

    if (self.get('labelCfg')) {
      self._addLabels(Util.union.apply(null, mappedArray), shapeContainer.get('children'));
    }

    if (!self.get('sortable')) {
      self._sort(mappedArray); // 渚夸簬鏁版嵁鐨勬煡鎵撅紝闇€瑕佸鏁版嵁杩涜鎺掑簭锛岀敤浜� geom.findPoint()

    } else {
      self.set('dataArray', mappedArray);
    }
  };

  _proto._sort = function _sort(mappedArray) {
    var self = this;
    var xScale = self.getXScale();
    var xField = xScale.field;
    Util.each(mappedArray, function (itemArr) {
      itemArr.sort(function (obj1, obj2) {
        return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);
      });
    });
    self.set('dataArray', mappedArray);
  } // step 3.1 before mapping
  ;

  _proto._beforeMapping = function _beforeMapping(dataArray) {
    var self = this;

    if (self.get('sortable')) {
      var xScale = self.getXScale();
      var field = xScale.field;
      Util.each(dataArray, function (data) {
        data.sort(function (v1, v2) {
          return xScale.translate(v1[field]) - xScale.translate(v2[field]);
        });
      });
    }

    if (self.get('generatePoints')) {
      Util.each(dataArray, function (data) {
        self._generatePoints(data);
      });
      Util.each(dataArray, function (data, index) {
        var nextData = dataArray[index + 1];

        if (nextData) {
          data[0].nextPoints = nextData[0].points;
        }
      });
    }
  } // step 3.2 add labels
  ;

  _proto._addLabels = function _addLabels(points, shapes) {
    var self = this;
    var type = self.get('type');
    var viewTheme = self.get('viewTheme') || Global;
    var coord = self.get('coord');
    var C = Labels.getLabelsClass(coord.type, type);
    var container = self.get('container');
    var scales = Util.map(self.get('labelCfg').fields, function (field) {
      return self._createScale(field);
    });
    var labelContainer = container.addGroup(C, {
      _id: this.get('_id'),
      labelCfg: Util.mix({
        scales: scales
      }, self.get('labelCfg')),
      coord: coord,
      geom: self,
      geomType: type,
      yScale: self.getYScale(),
      viewTheme: viewTheme,
      visible: self.get('visible')
    });
    labelContainer.showLabels(points, shapes);
    self.set('labelContainer', labelContainer);
  }
  /**
   * @protected
   * 鑾峰彇鍥惧舰鐨勫伐鍘傜被
   * @return {Object} 宸ュ巶绫诲璞�
   */
  ;

  _proto.getShapeFactory = function getShapeFactory() {
    var shapeFactory = this.get('shapeFactory');

    if (!shapeFactory) {
      var shapeType = this.get('shapeType');
      shapeFactory = Shape.getShapeFactory(shapeType);
      this.set('shapeFactory', shapeFactory);
    }

    return shapeFactory;
  } // step 3.2 generate points
  ;

  _proto._generatePoints = function _generatePoints(data) {
    var self = this;
    var shapeFactory = self.getShapeFactory();
    var shapeAttr = self.getAttr('shape');

    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var cfg = self.createShapePointsCfg(obj);
      var shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;
      var points = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points;
    }
  }
  /**
   * 鑾峰彇鍥惧舰瀵瑰簲鐐圭殑閰嶇疆椤�
   * @protected
   * @param  {Object} obj 鏁版嵁瀵硅薄
   * @return {Object} cfg 鑾峰彇鍥惧舰瀵瑰簲鐐圭殑閰嶇疆椤�
   */
  ;

  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();

    var x = this._normalizeValues(obj[xScale.field], xScale);

    var y; // 瀛樺湪娌℃湁 y 鐨勬儏鍐�

    if (yScale) {
      y = this._normalizeValues(obj[yScale.field], yScale);
    } else {
      y = obj.y ? obj.y : 0.1;
    }

    return {
      x: x,
      y: y,
      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
    };
  }
  /**
   * @protected
   * 濡傛灉y杞寸殑鏈€灏忓€煎皬浜�0鍒欒繑鍥�0锛屽惁鍒欒繑鍥炴渶灏忓€�
   * @return {Number} y杞翠笂鐨勬渶灏忓€�
   */
  ;

  _proto.getYMinValue = function getYMinValue() {
    var yScale = this.getYScale();
    var min = yScale.min,
        max = yScale.max;
    var value;

    if (min >= 0) {
      value = min;
    } else if (max <= 0) {
      // 褰撳€煎叏浣嶄簬璐熷尯闂存椂锛岄渶瑕佷繚璇� ymin 鍦ㄥ尯鍩熷唴锛屼笉鍙负 0
      value = max;
    } else {
      value = 0;
    }

    return value;
  } // 灏嗘暟鎹綊涓€鍖�
  ;

  _proto._normalizeValues = function _normalizeValues(values, scale) {
    var rst = [];

    if (Util.isArray(values)) {
      for (var i = 0; i < values.length; i++) {
        var v = values[i];
        rst.push(scale.scale(v));
      }
    } else {
      rst = scale.scale(values);
    }

    return rst;
  } // step 3.2 mapping
  ;

  _proto._mapping = function _mapping(data) {
    var self = this;
    var attrs = self.get('attrs');
    var mappedData = [];

    for (var i = 0; i < data.length; i++) {
      var record = data[i];
      var newRecord = {};
      newRecord[FIELD_ORIGIN] = record[FIELD_ORIGIN];
      newRecord.points = record.points;
      newRecord.nextPoints = record.nextPoints;

      for (var k in attrs) {
        if (attrs.hasOwnProperty(k)) {
          var attr = attrs[k];
          var names = attr.names;

          var values = self._getAttrValues(attr, record);

          if (names.length > 1) {
            // position 涔嬬被鐨勭敓鎴愬涓瓧娈电殑灞炴€�
            for (var j = 0; j < values.length; j++) {
              var val = values[j];
              var name = names[j];
              newRecord[name] = Util.isArray(val) && val.length === 1 ? val[0] : val; // 鍙湁涓€涓€兼椂杩斿洖绗竴涓睘鎬у€�
            }
          } else {
            newRecord[names[0]] = values.length === 1 ? values[0] : values;
          }
        }
      }

      mappedData.push(newRecord);
    }

    return mappedData;
  } // 鑾峰彇灞炴€ф槧灏勭殑鍊�
  ;

  _proto._getAttrValues = function _getAttrValues(attr, record) {
    var scales = attr.scales;
    var params = [];

    for (var i = 0; i < scales.length; i++) {
      var scale = scales[i];
      var field = scale.field;

      if (scale.type === 'identity') {
        params.push(scale.value);
      } else {
        params.push(record[field]);
      }
    }

    var values = attr.mapping.apply(attr, params);
    return values;
  };

  _proto.getAttrValue = function getAttrValue(attrName, record) {
    var attr = this.getAttr(attrName);
    var rst = null;

    if (attr) {
      var values = this._getAttrValues(attr, record);

      rst = values[0];
    }

    return rst;
  };

  _proto.getDefaultValue = function getDefaultValue(attrName) {
    var value = this.get(attrName);
    var attr = this.getAttr(attrName);

    if (attr) {
      var scale = attr.getScale(attrName);

      if (scale.type === 'identity') {
        value = scale.value;
      }
    }

    return value;
  }
  /**
   * step 3.3 draw
   * @protected
   * @param  {Array} data 缁樺埗鍥惧舰
   * @param {Object} container 缁樺浘瀹瑰櫒
   * @param {Object} shapeFactory 缁樺埗鍥惧舰鐨勫伐鍘傜被
   * @param {Number} index 姣忎釜 shape 鐨勭储寮曞€�
   */
  ;

  _proto.draw = function draw(data, container, shapeFactory, index) {
    var self = this;

    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      self.drawPoint(obj, container, shapeFactory, index + i);
    }
  };

  _proto.getCallbackCfg = function getCallbackCfg(fields, cfg, origin) {
    if (!fields) {
      return cfg;
    }

    var tmpCfg = {};
    var params = fields.map(function (field) {
      return origin[field];
    });
    Util.each(cfg, function (v, k) {
      if (Util.isFunction(v)) {
        tmpCfg[k] = v.apply(null, params);
      } else {
        tmpCfg[k] = v;
      }
    });
    return tmpCfg;
  };

  _proto._getShapeId = function _getShapeId(dataObj) {
    var id = this.get('_id');
    var keyFields = this.get('keyFields');

    if (keyFields && keyFields.length > 0) {
      Util.each(keyFields, function (key) {
        id += '-' + dataObj[key];
      });
    } else {
      var type = this.get('type');
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field || 'x';
      var yField = yScale.field || 'y';
      var yVal = dataObj[yField];
      var xVal;

      if (xScale.isIdentity) {
        xVal = xScale.value;
      } else {
        xVal = dataObj[xField];
      }

      if (type === 'interval' || type === 'schema') {
        id += '-' + xVal;
      } else if (type === 'line' || type === 'area' || type === 'path') {
        id += '-' + type;
      } else {
        id += '-' + xVal + '-' + yVal;
      }

      var groupScales = this._getGroupScales();

      if (!Util.isEmpty(groupScales)) {
        Util.each(groupScales, function (groupScale) {
          var field = groupScale.field;

          if (groupScale.type !== 'identity') {
            id += '-' + dataObj[field];
          }
        });
      }
    }

    return id;
  };

  _proto.getDrawCfg = function getDrawCfg(obj) {
    var self = this;
    var cfg = {
      origin: obj,
      x: obj.x,
      y: obj.y,
      color: obj.color,
      size: obj.size,
      shape: obj.shape,
      isInCircle: self.isInCircle(),
      opacity: obj.opacity
    };
    var styleOptions = self.get('styleOptions');

    if (styleOptions && styleOptions.style) {
      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);
    }

    if (self.get('generatePoints')) {
      cfg.points = obj.points;
      cfg.nextPoints = obj.nextPoints;
    }

    if (self.get('animate')) {
      // _id 瀛楁浠呯敤浜庡姩鐢�
      cfg._id = self._getShapeId(obj[FIELD_ORIGIN]);
    }

    return cfg;
  };

  _proto.appendShapeInfo = function appendShapeInfo(shape, index) {
    if (shape) {
      shape.setSilent('index', index);
      shape.setSilent('coord', this.get('coord'));

      if (this.get('animate') && this.get('animateCfg')) {
        shape.setSilent('animateCfg', this.get('animateCfg'));
      }
    }
  };

  _proto._applyViewThemeShapeStyle = function _applyViewThemeShapeStyle(cfg, shape, shapeFactory) {
    // applying view theme
    var self = this;
    var viewTheme = self.viewTheme || Global;
    var shapeName = shapeFactory.name;

    if (shape) {
      if (shape && (shape.indexOf('hollow') > -1 || shape.indexOf('liquid') > -1)) {
        shapeName = "hollow" + Util.upperFirst(shapeName);
      }
    } else if (shapeFactory.defaultShapeType.indexOf('hollow') > -1) {
      shapeName = "hollow" + Util.upperFirst(shapeName);
    }

    var defaultStyle = viewTheme.shape[shapeName] || {};
    cfg.style = Util.mix({}, defaultStyle, cfg.style);
  };

  _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {
    var self = this;
    var shape = obj.shape;
    var cfg = self.getDrawCfg(obj);

    self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);

    var geomShape = shapeFactory.drawShape(shape, cfg, container);
    self.appendShapeInfo(geomShape, index);
  }
  /**
   * 鑾峰彇灞炴€�
   * @protected
   * @param {String} name 灞炴€у悕
   * @return {Scale} 搴﹂噺
   */
  ;

  _proto.getAttr = function getAttr(name) {
    return this.get('attrs')[name];
  }
  /**
   * 鑾峰彇 x 瀵瑰簲鐨勫害閲�
   * @return {Scale} x 瀵瑰簲鐨勫害閲�
   */
  ;

  _proto.getXScale = function getXScale() {
    return this.getAttr('position').scales[0];
  }
  /**
   * 鑾峰彇 y 瀵瑰簲鐨勫害閲�
   * @return {Scale} y 瀵瑰簲鐨勫害閲�
   */
  ;

  _proto.getYScale = function getYScale() {
    return this.getAttr('position').scales[1];
  };

  _proto.getShapes = function getShapes() {
    var result = [];
    var shapeContainer = this.get('shapeContainer');
    var children = shapeContainer.get('children');
    Util.each(children, function (child) {
      if (child.get('origin')) {
        // 杩囨护 label
        result.push(child);
      }
    });
    return result;
  };

  _proto.getAttrsForLegend = function getAttrsForLegend() {
    var attrs = this.get('attrs');
    var rst = [];
    Util.each(attrs, function (attr) {
      if (GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };

  _proto.getFieldsForLegend = function getFieldsForLegend() {
    var fields = [];
    var attrOptions = this.get('attrOptions');
    Util.each(GROUP_ATTRS, function (attrName) {
      var attrCfg = attrOptions[attrName];

      if (attrCfg && attrCfg.field && Util.isString(attrCfg.field)) {
        fields = fields.concat(attrCfg.field.split('*'));
      }
    });
    return Util.uniq(fields);
  };

  _proto.changeVisible = function changeVisible(visible, stopDraw) {
    var me = this;
    me.set('visible', visible);
    var shapeContainer = this.get('shapeContainer');

    if (shapeContainer) {
      shapeContainer.set('visible', visible);
    }

    var labelContainer = this.get('labelContainer');

    if (labelContainer) {
      labelContainer.set('visible', visible);
    }

    if (!stopDraw && shapeContainer) {
      var canvas = shapeContainer.get('canvas');
      canvas.draw();
    }
  };

  _proto.reset = function reset() {
    this.set('attrOptions', {});
    this.clearInner();
  };

  _proto.clearInner = function clearInner() {
    this.clearActivedShapes();
    this.clearSelected();
    var shapeContainer = this.get('shapeContainer');
    shapeContainer && shapeContainer.clear(); // 鐢变簬 Labels 瀵瑰簲鐨勬ā鍧楅渶瑕佺敓鎴恎roup锛屾墍浠ヨ繖涓湴鏂归渶瑕佸垹闄�

    var labelContainer = this.get('labelContainer');
    labelContainer && labelContainer.remove();
    this.set('attrs', {});
    this.set('groupScales', null); // if (!this.get('hasDefaultAdjust')) {
    //   this.set('adjusts', null);
    // }

    this.set('labelContainer', null);
    this.set('xDistance', null);
    this.set('isStacked', null);
  };

  _proto.clear = function clear() {
    this.clearInner();
    this.set('scales', {});
  };

  _proto.destroy = function destroy() {
    this.clear();
    var shapeContainer = this.get('shapeContainer');
    shapeContainer && shapeContainer.remove();
    this.offEvents();

    _Base.prototype.destroy.call(this);
  };

  _proto.bindEvents = function bindEvents() {
    if (this.get('view')) {
      this._bindActiveAction();

      this._bindSelectedAction();
    }
  };

  _proto.offEvents = function offEvents() {
    if (this.get('view')) {
      this._offActiveAction();

      this._offSelectedAction();
    }
  };

  return GeomBase;
}(Base);

module.exports = GeomBase;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 宸ュ巶绫伙紝绠＄悊鍚勭绫诲瀷鐨� shape
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var PathUtil = __webpack_require__(25);

var GPath = Util.PathUtil;
var Shape = {};
var ShapeBase = {
  _coord: null,

  /**
   * 缁樺埗鍥惧舰
   * @param {Object} cfg 閰嶇疆椤�
   * @param {Object} container 瀹瑰櫒
   * @return {Object} shape 鍒涘缓鐨� shape
   */
  draw: function draw(cfg, container) {
    if (this.drawShape) {
      return this.drawShape(cfg, container);
    }

    return null;
  },

  /**
   * 鑾峰彇缁樺埗鍥惧舰闇€瑕佺殑鐐�, 鍙互涓嶅畾涔夛紝鍒欎娇鐢ㄩ粯璁ょ殑
  getPoints(cfg) {
    if (this.getShapePoints) {
      return this.getShapePoints(cfg);
    }
    return null;
  },*/

  /**
   * 璁剧疆鍧愭爣绯�
   * @param {Coord} coord 鍧愭爣绯�
   */
  setCoord: function setCoord(coord) {
    this._coord = coord;
  },

  /**
   * 0锝�1 path 杞� 鐢诲竷 path
   * @param  {path} path 璺緞
   * @param  {Boolean} islineToArc 鏄惁杞崲鎴愬渾寮�
   * @return {path} path 杞崲鍒扮敾甯冨潗鏍囩殑path
   */
  parsePath: function parsePath(path, islineToArc) {
    var coord = this._coord;
    path = GPath.parsePathString(path);

    if (coord.isPolar && islineToArc !== false) {
      path = PathUtil.convertPolarPath(coord, path);
    } else {
      path = PathUtil.convertNormalPath(coord, path);
    }

    return path;
  },

  /**
   * 0锝�1 point 杞� 鐢诲竷 point
   * @param  {point} point 鑺傜偣
   * @return {point} point 杞崲鍚庣殑鐐�
   */
  parsePoint: function parsePoint(point) {
    var coord = this._coord;
    return coord.convertPoint(point);
  },

  /**
   * 0锝�1 points 杞� 鐢诲竷 points
   * @param  {points} points 鑺傜偣闆嗗悎
   * @return {points} points 杞崲鍚庣殑澶氫釜鑺傜偣
   */
  parsePoints: function parsePoints(points) {
    var coord = this._coord;
    var rst = [];
    Util.each(points, function (point) {
      rst.push(coord.convertPoint(point));
    });
    return rst;
  }
};
var ShapeFactoryBase = {
  defaultShapeType: null,
  setCoord: function setCoord(coord) {
    this._coord = coord;
  },
  getShape: function getShape(type) {
    var self = this;

    if (Util.isArray(type)) {
      type = type[0];
    }

    var shape = self[type] || self[self.defaultShapeType];
    shape._coord = self._coord;
    return shape;
  },
  getShapePoints: function getShapePoints(type, cfg) {
    var shape = this.getShape(type);
    var fn = shape.getPoints || shape.getShapePoints || this.getDefaultPoints;
    var points = fn(cfg);
    return points;
  },
  getDefaultPoints: function getDefaultPoints()
  /* cfg */
  {
    return [];
  },
  getMarkerCfg: function getMarkerCfg(type, cfg) {
    var shape = this.getShape(type);

    if (!shape.getMarkerCfg) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }

    return shape.getMarkerCfg(cfg);
  },
  getSelectedCfg: function getSelectedCfg()
  /* type, cfg */
  {
    return {};
  },
  drawShape: function drawShape(type, cfg, container) {
    var shape = this.getShape(type);
    var gShape = shape.draw(cfg, container);

    if (gShape) {
      gShape.setSilent('origin', cfg.origin);
      gShape._id = cfg.yIndex ? cfg._id + cfg.yIndex : cfg._id;
      gShape.name = this.name;
    }

    return gShape;
  }
}; // 娉ㄥ唽 Geometry 鑾峰彇鍥惧舰鐨勫叆鍙�

Shape.registerFactory = function (factoryName, cfg) {
  var className = Util.upperFirst(factoryName);
  var geomObj = Util.assign({}, ShapeFactoryBase, cfg);
  Shape[className] = geomObj;
  geomObj.name = factoryName;
  return geomObj;
}; // 娉ㄥ唽鍥惧舰


Shape.registerShape = function (factoryName, shapeType, cfg) {
  var className = Util.upperFirst(factoryName);
  var factory = Shape[className];
  var shapeObj = Util.assign({}, ShapeBase, cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}; // 鑾峰緱Geom 瀵瑰簲鐨� shapeFactory


Shape.getShapeFactory = function (factoryName) {
  var self = this;
  factoryName = factoryName || 'point';
  var className = Util.upperFirst(factoryName);
  return self[className];
};

module.exports = Shape;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
      dist[key] = obj[key];
    }
  }
}

var mix = function mix(dist, src1, src2, src3) {
  if (src1) _mix(dist, src1);
  if (src2) _mix(dist, src2);
  if (src3) _mix(dist, src3);
  return dist;
};

module.exports = mix;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 鍒ゆ柇鏄惁鏁板瓧
 * @return {Boolean} 鏄惁鏁板瓧
 */
var isType = __webpack_require__(17);

var isNumber = function isNumber(value) {
  return isType(value, 'Number');
};
module.exports = isNumber;

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__color_js__ = __webpack_require__(89);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_0__color_js__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_0__color_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__color_js__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lab_js__ = __webpack_require__(440);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__lab_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__lab_js__["a"]; });
/* unused harmony reexport lch */
/* unused harmony reexport gray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cubehelix_js__ = __webpack_require__(439);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__cubehelix_js__["a"]; });





/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CREATED */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return STARTING; });
/* unused harmony export STARTED */
/* unused harmony export RUNNING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ENDED; });
/* harmony export (immutable) */ __webpack_exports__["g"] = init;
/* harmony export (immutable) */ __webpack_exports__["e"] = set;
/* harmony export (immutable) */ __webpack_exports__["f"] = get;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_timer__ = __webpack_require__(103);



var emptyOn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["h"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 鏄惁涓哄嚱鏁�
 * @param  {*} fn 瀵硅薄
 * @return {Boolean}  鏄惁鍑芥暟
 */
var isType = __webpack_require__(17);

var isFunction = function isFunction(value) {
  return isType(value, 'Function');
};

module.exports = isFunction;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(17);

var isString = function isString(str) {
  return isType(str, 'String');
};

module.exports = isString;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var G = __webpack_require__(31);

module.exports = G;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var toString = {}.toString;
var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};

module.exports = isType;

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return root; });
/* harmony export (immutable) */ __webpack_exports__["b"] = Selection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__select__ = __webpack_require__(505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectAll__ = __webpack_require__(506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(493);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__data__ = __webpack_require__(487);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enter__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__exit__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__join__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__merge__ = __webpack_require__(498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__order__ = __webpack_require__(501);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__sort__ = __webpack_require__(508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__call__ = __webpack_require__(484);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__nodes__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__node__ = __webpack_require__(499);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__size__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__empty__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__each__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__attr__ = __webpack_require__(483);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__style__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__property__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__classed__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__text__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__html__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__raise__ = __webpack_require__(503);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__lower__ = __webpack_require__(497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__append__ = __webpack_require__(482);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__insert__ = __webpack_require__(495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__remove__ = __webpack_require__(504);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__clone__ = __webpack_require__(486);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__datum__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__on__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__dispatch__ = __webpack_require__(489);
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: __WEBPACK_IMPORTED_MODULE_0__select__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_1__selectAll__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_2__filter__["a" /* default */],
  data: __WEBPACK_IMPORTED_MODULE_3__data__["a" /* default */],
  enter: __WEBPACK_IMPORTED_MODULE_4__enter__["a" /* default */],
  exit: __WEBPACK_IMPORTED_MODULE_5__exit__["a" /* default */],
  join: __WEBPACK_IMPORTED_MODULE_6__join__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_7__merge__["a" /* default */],
  order: __WEBPACK_IMPORTED_MODULE_8__order__["a" /* default */],
  sort: __WEBPACK_IMPORTED_MODULE_9__sort__["a" /* default */],
  call: __WEBPACK_IMPORTED_MODULE_10__call__["a" /* default */],
  nodes: __WEBPACK_IMPORTED_MODULE_11__nodes__["a" /* default */],
  node: __WEBPACK_IMPORTED_MODULE_12__node__["a" /* default */],
  size: __WEBPACK_IMPORTED_MODULE_13__size__["a" /* default */],
  empty: __WEBPACK_IMPORTED_MODULE_14__empty__["a" /* default */],
  each: __WEBPACK_IMPORTED_MODULE_15__each__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_16__attr__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_17__style__["b" /* default */],
  property: __WEBPACK_IMPORTED_MODULE_18__property__["a" /* default */],
  classed: __WEBPACK_IMPORTED_MODULE_19__classed__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_20__text__["a" /* default */],
  html: __WEBPACK_IMPORTED_MODULE_21__html__["a" /* default */],
  raise: __WEBPACK_IMPORTED_MODULE_22__raise__["a" /* default */],
  lower: __WEBPACK_IMPORTED_MODULE_23__lower__["a" /* default */],
  append: __WEBPACK_IMPORTED_MODULE_24__append__["a" /* default */],
  insert: __WEBPACK_IMPORTED_MODULE_25__insert__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_26__remove__["a" /* default */],
  clone: __WEBPACK_IMPORTED_MODULE_27__clone__["a" /* default */],
  datum: __WEBPACK_IMPORTED_MODULE_28__datum__["a" /* default */],
  on: __WEBPACK_IMPORTED_MODULE_29__on__["c" /* default */],
  dispatch: __WEBPACK_IMPORTED_MODULE_30__dispatch__["a" /* default */]
};

/* harmony default export */ __webpack_exports__["a"] = (selection);


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = {
  FONT_FAMILY: '"-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",SimSun, "sans-serif"'
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Helper = __webpack_require__(109);

var Component = __webpack_require__(36);

var KEYWORDS = ['min', 'max', 'median', 'start', 'end'];

var Guide =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Guide, _Component);

  function Guide() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Guide.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Component.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      xScales: null,
      yScales: null,
      el: null
    });
  };

  _proto.render = function render() {}
  /**
   * clear container
   * @override
   */
  ;

  _proto.clear = function clear() {
    var self = this;
    var el = self.get('el');
    el && el.remove();
    this.set('el', null);
  };

  _proto.destroy = function destroy() {
    this.clear();

    _Component.prototype.destroy.call(this);
  }
  /**
   * show or hide
   * @protected
   * @param {Boolean} visible true means show, false means hide
   */
  ;

  _proto.changeVisible = function changeVisible(visible) {
    var self = this;
    self.set('visible', visible);
    var el = self.get('el');
    if (!el) return;

    if (el.set) {
      el.set('visible', visible);
    } else {
      el.style.display = visible ? '' : 'none';
    }
  }
  /**
   * calculate the canvas coordinate value
   * @protected
   * @param  {Coordinate} coord  the instance of Coordinate class
   * @param  {Object | Array | Function} position the value need to convert
   * @return {Object} return the result
   */
  ;

  _proto.parsePoint = function parsePoint(coord, position) {
    var self = this;
    var xScales = self.get('xScales');
    var yScales = self.get('yScales');

    if (Util.isFunction(position)) {
      position = position(xScales, yScales);
    }

    var x;
    var y; // 濡傛灉鏁版嵁鏍煎紡鏄� ['50%', '50%'] 鐨勬牸寮�

    if (Util.isArray(position) && Util.isString(position[0]) && position[0].indexOf('%') !== -1) {
      return this._parsePercentPoint(coord, position);
    }

    if (Util.isArray(position)) {
      // Array锛宻uuport for mixing of keyword, percent and value
      x = self._getNormalizedValue(position[0], Helper.getFirstScale(xScales));
      y = self._getNormalizedValue(position[1], Helper.getFirstScale(yScales));
    } else {
      for (var field in position) {
        var value = position[field];

        if (xScales[field]) {
          x = self._getNormalizedValue(value, xScales[field]);
        }

        if (yScales[field]) {
          y = self._getNormalizedValue(value, yScales[field], 'y');
        }
      }
    }

    if (!Util.isNil(x) && !Util.isNil(y) && !isNaN(x) && !isNaN(y)) {
      return coord.convert({
        x: x,
        y: y
      });
    }

    return null;
  }
  /**
   * Normalized the value
   * @param  {String | Number} val   param
   * @param  {Scale} scale the instance of Scale
   * @return {Number}       return the normalized value
   */
  ;

  _proto._getNormalizedValue = function _getNormalizedValue(val, scale) {
    var result;

    if (Util.indexOf(KEYWORDS, val) !== -1) {
      // keyword
      var scaleValue;

      if (val === 'start') {
        // the start of coordinate
        result = 0;
      } else if (val === 'end') {
        result = 1;
      } else if (val === 'median') {
        scaleValue = scale.isCategory ? (scale.values.length - 1) / 2 : (scale.min + scale.max) / 2;
        result = scale.scale(scaleValue);
      } else {
        if (scale.isCategory) {
          scaleValue = val === 'min' ? 0 : scale.values.length - 1;
        } else {
          scaleValue = scale[val];
        }

        result = scale.scale(scaleValue);
      }
    } else {
      // 鏁板€�
      result = scale.scale(val);
    }

    return result;
  };

  _proto._parsePercentPoint = function _parsePercentPoint(coord, position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var start = coord.start,
        end = coord.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x = coord.width * xPercent + topLeft.x;
    var y = coord.height * yPercent + topLeft.y;
    return {
      x: x,
      y: y
    };
  };

  return Guide;
}(Component);

module.exports = Guide;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

var isArrayLike = function isArrayLike(value) {
  /**
   * isArrayLike([1, 2, 3]) => true
   * isArrayLike(document.body.children) => true
   * isArrayLike('abc') => true
   * isArrayLike(Function) => false
   */
  return value !== null && typeof value !== 'function' && isFinite(value.length);
};

module.exports = isArrayLike;

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create__ = __webpack_require__(478);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return __WEBPACK_IMPORTED_MODULE_0__create__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__creator__ = __webpack_require__(61);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return __WEBPACK_IMPORTED_MODULE_1__creator__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__local__ = __webpack_require__(479);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "local", function() { return __WEBPACK_IMPORTED_MODULE_2__local__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__matcher__ = __webpack_require__(214);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return __WEBPACK_IMPORTED_MODULE_3__matcher__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mouse__ = __webpack_require__(480);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return __WEBPACK_IMPORTED_MODULE_4__mouse__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__namespace__ = __webpack_require__(97);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return __WEBPACK_IMPORTED_MODULE_5__namespace__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__namespaces__ = __webpack_require__(98);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return __WEBPACK_IMPORTED_MODULE_6__namespaces__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__point__ = __webpack_require__(62);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return __WEBPACK_IMPORTED_MODULE_7__point__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__select__ = __webpack_require__(215);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "select", function() { return __WEBPACK_IMPORTED_MODULE_8__select__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__selectAll__ = __webpack_require__(481);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return __WEBPACK_IMPORTED_MODULE_9__selectAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__selection_index__ = __webpack_require__(18);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return __WEBPACK_IMPORTED_MODULE_10__selection_index__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__selector__ = __webpack_require__(100);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return __WEBPACK_IMPORTED_MODULE_11__selector__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__selectorAll__ = __webpack_require__(219);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return __WEBPACK_IMPORTED_MODULE_12__selectorAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__selection_style__ = __webpack_require__(218);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return __WEBPACK_IMPORTED_MODULE_13__selection_style__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__touch__ = __webpack_require__(510);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return __WEBPACK_IMPORTED_MODULE_14__touch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__touches__ = __webpack_require__(511);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return __WEBPACK_IMPORTED_MODULE_15__touches__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__window__ = __webpack_require__(102);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return __WEBPACK_IMPORTED_MODULE_16__window__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__selection_on__ = __webpack_require__(99);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return __WEBPACK_IMPORTED_MODULE_17__selection_on__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return __WEBPACK_IMPORTED_MODULE_17__selection_on__["b"]; });




















/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview shape 鐨勮緟鍔╂柟娉�
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var ShapeUtil = {
  splitPoints: function splitPoints(obj) {
    var points = [];
    var x = obj.x;
    var y = obj.y;
    y = Util.isArray(y) ? y : [y];
    Util.each(y, function (yItem, index) {
      var point = {
        x: Util.isArray(x) ? x[index] : x,
        y: yItem
      };
      points.push(point);
    });
    return points;
  },
  addFillAttrs: function addFillAttrs(attrs, cfg) {
    if (cfg.color) {
      attrs.fill = cfg.color;
    }

    if (Util.isNumber(cfg.opacity)) {
      attrs.opacity = attrs.fillOpacity = cfg.opacity;
    }
  },
  addStrokeAttrs: function addStrokeAttrs(attrs, cfg) {
    if (cfg.color) {
      attrs.stroke = cfg.color;
    }

    if (Util.isNumber(cfg.opacity)) {
      attrs.opacity = attrs.strokeOpacity = cfg.opacity;
    }
  }
};
module.exports = ShapeUtil;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(42);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseComponent = function (_Component) {
  _inherits(BaseComponent, _Component);

  function BaseComponent(props, name) {
    _classCallCheck(this, BaseComponent);

    var _this = _possibleConstructorReturn(this, (BaseComponent.__proto__ || Object.getPrototypeOf(BaseComponent)).call(this, props));

    _this.getParentInfo = function () {
      return {
        id: _this.id,
        name: _this.name
      };
    };

    _this.name = name;
    return _this;
  }

  _createClass(BaseComponent, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        addElement: this.context.addElement,
        updateElement: this.context.updateElement,
        deleteElement: this.context.deleteElement,
        createId: this.context.createId,
        getParentInfo: this.getParentInfo,
        getViewId: this.context.getViewId
      };
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      var context = this.context;
      this.id = context.createId();
      context.addElement(this.name, this.id, this.props, context.getParentInfo(), context.getViewId());
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.context.updateElement(this.name, this.id, nextProps, this.context.getParentInfo(), this.context.getViewId());
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.context.deleteElement(this.name, this.id);
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;

      if (children) {
        if (children.length) {
          children = _react2.default.createElement(
            'div',
            null,
            children
          );
        }
      } else {
        children = null;
      }

      return children;
    }
  }]);

  return BaseComponent;
}(_react.Component);

BaseComponent.contextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
BaseComponent.childContextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};


function generateBaseTypedComponent(name) {
  var TypedComponent = function (_BaseComponent) {
    _inherits(TypedComponent, _BaseComponent);

    function TypedComponent(props) {
      _classCallCheck(this, TypedComponent);

      return _possibleConstructorReturn(this, (TypedComponent.__proto__ || Object.getPrototypeOf(TypedComponent)).call(this, props, name));
    }

    _createClass(TypedComponent, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          addElement: this.context.addElement,
          updateElement: this.context.updateElement,
          deleteElement: this.context.deleteElement,
          createId: this.context.createId,
          getParentInfo: this.getParentInfo,
          getViewId: this.context.getViewId
        };
      }
    }]);

    return TypedComponent;
  }(BaseComponent);

  TypedComponent.contextTypes = {
    addElement: _propTypes2.default.func,
    updateElement: _propTypes2.default.func,
    deleteElement: _propTypes2.default.func,
    createId: _propTypes2.default.func,
    getParentInfo: _propTypes2.default.func,
    getViewId: _propTypes2.default.func
  };
  TypedComponent.childContextTypes = {
    addElement: _propTypes2.default.func,
    updateElement: _propTypes2.default.func,
    deleteElement: _propTypes2.default.func,
    createId: _propTypes2.default.func,
    getParentInfo: _propTypes2.default.func,
    getViewId: _propTypes2.default.func
  };


  return TypedComponent;
}

BaseComponent.generateBaseTypedComponent = generateBaseTypedComponent;

exports.default = BaseComponent;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 璁＄畻path 浣跨敤鐨勫伐鍏锋柟娉�
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var Spline = __webpack_require__(314);

function points2path(points, isInCircle) {
  if (!points.length) {
    return [];
  }

  var path = [];

  for (var i = 0, length = points.length; i < length; i++) {
    var item = points[i];

    if (i === 0) {
      path.push(['M', item.x, item.y]);
    } else {
      path.push(['L', item.x, item.y]);
    }
  }

  if (isInCircle) {
    path.push(['Z']);
  }

  return path;
}

function _getPointRadius(coord, point) {
  var center = coord.getCenter();
  var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
  return r;
}

function convertArr(arr, coord) {
  var len = arr.length;
  var tmp = [arr[0]];

  for (var i = 1; i < len; i = i + 2) {
    var point = coord.convertPoint({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point.x, point.y);
  }

  return tmp;
}

function _convertPolarPath(pre, cur, coord) {
  // const radius = coord.getRadius();
  // const inner = coord.innerRadius || 0;
  // let innerRadius = inner * radius;
  var transposed = coord.isTransposed;
  var startAngle = coord.startAngle;
  var endAngle = coord.endAngle;
  var prePoint = {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = []; // innerRadius = innerRadius || 0;

  var xDim = transposed ? 'y' : 'x';
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 鍦嗗姬鐨勬柟鍚�

  var flag = angleRange > Math.PI ? 1 : 0; // 澶у姬杩樻槸灏忓姬鏍囧織浣�

  var convertPoint = coord.convertPoint(curPoint);

  var r = _getPointRadius(coord, convertPoint);

  if (r >= 0.5) {
    // 灏忎簬1鍍忕礌鐨勫渾鍦ㄥ浘鍍忎笂鏃犳硶璇嗗埆
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord.convertPoint(middlePoint);
      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    }
  }

  return rst;
} // 褰撳瓨鍦ㄦ暣浣撶殑鍦嗘椂锛屽幓闄ゅ渾鍓嶉潰鍜屽悗闈㈢殑绾匡紝闃叉鍑虹幇鐩寸嚎绌胯繃鏁翠釜鍦嗙殑鎯呭舰


function filterFullCirleLine(path) {
  Util.each(path, function (subPath, index) {
    var cur = subPath;

    if (cur[0].toLowerCase() === 'a') {
      var pre = path[index - 1];
      var next = path[index + 1];

      if (next && next[0].toLowerCase() === 'a') {
        if (pre && pre[0].toLowerCase() === 'l') {
          pre[0] = 'M';
        }
      } else if (pre && pre[0].toLowerCase() === 'a') {
        if (next && next[0].toLowerCase() === 'l') {
          next[0] = 'M';
        }
      }
    }
  });
}

var PathUtil = {
  // 绾跨殑path
  getLinePath: function getLinePath(points, isInCircle) {
    return points2path(points, isInCircle);
  },
  // get spline锛� 闄愬畾浜嗚寖鍥寸殑骞虫粦绾�
  getSplinePath: function getSplinePath(points, isInCircle, constaint) {
    var data = [];
    var first = points[0];
    var prePoint = null;

    if (points.length <= 2) {
      return PathUtil.getLinePath(points, isInCircle);
    }

    Util.each(points, function (point) {
      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
        data.push(point.x);
        data.push(point.y);
        prePoint = point;
      }
    });
    constaint = constaint || [// 鑼冨洿
    [0, 0], [1, 1]];
    var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);
    splinePath.unshift(['M', first.x, first.y]);
    return splinePath;
  },
  getPointRadius: function getPointRadius(coord, point) {
    var result = _getPointRadius(coord, point);

    return result;
  },
  getPointAngle: function getPointAngle(coord, point) {
    var center = coord.getCenter();
    var angle = Math.atan2(point.y - center.y, point.x - center.x);
    return angle;
  },
  convertNormalPath: function convertNormalPath(coord, path) {
    var tmp = [];
    Util.each(path, function (subPath) {
      var action = subPath[0];

      switch (action.toLowerCase()) {
        case 'm':
        case 'l':
        case 'c':
          tmp.push(convertArr(subPath, coord));
          break;

        case 'z':
        default:
          tmp.push(subPath);
          break;
      }
    });
    return tmp;
  },
  convertPolarPath: function convertPolarPath(coord, path) {
    var tmp = [];
    var pre;
    var cur;
    var transposed;
    var equals;
    Util.each(path, function (subPath, index) {
      var action = subPath[0];

      switch (action.toLowerCase()) {
        case 'm':
        case 'c':
        case 'q':
          tmp.push(convertArr(subPath, coord));
          break;

        case 'l':
          pre = path[index - 1];
          cur = subPath;
          transposed = coord.isTransposed; // 鏄惁鍗婂緞鐩稿悓锛岃浆鎹㈡垚鍦嗗姬

          equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];

          if (equals) {
            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
          } else {
            // y 涓嶇浉绛夛紝鎵€浠ョ洿鎺ヨ浆鎹�
            tmp.push(convertArr(subPath, coord));
          }

          break;

        case 'z':
        default:
          tmp.push(subPath);
          break;
      }
    });
    filterFullCirleLine(tmp); // 杩囨护澶氫綑鐨勭洿绾�

    return tmp;
  }
};
module.exports = PathUtil;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var mix = __webpack_require__(10);

var each = __webpack_require__(2);

var isObject = __webpack_require__(39);

var isNil = __webpack_require__(6);

var Scale =
/*#__PURE__*/
function () {
  var _proto = Scale.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    this.type = 'base';
    /**
     * 鏍煎紡鍖栧嚱鏁�,杈撳嚭鏂囨湰鎴栬€卼ick鏃剁殑鏍煎紡鍖栧嚱鏁�
     * @type {Function}
     */

    this.formatter = null;
    /**
     * 杈撳嚭鐨勫€煎煙
     * @type {Array}
     */

    this.range = [0, 1];
    /**
     * 搴﹂噺鐨勬爣璁�
     * @type {Array}
     */

    this.ticks = null;
    /**
     * 鍙備笌搴﹂噺璁＄畻鐨勫€硷紝鍙€夐」
     * @type {Array}
     */

    this.values = [];
  };

  function Scale(cfg) {
    this._initDefaultCfg();

    mix(this, cfg);
    this.init();
  }
  /**
   * 搴﹂噺鍒濆鍖�
   * @protected
   */


  _proto.init = function init() {}
  /**
   * 鑾峰彇璇ュ害閲忕殑ticks,杩斿洖鐨勬槸澶氫釜瀵硅薄锛�
   *   - text: tick 鐨勬枃鏈�
   *   - value: 瀵瑰簲鐨勫害閲忚浆鎹㈠悗鐨勫€�
   * <code>
   *   [
   *     {text: 0,value:0}
   *     {text: 1,value:0.2}
   *     {text: 2,value:0.4}
   *     {text: 3,value:0.6}
   *     {text: 4,value:0.8}
   *     {text: 5,value:1}
   *   ]
   * </code>
   * @param {Number} count 杈撳嚭tick鐨勪釜鏁扮殑杩戜技鍊硷紝榛樿鏄� 10
   * @return {Array} 杩斿洖 ticks 鏁扮粍
   */
  ;

  _proto.getTicks = function getTicks() {
    var self = this;
    var ticks = self.ticks;
    var rst = [];
    each(ticks, function (tick) {
      var obj;

      if (isObject(tick)) {
        obj = tick;
      } else {
        obj = {
          text: self.getText(tick),
          tickValue: tick,
          value: self.scale(tick)
        };
      }

      rst.push(obj);
    });
    return rst;
  }
  /**
   * 鑾峰彇鏍煎紡鍖栧悗鐨勬枃鏈�
   * @param  {*} value 杈撳叆鐨勬暟鎹�
   * @param  {*} key 瀛楁鐨� key
   * @return {String} 鏍煎紡鍖栫殑鏂囨湰
   */
  ;

  _proto.getText = function getText(value, key) {
    var formatter = this.formatter;
    value = formatter ? formatter(value, key) : value;

    if (isNil(value) || !value.toString) {
      value = '';
    }

    return value.toString();
  }
  /**
   * 杈撳嚭鐨勫€煎煙鏈€灏忓€�
   * @protected
   * @return {Number} 杩斿洖鏈€灏忕殑鍊�
   */
  ;

  _proto.rangeMin = function rangeMin() {
    return this.range[0];
  }
  /**
   * 杈撳嚭鐨勫€煎煙鏈€澶у€�
   * @protected
   * @return {Number} 杩斿洖鏈€澶х殑鍊�
   */
  ;

  _proto.rangeMax = function rangeMax() {
    var range = this.range;
    return range[range.length - 1];
  }
  /**
   * 搴﹂噺杞崲鍚庣殑缁撴灉锛岀炕杞洖杈撳叆鍩�
   * @param  {Number} value 闇€瑕佺炕杞殑鏁板€�
   * @return {*} 搴﹂噺鐨勮緭鍏ュ€�
   */
  ;

  _proto.invert = function invert(value) {
    return value;
  }
  /**
   * 灏嗕紶鍏ョ殑鍊间粠闈炴暟鍊艰浆鎹㈡垚鏁板€兼牸寮忥紝濡傚垎绫诲瓧绗︿覆銆佹椂闂村瓧绗︿覆绛�
   * @param  {*} value 浼犲叆鐨勫€�
   * @return {Number} 杞崲鐨勫€�
   */
  ;

  _proto.translate = function translate(value) {
    return value;
  }
  /**
   * 杩涜搴﹂噺杞崲
   * @param  {*} value 杈撳叆鍊�
   * @return {Number} 杈撳嚭鍊硷紝鍦ㄨ瀹氱殑杈撳嚭鍊煎煙涔嬮棿锛岄粯璁0,1]
   */
  ;

  _proto.scale = function scale(value) {
    return value;
  }
  /**
   * 鍏嬮殕涓€涓柊鐨剆cale,鎷ユ湁璺熷綋鍓峴cale鐩稿悓鐨勮緭鍏ュ煙銆佽緭鍑哄煙绛�
   * @return {Scale} 鍏嬮殕鐨勫害閲�
   */
  ;

  _proto.clone = function clone() {
    var self = this;
    var constr = self.constructor;
    var cfg = {};
    each(self, function (v, k) {
      cfg[k] = self[k];
    });
    return new constr(cfg);
  }
  /**
   * 鏇存敼搴﹂噺鐨勫睘鎬т俊鎭�
   * @param  {Object} info 灞炴€т俊鎭�
   * @chainable
   * @return {Scale} 杩斿洖鑷韩鐨勫紩鐢�
   */
  ;

  _proto.change = function change(info) {
    this.ticks = null;
    mix(this, info);
    this.init();
    return this;
  };

  return Scale;
}();

module.exports = Scale;

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = Transition;
/* harmony export (immutable) */ __webpack_exports__["a"] = transition;
/* harmony export (immutable) */ __webpack_exports__["c"] = newId;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attr_js__ = __webpack_require__(519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attrTween_js__ = __webpack_require__(520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__delay_js__ = __webpack_require__(521);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration_js__ = __webpack_require__(522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ease_js__ = __webpack_require__(523);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter_js__ = __webpack_require__(525);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__merge_js__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__on_js__ = __webpack_require__(527);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__remove_js__ = __webpack_require__(528);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__select_js__ = __webpack_require__(529);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__selectAll_js__ = __webpack_require__(530);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__selection_js__ = __webpack_require__(531);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__style_js__ = __webpack_require__(532);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__styleTween_js__ = __webpack_require__(533);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__text_js__ = __webpack_require__(534);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__textTween_js__ = __webpack_require__(535);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__transition_js__ = __webpack_require__(536);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__tween_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__end_js__ = __webpack_require__(524);





















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: __WEBPACK_IMPORTED_MODULE_10__select_js__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_11__selectAll_js__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_6__filter_js__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_7__merge_js__["a" /* default */],
  selection: __WEBPACK_IMPORTED_MODULE_12__selection_js__["a" /* default */],
  transition: __WEBPACK_IMPORTED_MODULE_17__transition_js__["a" /* default */],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: __WEBPACK_IMPORTED_MODULE_8__on_js__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_1__attr_js__["a" /* default */],
  attrTween: __WEBPACK_IMPORTED_MODULE_2__attrTween_js__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_13__style_js__["a" /* default */],
  styleTween: __WEBPACK_IMPORTED_MODULE_14__styleTween_js__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_15__text_js__["a" /* default */],
  textTween: __WEBPACK_IMPORTED_MODULE_16__textTween_js__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_9__remove_js__["a" /* default */],
  tween: __WEBPACK_IMPORTED_MODULE_18__tween_js__["a" /* default */],
  delay: __WEBPACK_IMPORTED_MODULE_3__delay_js__["a" /* default */],
  duration: __WEBPACK_IMPORTED_MODULE_4__duration_js__["a" /* default */],
  ease: __WEBPACK_IMPORTED_MODULE_5__ease_js__["a" /* default */],
  end: __WEBPACK_IMPORTED_MODULE_19__end_js__["a" /* default */]
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var DomUtil = Util.DomUtil;
var EVENT_TYPES = ['start', 'process', 'end', 'reset'];

var Interaction = /*#__PURE__*/function () {
  var _proto = Interaction.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      startEvent: 'mousedown',
      processEvent: 'mousemove',
      endEvent: 'mouseup',
      resetEvent: 'dblclick'
    };
  };

  _proto._start = function _start(ev) {
    var me = this;
    me.preStart && me.preStart(ev);
    me.start(ev);
    me.onStart && me.onStart(ev);
  };

  _proto._process = function _process(ev) {
    var me = this;
    me.preProcess && me.preProcess(ev);
    me.process(ev);
    me.onProcess && me.onProcess(ev);
  };

  _proto._end = function _end(ev) {
    var me = this;
    me.preEnd && me.preEnd(ev);
    me.end(ev);
    me.onEnd && me.onEnd(ev);
  };

  _proto._reset = function _reset(ev) {
    var me = this;
    me.preReset && me.preReset(ev);
    me.reset(ev);
    me.onReset && me.onReset(ev);
  };

  _proto.start = function start() {// TODO override
  };

  _proto.process = function process() {// TODO override
  };

  _proto.end = function end() {// TODO override
  };

  _proto.reset = function reset() {// TODO override
  };

  function Interaction(cfg, view) {
    var me = this;
    var defaultCfg = me.getDefaultCfg();
    Util.assign(me, defaultCfg, cfg);
    me.view = me.chart = view;
    me.canvas = view.get('canvas');

    me._bindEvents();
  }

  _proto._bindEvents = function _bindEvents() {
    var me = this;
    var canvas = me.canvas;
    var canvasDOM = canvas.get('canvasDOM');

    me._clearEvents();

    Util.each(EVENT_TYPES, function (type) {
      var ucType = Util.upperFirst(type);
      me["_on" + ucType + "Listener"] = DomUtil.addEventListener(canvasDOM, me[type + "Event"], Util.wrapBehavior(me, "_" + type));
    });
  };

  _proto._clearEvents = function _clearEvents() {
    var me = this;
    Util.each(EVENT_TYPES, function (type) {
      var listenerName = "_on" + Util.upperFirst(type) + "Listener";
      me[listenerName] && me[listenerName].remove();
    });
  };

  _proto.destroy = function destroy() {
    this._clearEvents();
  };

  return Interaction;
}();

module.exports = Interaction;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(224);

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(541)(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  Axis: __webpack_require__(240),
  Component: __webpack_require__(66),
  Guide: __webpack_require__(248),
  Label: __webpack_require__(252),
  Legend: __webpack_require__(258),
  Tooltip: __webpack_require__(263)
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  Canvas: __webpack_require__(328),
  Group: __webpack_require__(134),
  Shape: __webpack_require__(7),
  Arc: __webpack_require__(136),
  Circle: __webpack_require__(137),
  Dom: __webpack_require__(138),
  Ellipse: __webpack_require__(139),
  Fan: __webpack_require__(140),
  Image: __webpack_require__(141),
  Line: __webpack_require__(142),
  Marker: __webpack_require__(74),
  Path: __webpack_require__(145),
  Polygon: __webpack_require__(146),
  Polyline: __webpack_require__(147),
  Rect: __webpack_require__(148),
  Text: __webpack_require__(149),
  PathSegment: __webpack_require__(50),
  PathUtil: __webpack_require__(77),
  Event: __webpack_require__(135),
  // version, etc.
  version: '3.3.6'
};

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = hue;
/* harmony export (immutable) */ __webpack_exports__["c"] = gamma;
/* harmony export (immutable) */ __webpack_exports__["a"] = nogamma;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant_js__ = __webpack_require__(209);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a" /* default */])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a" /* default */])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a" /* default */])(isNaN(a) ? b : a);
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var mix = __webpack_require__(10);

var Adjust =
/*#__PURE__*/
function () {
  var _proto = Adjust.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    this.adjustNames = ['x', 'y']; // 璋冩暣鐨勭淮搴︼紝榛樿,x,y閮藉仛璋冩暣
  };

  function Adjust(cfg) {
    this._initDefaultCfg();

    mix(this, cfg);
  }
  /**
   * @override
   */


  _proto.processAdjust = function processAdjust()
  /* dataArray */
  {};

  return Adjust;
}();

module.exports = Adjust;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview the Attribute base class
 */
var isString = __webpack_require__(15);

var isArray = __webpack_require__(4);

var isNil = __webpack_require__(6);

var mix = __webpack_require__(10);

var each = __webpack_require__(2);

function toScaleString(scale, value) {
  if (isString(value)) {
    return value;
  }

  return scale.invert(scale.scale(value));
}
/**
 * 鎵€鏈夎瑙夐€氶亾灞炴€х殑鍩虹被
 * @class Attr
 */


var AttributeBase =
/*#__PURE__*/
function () {
  function AttributeBase(cfg) {
    var _this = this;

    /**
     * 灞炴€х殑绫诲瀷
     * @type {String}
     */
    this.type = 'base';
    /**
     * 灞炴€х殑鍚嶇О
     * @type {String}
     */

    this.name = null;
    /**
     * 鍥炶皟鍑芥暟
     * @type {Function}
     */

    this.method = null;
    /**
     * 澶囬€夌殑鍊兼暟缁�
     * @type {Array}
     */

    this.values = [];
    /**
     * 灞炴€у唴閮ㄧ殑搴﹂噺
     * @type {Array}
     */

    this.scales = [];
    /**
     * 鏄惁閫氳繃绾挎€у彇鍊�, 濡傛灉鏈寚瀹氾紝鍒欐牴鎹暟鍊肩殑绫诲瀷鍒ゅ畾
     * @type {Boolean}
     */

    this.linear = null;
    /**
     * 褰撶敤鎴疯缃殑 callback 杩斿洖 null 鏃�, 搴旇杩斿洖榛樿 callback 涓殑鍊�
     */

    var mixedCallback = null;
    var defaultCallback = this.callback;

    if (cfg.callback) {
      var userCallback = cfg.callback;

      mixedCallback = function mixedCallback() {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        var ret = userCallback.apply(void 0, params);

        if (isNil(ret)) {
          ret = defaultCallback.apply(_this, params);
        }

        return ret;
      };
    }

    mix(this, cfg);

    if (mixedCallback) {
      mix(this, {
        callback: mixedCallback
      });
    }
  } // 鑾峰彇灞炴€у€硷紝灏嗗€兼槧灏勫埌瑙嗚閫氶亾


  var _proto = AttributeBase.prototype;

  _proto._getAttrValue = function _getAttrValue(scale, value) {
    var values = this.values;

    if (scale.isCategory && !this.linear) {
      var index = scale.translate(value);
      return values[index % values.length];
    }

    var percent = scale.scale(value);
    return this.getLinearValue(percent);
  };
  /**
   * 濡傛灉杩涜绾挎€ф槧灏勶紝杩斿洖瀵瑰簲鐨勬槧灏勫€�
   * @protected
   * @param  {Number} percent 鐧惧垎姣�
   * @return {*}  棰滆壊鍊笺€佸舰鐘躲€佸ぇ灏忕瓑
   */


  _proto.getLinearValue = function getLinearValue(percent) {
    var values = this.values;
    var steps = values.length - 1;
    var step = Math.floor(steps * percent);
    var leftPercent = steps * percent - step;
    var start = values[step];
    var end = step === steps ? start : values[step + 1];
    var rstValue = start + (end - start) * leftPercent;
    return rstValue;
  };
  /**
   * 榛樿鐨勫洖璋冨嚱鏁�
   * @param {*} value 鍥炶皟鍑芥暟鐨勫€�
   * @type {Function}
   * @return {Array} 杩斿洖鏄犲皠鍚庣殑鍊�
   */


  _proto.callback = function callback(value) {
    var self = this;
    var scale = self.scales[0];
    var rstValue = null;

    if (scale.type === 'identity') {
      rstValue = scale.value;
    } else {
      rstValue = self._getAttrValue(scale, value);
    }

    return rstValue;
  };
  /**
   * 鏍规嵁搴﹂噺鑾峰彇灞炴€у悕
   * @return {Array} dims of this Attribute
   */


  _proto.getNames = function getNames() {
    var scales = this.scales;
    var names = this.names;
    var length = Math.min(scales.length, names.length);
    var rst = [];

    for (var i = 0; i < length; i++) {
      rst.push(names[i]);
    }

    return rst;
  };
  /**
   * 鏍规嵁搴﹂噺鑾峰彇缁村害鍚�
   * @return {Array} dims of this Attribute
   */


  _proto.getFields = function getFields() {
    var scales = this.scales;
    var rst = [];
    each(scales, function (scale) {
      rst.push(scale.field);
    });
    return rst;
  };
  /**
   * 鏍规嵁鍚嶇О鑾峰彇搴﹂噺
   * @param  {String} name the name of scale
   * @return {Scale} scale
   */


  _proto.getScale = function getScale(name) {
    var scales = this.scales;
    var names = this.names;
    var index = names.indexOf(name);
    return scales[index];
  };
  /**
   * 鏄犲皠鏁版嵁
   * @param {*} param1...paramn 澶氫釜鏁板€�
   * @return {Array} 鏄犲皠鐨勫€肩粍鎴愮殑鏁扮粍
   */


  _proto.mapping = function mapping() {
    var scales = this.scales;
    var callback = this.callback;

    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      params[_key2] = arguments[_key2];
    }

    var values = params;

    if (callback) {
      for (var i = 0, len = params.length; i < len; i++) {
        params[i] = this._toOriginParam(params[i], scales[i]);
      }

      values = callback.apply(this, params);
    }

    values = [].concat(values);
    return values;
  }; // 鍘熷鐨勫弬鏁�


  _proto._toOriginParam = function _toOriginParam(param, scale) {
    var rst = param;

    if (!scale.isLinear) {
      if (isArray(param)) {
        rst = [];

        for (var i = 0, len = param.length; i < len; i++) {
          rst.push(toScaleString(scale, param[i]));
        }
      } else {
        rst = toScaleString(scale, param);
      }
    }

    return rst;
  };

  return AttributeBase;
}();

module.exports = AttributeBase;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Component = __webpack_require__(36);

var Util = __webpack_require__(3);

var Grid = __webpack_require__(108);

var Label = __webpack_require__(110);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var Axis =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Axis, _Component);

  function Axis() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Axis.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Component.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 鐢ㄤ簬鍔ㄧ敾锛屽敮涓€鏍囪瘑鐨� id
       * @type {[type]}
       */
      _id: null,
      zIndex: 4,

      /**
       * 鍧愭爣杞翠笂鐨勫潗鏍囩偣
       * @type {Array}
       */
      ticks: null,

      /**
       * 鍧愭爣杞寸嚎鐨勯厤缃俊鎭紝濡傛灉璁剧疆鎴恘ull锛屽垯涓嶆樉绀鸿酱绾�
       * @type {Object}
       */
      line: null,

      /**
       * 鍧愭爣杞村埢搴︾嚎鐨勯厤缃�,濡傛灉璁剧疆鎴恘ull锛屽垯涓嶆樉绀哄埢搴︾嚎
       * @type {Object}
       */
      tickLine: null,

      /**
       * 娆″埢搴︾嚎涓暟閰嶇疆
       * @type {Number}
       */
      subTickCount: 0,

      /**
       * 娆″埢搴︾嚎鏍峰紡閰嶇疆
       * @type {Object}
       */
      subTickLine: null,

      /**
       * 缃戞牸绾块厤缃紝濡傛灉鍊间负 null锛屽垯涓嶆樉绀�
       * @type {Object}
       */
      grid: null,

      /**
       * 鍧愭爣杞存枃鏈厤缃�
       * @type {Object}
       */
      label: {
        offset: 0,
        offsetX: 0,
        offsetY: 0,
        textStyle: {},
        // 鍧愭爣杞存枃鏈牱寮�
        autoRotate: true,
        autoHide: false,
        formatter: null // 鍧愭爣杞存枃鏈牸寮忓寲鍥炶皟鍑芥暟

      },
      labelItems: [],

      /**
       * 鍧愭爣杞存爣棰橀厤缃�
       * @type {Object}
       */
      title: {
        autoRotate: true,
        // 鏂囨湰鏄惁鑷姩鏃嬭浆
        textStyle: {} // 鍧愭爣杞存爣棰樻牱寮�

      },
      autoPaint: true
    });
  };

  _proto.beforeRender = function beforeRender() {
    var self = this;
    var title = self.get('title');
    var label = self.get('label');
    var grid = self.get('grid');

    if (title) {
      self.set('title', Util.deepMix({
        autoRotate: true,
        textStyle: {
          fontSize: 12,
          fill: '#ccc',
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY,
          textAlign: 'center'
        },
        offset: 48
      }, title));
    }

    if (label) {
      self.set('label', Util.deepMix({
        autoRotate: true,
        autoHide: true,
        textStyle: {
          fontSize: 12,
          fill: '#ccc',
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        },
        offset: 10
      }, label));
    }

    if (grid) {
      self.set('grid', Util.deepMix({
        lineStyle: {
          lineWidth: 1,
          stroke: '#C0D0E0'
        }
      }, grid));
    }
  };

  _proto.render = function render() {
    var self = this;
    self.beforeRender();
    var labelCfg = self.get('label');

    if (labelCfg) {
      self.renderLabels();
    }

    if (self.get('autoPaint')) {
      self.paint();
    }

    if (!Util.isNil(self.get('title'))) {
      self.renderTitle();
    }

    self.get('group').sort();
  };

  _proto.renderLabels = function renderLabels() {
    var self = this;
    var group = self.get('group');
    var labelCfg = self.get('label');
    var labelRenderer = new Label({
      name: 'axis-label'
    });
    self.set('labelRenderer', labelRenderer);
    labelRenderer.set('labelCfg', labelCfg);
    var cfgs2copy = ['formatter', 'htmlTemplate', 'labelLine', 'textStyle', 'useHtml'];
    Util.each(cfgs2copy, function (cfg) {
      if (labelCfg[cfg]) {
        labelRenderer.set(cfg, labelCfg[cfg]);
      }
    });
    labelRenderer.set('coord', self.get('coord'));
    labelRenderer.set('group', group.addGroup());
    labelRenderer.set('canvas', self.get('canvas'));
  };

  _proto._parseTicks = function _parseTicks(ticks) {
    ticks = ticks || [];
    var ticksLength = ticks.length;

    for (var i = 0; i < ticksLength; i++) {
      var item = ticks[i];

      if (!Util.isObject(item)) {
        ticks[i] = this.parseTick(item, i, ticksLength);
      }
    }

    this.set('ticks', ticks);
    return ticks;
  };

  _proto._addTickItem = function _addTickItem(index, point, length, type) {
    if (type === void 0) {
      type = '';
    }

    var tickItems = this.get('tickItems');
    var subTickItems = this.get('subTickItems');
    var end = this.getTickEnd(point, length, index);
    var cfg = {
      x1: point.x,
      y1: point.y,
      x2: end.x,
      y2: end.y
    };

    if (!tickItems) {
      tickItems = [];
    }

    if (!subTickItems) {
      subTickItems = [];
    }

    if (type === 'sub') {
      subTickItems.push(cfg);
    } else {
      tickItems.push(cfg);
    }

    this.set('tickItems', tickItems);
    this.set('subTickItems', subTickItems);
  };

  _proto._renderLine = function _renderLine() {
    var self = this;
    var lineCfg = self.get('line');
    var path;

    if (lineCfg) {
      path = self.getLinePath();
      lineCfg = Util.mix({
        path: path
      }, lineCfg);
      var group = self.get('group');
      var lineShape = group.addShape('path', {
        attrs: lineCfg
      });
      lineShape.name = 'axis-line';
      self.get('appendInfo') && lineShape.setSilent('appendInfo', self.get('appendInfo'));
      self.set('lineShape', lineShape);
    }
  };

  _proto._processCatTicks = function _processCatTicks() {
    var self = this;
    var labelCfg = self.get('label');
    var tickLineCfg = self.get('tickLine');
    var ticks = self.get('ticks');
    ticks = self._parseTicks(ticks);

    var new_ticks = self._getNormalizedTicks(ticks);

    for (var i = 0; i < new_ticks.length; i += 3) {
      var p = self.getTickPoint(new_ticks[i]);
      var p0 = self.getTickPoint(new_ticks[i + 1]);
      var p1 = self.getTickPoint(new_ticks[i + 2]);
      var index = Math.floor(i / 3);
      var tick = ticks[index];

      if (tickLineCfg) {
        if (index === 0) {
          self._addTickItem(index, p0, tickLineCfg.length);
        }

        self._addTickItem(index, p1, tickLineCfg.length);
      }

      if (labelCfg) {
        self.addLabel(tick, p, index);
      }
    }
  };

  _proto._getNormalizedTicks = function _getNormalizedTicks(ticks) {
    var tickSeg = 0;

    if (ticks.length > 1) {
      tickSeg = (ticks[1].value - ticks[0].value) / 2;
    }

    var points = [];

    for (var i = 0; i < ticks.length; i++) {
      var tick = ticks[i];
      var p = tick.value;
      var p0 = tick.value - tickSeg;
      var p1 = tick.value + tickSeg;
      points.push(p, p0, p1);
    }

    var range = Util.arrayUtil.getRange(points);
    return points.map(function (p) {
      var norm = (p - range.min) / (range.max - range.min);
      return norm;
    });
  };

  _proto.addLabel = function addLabel(tick, point, index) {
    var self = this;
    var labelItems = self.get('labelItems');
    var labelRenderer = self.get('labelRenderer');
    var label = Util.deepMix({}, self.get('label'));
    var rst;

    if (labelRenderer) {
      var offset = self.get('_labelOffset');

      if (!Util.isNil(self.get('label').offset)) {
        offset = self.get('label').offset;
      }

      var vector = self.getSideVector(offset, point, index);
      point = {
        x: point.x + vector[0] + label.offsetX,
        y: point.y + vector[1] + label.offsetY
      };
      label.text = tick.text;
      label.x = point.x;
      label.y = point.y;
      label.point = point;
      label.textAlign = self.getTextAnchor(vector);

      if (point.rotate) {
        label.rotate = point.rotate;
      }

      labelItems.push(label);
    }

    return rst;
  };

  _proto._processTicks = function _processTicks() {
    var self = this;
    var labelCfg = self.get('label');
    var subTickCount = self.get('subTickCount');
    var tickLineCfg = self.get('tickLine');
    var ticks = self.get('ticks');
    ticks = self._parseTicks(ticks);
    Util.each(ticks, function (tick, index) {
      var tickPoint = self.getTickPoint(tick.value, index);

      if (tickLineCfg) {
        self._addTickItem(index, tickPoint, tickLineCfg.length);
      }

      if (labelCfg) {
        self.addLabel(tick, tickPoint, index);
      }
    });

    if (subTickCount) {
      // 濡傛灉鏈夎缃绾у垎鐐癸紝娣诲姞娆＄骇tick
      var subTickLineCfg = self.get('subTickLine');
      Util.each(ticks, function (tick, index) {
        if (index > 0) {
          var diff = tick.value - ticks[index - 1].value;
          diff = diff / (self.get('subTickCount') + 1);

          for (var i = 1; i <= subTickCount; i++) {
            var subTick = {
              text: '',
              value: index ? ticks[index - 1].value + i * diff : i * diff
            };
            var tickPoint = self.getTickPoint(subTick.value);
            var subTickLength = void 0;

            if (subTickLineCfg && subTickLineCfg.length) {
              subTickLength = subTickLineCfg.length;
            } else {
              subTickLength = parseInt(tickLineCfg.length * (3 / 5), 10);
            }

            self._addTickItem(i - 1, tickPoint, subTickLength, 'sub');
          }
        }
      });
    }
  };

  _proto._addTickLine = function _addTickLine(ticks, lineCfg) {
    var self = this;
    var cfg = Util.mix({}, lineCfg);
    var path = [];
    Util.each(ticks, function (item) {
      path.push(['M', item.x1, item.y1]);
      path.push(['L', item.x2, item.y2]);
    });
    delete cfg.length;
    cfg.path = path;
    var group = self.get('group');
    var tickShape = group.addShape('path', {
      attrs: cfg
    });
    tickShape.name = 'axis-ticks';
    tickShape._id = self.get('_id') + '-ticks';
    tickShape.set('coord', self.get('coord'));
    self.get('appendInfo') && tickShape.setSilent('appendInfo', self.get('appendInfo'));
  };

  _proto._renderTicks = function _renderTicks() {
    var self = this;
    var tickItems = self.get('tickItems');
    var subTickItems = self.get('subTickItems');

    if (!Util.isEmpty(tickItems)) {
      var tickLineCfg = self.get('tickLine');

      self._addTickLine(tickItems, tickLineCfg);
    }

    if (!Util.isEmpty(subTickItems)) {
      var subTickLineCfg = self.get('subTickLine') || self.get('tickLine');

      self._addTickLine(subTickItems, subTickLineCfg);
    }
  };

  _proto._renderGrid = function _renderGrid() {
    var grid = this.get('grid');

    if (!grid) {
      return;
    }

    grid.coord = this.get('coord');
    grid.appendInfo = this.get('appendInfo');
    var group = this.get('group');
    this.set('gridGroup', group.addGroup(Grid, grid));
  };

  _proto._renderLabels = function _renderLabels() {
    var self = this;
    var labelRenderer = self.get('labelRenderer');
    var labelItems = self.get('labelItems');

    if (labelRenderer) {
      labelRenderer.set('items', labelItems);

      labelRenderer._dryDraw();
    }
  };

  _proto.paint = function paint() {
    var self = this;
    var tickLineCfg = self.get('tickLine');
    var alignWithLabel = true;

    if (tickLineCfg && tickLineCfg.hasOwnProperty('alignWithLabel')) {
      alignWithLabel = tickLineCfg.alignWithLabel;
    }

    self._renderLine();

    var type = self.get('type');
    var isCat = type === 'cat' || type === 'timeCat';

    if (isCat && alignWithLabel === false) {
      self._processCatTicks();
    } else {
      self._processTicks();
    }

    self._renderTicks();

    self._renderGrid();

    self._renderLabels();

    var labelCfg = this.get('label');

    if (labelCfg && labelCfg.autoRotate) {
      self.autoRotateLabels();
    }

    if (labelCfg && labelCfg.autoHide) {
      self.autoHideLabels();
    }
  };

  _proto.parseTick = function parseTick(tick, index, length) {
    return {
      text: tick,
      value: index / (length - 1)
    };
  };

  _proto.getTextAnchor = function getTextAnchor(vector) {
    var ratio = Math.abs(vector[1] / vector[0]);
    var align;

    if (ratio >= 1) {
      // 涓婇潰鎴栬€呬笅闈�
      align = 'center';
    } else {
      if (vector[0] > 0) {
        // 鍙充晶
        align = 'start';
      } else {
        // 宸︿晶
        align = 'end';
      }
    }

    return align;
  };

  _proto.getMaxLabelWidth = function getMaxLabelWidth(labelRenderer) {
    var labels = labelRenderer.getLabels();
    var max = 0;
    Util.each(labels, function (label) {
      var bbox = label.getBBox();
      var width = bbox.width;

      if (max < width) {
        max = width;
      }
    });
    return max;
  };

  _proto.getMaxLabelHeight = function getMaxLabelHeight(labelRenderer) {
    var labels = labelRenderer.getLabels();
    var max = 0;
    Util.each(labels, function (label) {
      var bbox = label.getBBox();
      var height = bbox.height;

      if (max < height) {
        max = height;
      }
    });
    return max;
  };

  _proto.destroy = function destroy() {
    var self = this;

    if (!self.destroyed) {
      var gridGroup = self.get('gridGroup');
      gridGroup && gridGroup.remove();
      var labelRenderer = this.get('labelRenderer');
      labelRenderer && labelRenderer.destroy();
      var group = self.get('group');
      group.destroy();

      _Component.prototype.destroy.call(this); // 瑕佹渶鍚庤皟鐢� super.destroy 鍚﹀垯 get 灞炴€т細鏃犳晥

    }
  };

  _proto.clear = function clear() {
    var self = this;
    var group = self.get('group');

    if (!group.get('destroyed') && group.get('children').length) {
      var gridGroup = self.get('gridGroup');
      gridGroup && gridGroup.clear();
      var labelRenderer = this.get('labelRenderer');
      labelRenderer && labelRenderer.clear();

      var _group = self.get('group');

      _group.clear();
    }
  }
  /**
   * 鏃嬭浆鏂囨湰
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.autoRotateLabels = function autoRotateLabels() {}
  /**
   * 鏂囨湰鑷姩闃查伄缃�
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.autoHideLabels = function autoHideLabels() {}
  /**
   * 娓叉煋鏍囬
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.renderTitle = function renderTitle() {}
  /**
   * 鑾峰彇鍧愭爣杞寸嚎鐨� path
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.getLinePath = function getLinePath() {}
  /**
   * 鑾峰彇 tick 鍦ㄧ敾甯冧笂鐨勪綅缃�
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.getTickPoint = function getTickPoint() {}
  /**
   * 鑾峰彇鏍囩ず鍧愭爣鐐圭殑绾跨殑缁堢偣
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.getTickEnd = function getTickEnd() {}
  /**
   * 鑾峰彇璺濈鍧愭爣杞寸殑鍚戦噺
   * @abstract
   * @return {[type]} [description]
   */
  ;

  _proto.getSideVector = function getSideVector() {};

  return Axis;
}(Component);

module.exports = Axis;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(66);

var Component =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Component, _Base);

  function Component() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Component.prototype;

  // 閰嶇疆
  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      // 椤跺眰鏍囧織浣�
      _id: null,
      // 鐢ㄤ簬鍔ㄧ敾
      // 瀹瑰櫒
      canvas: null,
      container: null,
      // html锛屽彲閫�
      group: null,
      // G Group锛屽彲閫�
      // 浜や簰灞炴€�
      capture: false,
      // props
      coord: null,
      offset: [0, 0],
      plotRange: null,
      // BBox
      position: [0, 0],
      visible: true,
      zIndex: 1
    };
  } // 鍩虹鐢熷懡鍛ㄦ湡
  ;

  _proto._init = function _init() {};

  _proto.clear = function clear() {};

  _proto.destroy = function destroy() {
    // 涔嬪墠鏈寚瀹氶攢姣�
    _Base.prototype.destroy.call(this);
  } // 缁樺浘
  ;

  _proto.beforeRender = function beforeRender() {};

  _proto.render = function render() {} // 鍒濆鍖栥€佺粦浜嬩欢鍜岀粯鍥�
  ;

  _proto.afterRender = function afterRender() {};

  _proto.beforeDraw = function beforeDraw() {};

  _proto.draw = function draw() {} // 鍗曠函鏇存柊瑙嗗浘
  ;

  _proto.afterDraw = function afterDraw() {} // visibility
  ;

  _proto.show = function show() {};

  _proto.hide = function hide() {} // props operating syntactic sugar
  ;

  _proto.setOffset = function setOffset() {};

  _proto.setPosition = function setPosition() {};

  _proto.setVisible = function setVisible() {};

  _proto.setZIndex = function setZIndex() {};

  return Component;
}(Base);

module.exports = Component;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
var numColorCache = {};
module.exports = {
  parseRadius: function parseRadius(radius) {
    var r1 = 0,
        r2 = 0,
        r3 = 0,
        r4 = 0;

    if (Util.isArray(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }

    return {
      r1: r1,
      r2: r2,
      r3: r3,
      r4: r4
    };
  },
  parsePath: function parsePath(path) {
    path = path || [];

    if (Util.isArray(path)) {
      return path;
    }

    if (Util.isString(path)) {
      path = path.match(regexTags);
      Util.each(path, function (item, index) {
        item = item.match(regexDot);

        if (item[0].length > 1) {
          var tag = item[0].charAt(0);
          item.splice(1, 0, item[0].substr(1));
          item[0] = tag;
        }

        Util.each(item, function (sub, i) {
          if (!isNaN(sub)) {
            item[i] = +sub;
          }
        });
        path[index] = item;
      });
      return path;
    }
  },
  numberToColor: function numberToColor(num) {
    // 澧炲姞缂撳瓨
    var color = numColorCache[num];

    if (!color) {
      var str = num.toString(16);

      for (var i = str.length; i < 6; i++) {
        str = '0' + str;
      }

      color = '#' + str;
      numColorCache[num] = color;
    }

    return color;
  }
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(6);

function toString(value) {
  if (isNil(value)) return '';
  return value.toString();
}

module.exports = toString;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isObject = function isObject(value) {
  /**
   * isObject({}) => true
   * isObject([1, 2, 3]) => true
   * isObject(Function) => true
   * isObject(null) => false
   */
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value !== null && type === 'object' || type === 'function';
};

module.exports = isObject;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var isObjectLike = __webpack_require__(86);
var isType = __webpack_require__(17);

var isPlainObject = function isPlainObject(value) {
  /**
   * isObjectLike(new Foo) => false
   * isObjectLike([1, 2, 3]) => false
   * isObjectLike({ x: 0, y: 0 }) => true
   * isObjectLike(Object.create(null)) => true
   */
  if (!isObjectLike(value) || !isType(value, 'Object')) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};

module.exports = isPlainObject;

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = hue;
/* harmony export (immutable) */ __webpack_exports__["c"] = gamma;
/* harmony export (immutable) */ __webpack_exports__["a"] = nogamma;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(202);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}


/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_42__;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileOverview the base class of Coordinate
 * @author sima.zhang
 */
var MatrixUtil = __webpack_require__(56);

var mix = __webpack_require__(10);

var mat3 = MatrixUtil.mat3;
var vec3 = MatrixUtil.vec3;

var Coord =
/*#__PURE__*/
function () {
  _createClass(Coord, [{
    key: "getDefaultCfg",

    /**
     * 鑾峰彇榛樿鐨勯厤缃睘鎬�
     * @protected
     * @return {Object} 榛樿灞炴€�
     */
    value: function getDefaultCfg() {
      return {
        /**
         * Mark x y is transposed.
         * @type {Boolean}
         */
        isTransposed: false,

        /**
         * The matrix of coordinate
         * @type {Array}
         */
        matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
      };
    }
  }]);

  function Coord(cfg) {
    _classCallCheck(this, Coord);

    var defaultCfg = this.getDefaultCfg();
    mix(this, defaultCfg, cfg);
    this.init();
  }

  _createClass(Coord, [{
    key: "init",
    value: function init() {
      var start = this.start;
      var end = this.end;
      var center = {
        x: (start.x + end.x) / 2,
        y: (start.y + end.y) / 2
      };
      this.center = center;
      this.width = Math.abs(end.x - start.x);
      this.height = Math.abs(end.y - start.y);
    }
  }, {
    key: "_swapDim",
    value: function _swapDim(dim) {
      var dimRange = this[dim];

      if (dimRange) {
        var tmp = dimRange.start;
        dimRange.start = dimRange.end;
        dimRange.end = tmp;
      }
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }
  }, {
    key: "convertDim",
    value: function convertDim(percent, dim) {
      var _this$dim = this[dim],
          start = _this$dim.start,
          end = _this$dim.end;
      return start + percent * (end - start);
    }
  }, {
    key: "invertDim",
    value: function invertDim(value, dim) {
      var _this$dim2 = this[dim],
          start = _this$dim2.start,
          end = _this$dim2.end;
      return (value - start) / (end - start);
    }
    /**
     * 灏嗗綊涓€鍖栫殑鍧愭爣鐐规暟鎹浆鎹负鐢诲竷鍧愭爣
     * @override
     * @param  {Object} point 褰掍竴鍖栫殑鍧愭爣鐐�
     * @return {Object}       杩斿洖鐢诲竷鍧愭爣
     */

  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      return point;
    }
    /**
     * 灏嗙敾甯冨潗鏍囪浆鎹负褰掍竴鍖栫殑鍧愭爣鐐规暟鎹�
     * @override
     * @param  {Object} point 鐢诲竷鍧愭爣鐐规暟鎹�
     * @return {Object}       褰掍竴鍖栧悗鐨勬暟鎹偣
     */

  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      return point;
    }
    /**
     * 灏嗗潗鏍囩偣杩涜鐭╅樀鍙樻崲
     * @param  {Number} x   瀵瑰簲 x 杞寸敾甯冨潗鏍�
     * @param  {Number} y   瀵瑰簲 y 杞寸敾甯冨潗鏍�
     * @param  {Number} tag 榛樿涓� 0锛屽彲鍙栧€� 0, 1
     * @return {Array}     杩斿洖鍙樻崲鍚庣殑涓夐樁鍚戦噺 [x, y, z]
     */

  }, {
    key: "applyMatrix",
    value: function applyMatrix(x, y) {
      var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var matrix = this.matrix;
      var vector = [x, y, tag];
      vec3.transformMat3(vector, vector, matrix);
      return vector;
    }
    /**
     * 灏嗗潗鏍囩偣杩涜鐭╅樀閫嗗彉鎹�
     * @param  {Number} x   瀵瑰簲 x 杞寸敾甯冨潗鏍�
     * @param  {Number} y   瀵瑰簲 y 杞寸敾甯冨潗鏍�
     * @param  {Number} tag 榛樿涓� 0锛屽彲鍙栧€� 0, 1
     * @return {Array}     杩斿洖鐭╅樀閫嗗彉鎹㈠悗鐨勪笁闃跺悜閲� [x, y, z]
     */

  }, {
    key: "invertMatrix",
    value: function invertMatrix(x, y) {
      var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var matrix = this.matrix;
      var inversedMatrix = mat3.invert([], matrix);
      var vector = [x, y, tag];
      vec3.transformMat3(vector, vector, inversedMatrix);
      return vector;
    }
    /**
     * 灏嗗綊涓€鍖栫殑鍧愭爣鐐规暟鎹浆鎹负鐢诲竷鍧愭爣锛屽苟鏍规嵁鍧愭爣绯诲綋鍓嶇煩闃佃繘琛屽彉鎹�
     * @param  {Object} point 褰掍竴鍖栫殑鍧愭爣鐐�
     * @return {Object}       杩斿洖杩涜鐭╅樀鍙樻崲鍚庣殑鐢诲竷鍧愭爣
     */

  }, {
    key: "convert",
    value: function convert(point) {
      var _this$convertPoint = this.convertPoint(point),
          x = _this$convertPoint.x,
          y = _this$convertPoint.y;

      var vector = this.applyMatrix(x, y, 1);
      return {
        x: vector[0],
        y: vector[1]
      };
    }
    /**
     * 灏嗚繘琛岃繃鐭╅樀鍙樻崲鐢诲竷鍧愭爣杞崲涓哄綊涓€鍖栧潗鏍�
     * @param  {Object} point 鐢诲竷鍧愭爣
     * @return {Object}       杩斿洖褰掍竴鍖栫殑鍧愭爣鐐�
     */

  }, {
    key: "invert",
    value: function invert(point) {
      var vector = this.invertMatrix(point.x, point.y, 1);
      return this.invertPoint({
        x: vector[0],
        y: vector[1]
      });
    }
    /**
     * 鍧愭爣绯绘棆杞彉鎹�
     * @param  {Number} radian 鏃嬭浆寮у害
     * @return {Object}        杩斿洖鍧愭爣绯诲璞�
     */

  }, {
    key: "rotate",
    value: function rotate(radian) {
      var matrix = this.matrix;
      var center = this.center;
      mat3.translate(matrix, matrix, [-center.x, -center.y]);
      mat3.rotate(matrix, matrix, radian);
      mat3.translate(matrix, matrix, [center.x, center.y]);
      return this;
    }
    /**
     * 鍧愭爣绯诲弽灏勫彉鎹�
     * @param  {String} dim 鍙嶅皠缁村害
     * @return {Object}     杩斿洖鍧愭爣绯诲璞�
     */

  }, {
    key: "reflect",
    value: function reflect(dim) {
      switch (dim) {
        case 'x':
          this._swapDim('x');

          break;

        case 'y':
          this._swapDim('y');

          break;

        default:
          this._swapDim('y');

      }

      return this;
    }
    /**
     * 鍧愭爣绯绘瘮渚嬪彉鎹�
     * @param  {Number} s1 x 鏂瑰悜缂╂斁姣斾緥
     * @param  {Number} s2 y 鏂瑰悜缂╂斁姣斾緥
     * @return {Object}    杩斿洖鍧愭爣绯诲璞�
     */

  }, {
    key: "scale",
    value: function scale(s1, s2) {
      var matrix = this.matrix;
      var center = this.center;
      mat3.translate(matrix, matrix, [-center.x, -center.y]);
      mat3.scale(matrix, matrix, [s1, s2]);
      mat3.translate(matrix, matrix, [center.x, center.y]);
      return this;
    }
    /**
     * 鍧愭爣绯诲钩绉诲彉鎹�
     * @param  {Number} x x 鏂瑰悜骞崇Щ鍍忕礌
     * @param  {Number} y y 鏂瑰悜骞崇Щ鍍忕礌
     * @return {Object}   杩斿洖鍧愭爣绯诲璞�
     */

  }, {
    key: "translate",
    value: function translate(x, y) {
      var matrix = this.matrix;
      mat3.translate(matrix, matrix, [x, y]);
      return this;
    }
    /**
     * 灏嗗潗鏍囩郴 x y 涓や釜杞磋繘琛岃浆缃�
     * @return {Object} 杩斿洖鍧愭爣绯诲璞�
     */

  }, {
    key: "transpose",
    value: function transpose() {
      this.isTransposed = !this.isTransposed;
      return this;
    }
  }]);

  return Coord;
}();

module.exports = Coord;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXNlLmpzIl0sIm5hbWVzIjpbIk1hdHJpeFV0aWwiLCJyZXF1aXJlIiwibWl4IiwibWF0MyIsInZlYzMiLCJDb29yZCIsImlzVHJhbnNwb3NlZCIsIm1hdHJpeCIsImNmZyIsImRlZmF1bHRDZmciLCJnZXREZWZhdWx0Q2ZnIiwiaW5pdCIsInN0YXJ0IiwiZW5kIiwiY2VudGVyIiwieCIsInkiLCJ3aWR0aCIsIk1hdGgiLCJhYnMiLCJoZWlnaHQiLCJkaW0iLCJkaW1SYW5nZSIsInRtcCIsInBlcmNlbnQiLCJ2YWx1ZSIsInBvaW50IiwidGFnIiwidmVjdG9yIiwidHJhbnNmb3JtTWF0MyIsImludmVyc2VkTWF0cml4IiwiaW52ZXJ0IiwiY29udmVydFBvaW50IiwiYXBwbHlNYXRyaXgiLCJpbnZlcnRNYXRyaXgiLCJpbnZlcnRQb2ludCIsInJhZGlhbiIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsIl9zd2FwRGltIiwiczEiLCJzMiIsInNjYWxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUlBLElBQU1BLFVBQVUsR0FBR0MsT0FBTyxDQUFDLHdCQUFELENBQTFCOztBQUNBLElBQU1DLEdBQUcsR0FBR0QsT0FBTyxDQUFDLG9CQUFELENBQW5COztBQUVBLElBQU1FLElBQUksR0FBR0gsVUFBVSxDQUFDRyxJQUF4QjtBQUNBLElBQU1DLElBQUksR0FBR0osVUFBVSxDQUFDSSxJQUF4Qjs7SUFFTUMsSzs7Ozs7O0FBQ0o7Ozs7O29DQUtnQjtBQUNkLGFBQU87QUFDTDs7OztBQUlBQyxRQUFBQSxZQUFZLEVBQUUsS0FMVDs7QUFNTDs7OztBQUlBQyxRQUFBQSxNQUFNLEVBQUUsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQjtBQVZILE9BQVA7QUFZRDs7O0FBRUQsaUJBQVlDLEdBQVosRUFBaUI7QUFBQTs7QUFDZixRQUFNQyxVQUFVLEdBQUcsS0FBS0MsYUFBTCxFQUFuQjtBQUNBUixJQUFBQSxHQUFHLENBQUMsSUFBRCxFQUFPTyxVQUFQLEVBQW1CRCxHQUFuQixDQUFIO0FBQ0EsU0FBS0csSUFBTDtBQUNEOzs7OzJCQUVNO0FBQ0wsVUFBTUMsS0FBSyxHQUFHLEtBQUtBLEtBQW5CO0FBQ0EsVUFBTUMsR0FBRyxHQUFHLEtBQUtBLEdBQWpCO0FBQ0EsVUFBTUMsTUFBTSxHQUFHO0FBQ2JDLFFBQUFBLENBQUMsRUFBRSxDQUFDSCxLQUFLLENBQUNHLENBQU4sR0FBVUYsR0FBRyxDQUFDRSxDQUFmLElBQW9CLENBRFY7QUFFYkMsUUFBQUEsQ0FBQyxFQUFFLENBQUNKLEtBQUssQ0FBQ0ksQ0FBTixHQUFVSCxHQUFHLENBQUNHLENBQWYsSUFBb0I7QUFGVixPQUFmO0FBS0EsV0FBS0YsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsV0FBS0csS0FBTCxHQUFhQyxJQUFJLENBQUNDLEdBQUwsQ0FBU04sR0FBRyxDQUFDRSxDQUFKLEdBQVFILEtBQUssQ0FBQ0csQ0FBdkIsQ0FBYjtBQUNBLFdBQUtLLE1BQUwsR0FBY0YsSUFBSSxDQUFDQyxHQUFMLENBQVNOLEdBQUcsQ0FBQ0csQ0FBSixHQUFRSixLQUFLLENBQUNJLENBQXZCLENBQWQ7QUFDRDs7OzZCQUVRSyxHLEVBQUs7QUFDWixVQUFNQyxRQUFRLEdBQUcsS0FBS0QsR0FBTCxDQUFqQjs7QUFDQSxVQUFJQyxRQUFKLEVBQWM7QUFDWixZQUFNQyxHQUFHLEdBQUdELFFBQVEsQ0FBQ1YsS0FBckI7QUFDQVUsUUFBQUEsUUFBUSxDQUFDVixLQUFULEdBQWlCVSxRQUFRLENBQUNULEdBQTFCO0FBQ0FTLFFBQUFBLFFBQVEsQ0FBQ1QsR0FBVCxHQUFlVSxHQUFmO0FBQ0Q7QUFDRjs7O2dDQUVXO0FBQ1YsYUFBTyxLQUFLVCxNQUFaO0FBQ0Q7OzsrQkFFVTtBQUNULGFBQU8sS0FBS0csS0FBWjtBQUNEOzs7Z0NBRVc7QUFDVixhQUFPLEtBQUtHLE1BQVo7QUFDRDs7OytCQUVVSSxPLEVBQVNILEcsRUFBSztBQUFBLHNCQUNBLEtBQUtBLEdBQUwsQ0FEQTtBQUFBLFVBQ2ZULEtBRGUsYUFDZkEsS0FEZTtBQUFBLFVBQ1JDLEdBRFEsYUFDUkEsR0FEUTtBQUV2QixhQUFPRCxLQUFLLEdBQUdZLE9BQU8sSUFBSVgsR0FBRyxHQUFHRCxLQUFWLENBQXRCO0FBQ0Q7Ozs4QkFFU2EsSyxFQUFPSixHLEVBQUs7QUFBQSx1QkFDRyxLQUFLQSxHQUFMLENBREg7QUFBQSxVQUNaVCxLQURZLGNBQ1pBLEtBRFk7QUFBQSxVQUNMQyxHQURLLGNBQ0xBLEdBREs7QUFFcEIsYUFBTyxDQUFDWSxLQUFLLEdBQUdiLEtBQVQsS0FBbUJDLEdBQUcsR0FBR0QsS0FBekIsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7OztpQ0FNYWMsSyxFQUFPO0FBQ2xCLGFBQU9BLEtBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Z0NBTVlBLEssRUFBTztBQUNqQixhQUFPQSxLQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztnQ0FPWVgsQyxFQUFHQyxDLEVBQVk7QUFBQSxVQUFUVyxHQUFTLHVFQUFILENBQUc7QUFDekIsVUFBTXBCLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUNBLFVBQU1xQixNQUFNLEdBQUcsQ0FBRWIsQ0FBRixFQUFLQyxDQUFMLEVBQVFXLEdBQVIsQ0FBZjtBQUNBdkIsTUFBQUEsSUFBSSxDQUFDeUIsYUFBTCxDQUFtQkQsTUFBbkIsRUFBMkJBLE1BQTNCLEVBQW1DckIsTUFBbkM7QUFDQSxhQUFPcUIsTUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7aUNBT2FiLEMsRUFBR0MsQyxFQUFZO0FBQUEsVUFBVFcsR0FBUyx1RUFBSCxDQUFHO0FBQzFCLFVBQU1wQixNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFDQSxVQUFNdUIsY0FBYyxHQUFHM0IsSUFBSSxDQUFDNEIsTUFBTCxDQUFZLEVBQVosRUFBZ0J4QixNQUFoQixDQUF2QjtBQUNBLFVBQU1xQixNQUFNLEdBQUcsQ0FBRWIsQ0FBRixFQUFLQyxDQUFMLEVBQVFXLEdBQVIsQ0FBZjtBQUNBdkIsTUFBQUEsSUFBSSxDQUFDeUIsYUFBTCxDQUFtQkQsTUFBbkIsRUFBMkJBLE1BQTNCLEVBQW1DRSxjQUFuQztBQUNBLGFBQU9GLE1BQVA7QUFDRDtBQUVEOzs7Ozs7Ozs0QkFLUUYsSyxFQUFPO0FBQUEsK0JBQ0ksS0FBS00sWUFBTCxDQUFrQk4sS0FBbEIsQ0FESjtBQUFBLFVBQ0xYLENBREssc0JBQ0xBLENBREs7QUFBQSxVQUNGQyxDQURFLHNCQUNGQSxDQURFOztBQUViLFVBQU1ZLE1BQU0sR0FBRyxLQUFLSyxXQUFMLENBQWlCbEIsQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCLENBQXZCLENBQWY7QUFDQSxhQUFPO0FBQ0xELFFBQUFBLENBQUMsRUFBRWEsTUFBTSxDQUFDLENBQUQsQ0FESjtBQUVMWixRQUFBQSxDQUFDLEVBQUVZLE1BQU0sQ0FBQyxDQUFEO0FBRkosT0FBUDtBQUlEO0FBRUQ7Ozs7Ozs7OzJCQUtPRixLLEVBQU87QUFDWixVQUFNRSxNQUFNLEdBQUcsS0FBS00sWUFBTCxDQUFrQlIsS0FBSyxDQUFDWCxDQUF4QixFQUEyQlcsS0FBSyxDQUFDVixDQUFqQyxFQUFvQyxDQUFwQyxDQUFmO0FBQ0EsYUFBTyxLQUFLbUIsV0FBTCxDQUFpQjtBQUN0QnBCLFFBQUFBLENBQUMsRUFBRWEsTUFBTSxDQUFDLENBQUQsQ0FEYTtBQUV0QlosUUFBQUEsQ0FBQyxFQUFFWSxNQUFNLENBQUMsQ0FBRDtBQUZhLE9BQWpCLENBQVA7QUFJRDtBQUVEOzs7Ozs7OzsyQkFLT1EsTSxFQUFRO0FBQ2IsVUFBTTdCLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUNBLFVBQU1PLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUNBWCxNQUFBQSxJQUFJLENBQUNrQyxTQUFMLENBQWU5QixNQUFmLEVBQXVCQSxNQUF2QixFQUErQixDQUFFLENBQUNPLE1BQU0sQ0FBQ0MsQ0FBVixFQUFhLENBQUNELE1BQU0sQ0FBQ0UsQ0FBckIsQ0FBL0I7QUFDQWIsTUFBQUEsSUFBSSxDQUFDbUMsTUFBTCxDQUFZL0IsTUFBWixFQUFvQkEsTUFBcEIsRUFBNEI2QixNQUE1QjtBQUNBakMsTUFBQUEsSUFBSSxDQUFDa0MsU0FBTCxDQUFlOUIsTUFBZixFQUF1QkEsTUFBdkIsRUFBK0IsQ0FBRU8sTUFBTSxDQUFDQyxDQUFULEVBQVlELE1BQU0sQ0FBQ0UsQ0FBbkIsQ0FBL0I7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs0QkFLUUssRyxFQUFLO0FBQ1gsY0FBUUEsR0FBUjtBQUNFLGFBQUssR0FBTDtBQUNFLGVBQUtrQixRQUFMLENBQWMsR0FBZDs7QUFDQTs7QUFDRixhQUFLLEdBQUw7QUFDRSxlQUFLQSxRQUFMLENBQWMsR0FBZDs7QUFDQTs7QUFDRjtBQUNFLGVBQUtBLFFBQUwsQ0FBYyxHQUFkOztBQVJKOztBQVVBLGFBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7OzswQkFNTUMsRSxFQUFJQyxFLEVBQUk7QUFDWixVQUFNbEMsTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBQ0EsVUFBTU8sTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBQ0FYLE1BQUFBLElBQUksQ0FBQ2tDLFNBQUwsQ0FBZTlCLE1BQWYsRUFBdUJBLE1BQXZCLEVBQStCLENBQUUsQ0FBQ08sTUFBTSxDQUFDQyxDQUFWLEVBQWEsQ0FBQ0QsTUFBTSxDQUFDRSxDQUFyQixDQUEvQjtBQUNBYixNQUFBQSxJQUFJLENBQUN1QyxLQUFMLENBQVduQyxNQUFYLEVBQW1CQSxNQUFuQixFQUEyQixDQUFFaUMsRUFBRixFQUFNQyxFQUFOLENBQTNCO0FBQ0F0QyxNQUFBQSxJQUFJLENBQUNrQyxTQUFMLENBQWU5QixNQUFmLEVBQXVCQSxNQUF2QixFQUErQixDQUFFTyxNQUFNLENBQUNDLENBQVQsRUFBWUQsTUFBTSxDQUFDRSxDQUFuQixDQUEvQjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs4QkFNVUQsQyxFQUFHQyxDLEVBQUc7QUFDZCxVQUFNVCxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFDQUosTUFBQUEsSUFBSSxDQUFDa0MsU0FBTCxDQUFlOUIsTUFBZixFQUF1QkEsTUFBdkIsRUFBK0IsQ0FBRVEsQ0FBRixFQUFLQyxDQUFMLENBQS9CO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7OztnQ0FJWTtBQUNWLFdBQUtWLFlBQUwsR0FBb0IsQ0FBQyxLQUFLQSxZQUExQjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7Ozs7QUFHSHFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQnZDLEtBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHRoZSBiYXNlIGNsYXNzIG9mIENvb3JkaW5hdGVcbiAqIEBhdXRob3Igc2ltYS56aGFuZ1xuICovXG5jb25zdCBNYXRyaXhVdGlsID0gcmVxdWlyZSgnQGFudHYvdXRpbC9saWIvbWF0cml4LycpO1xuY29uc3QgbWl4ID0gcmVxdWlyZSgnQGFudHYvdXRpbC9saWIvbWl4Jyk7XG5cbmNvbnN0IG1hdDMgPSBNYXRyaXhVdGlsLm1hdDM7XG5jb25zdCB2ZWMzID0gTWF0cml4VXRpbC52ZWMzO1xuXG5jbGFzcyBDb29yZCB7XG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgZ2V0RGVmYXVsdENmZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBNYXJrIHggeSBpcyB0cmFuc3Bvc2VkLlxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGlzVHJhbnNwb3NlZDogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtYXRyaXggb2YgY29vcmRpbmF0ZVxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBtYXRyaXg6IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIGNvbnN0IGRlZmF1bHRDZmcgPSB0aGlzLmdldERlZmF1bHRDZmcoKTtcbiAgICBtaXgodGhpcywgZGVmYXVsdENmZywgY2ZnKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xuICAgIGNvbnN0IGNlbnRlciA9IHtcbiAgICAgIHg6IChzdGFydC54ICsgZW5kLngpIC8gMixcbiAgICAgIHk6IChzdGFydC55ICsgZW5kLnkpIC8gMlxuICAgIH07XG5cbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5hYnMoZW5kLnggLSBzdGFydC54KTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGguYWJzKGVuZC55IC0gc3RhcnQueSk7XG4gIH1cblxuICBfc3dhcERpbShkaW0pIHtcbiAgICBjb25zdCBkaW1SYW5nZSA9IHRoaXNbZGltXTtcbiAgICBpZiAoZGltUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGRpbVJhbmdlLnN0YXJ0O1xuICAgICAgZGltUmFuZ2Uuc3RhcnQgPSBkaW1SYW5nZS5lbmQ7XG4gICAgICBkaW1SYW5nZS5lbmQgPSB0bXA7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlcjtcbiAgfVxuXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9XG5cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfVxuXG4gIGNvbnZlcnREaW0ocGVyY2VudCwgZGltKSB7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzW2RpbV07XG4gICAgcmV0dXJuIHN0YXJ0ICsgcGVyY2VudCAqIChlbmQgLSBzdGFydCk7XG4gIH1cblxuICBpbnZlcnREaW0odmFsdWUsIGRpbSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpc1tkaW1dO1xuICAgIHJldHVybiAodmFsdWUgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIOWwhuW9kuS4gOWMlueahOWdkOagh+eCueaVsOaNrui9rOaNouS4uueUu+W4g+WdkOagh1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDlvZLkuIDljJbnmoTlnZDmoIfngrlcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICDov5Tlm57nlLvluIPlnZDmoIdcbiAgICovXG4gIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiDlsIbnlLvluIPlnZDmoIfovazmjaLkuLrlvZLkuIDljJbnmoTlnZDmoIfngrnmlbDmja5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg55S75biD5Z2Q5qCH54K55pWw5o2uXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAg5b2S5LiA5YyW5ZCO55qE5pWw5o2u54K5XG4gICAqL1xuICBpbnZlcnRQb2ludChwb2ludCkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiDlsIblnZDmoIfngrnov5vooYznn6npmLXlj5jmjaJcbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICAg5a+55bqUIHgg6L2055S75biD5Z2Q5qCHXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgIOWvueW6lCB5IOi9tOeUu+W4g+WdkOagh1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRhZyDpu5jorqTkuLogMO+8jOWPr+WPluWAvCAwLCAxXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAg6L+U5Zue5Y+Y5o2i5ZCO55qE5LiJ6Zi25ZCR6YePIFt4LCB5LCB6XVxuICAgKi9cbiAgYXBwbHlNYXRyaXgoeCwgeSwgdGFnID0gMCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIGNvbnN0IHZlY3RvciA9IFsgeCwgeSwgdGFnIF07XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQzKHZlY3RvciwgdmVjdG9yLCBtYXRyaXgpO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cblxuICAvKipcbiAgICog5bCG5Z2Q5qCH54K56L+b6KGM55+p6Zi16YCG5Y+Y5o2iXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgIOWvueW6lCB4IOi9tOeUu+W4g+WdkOagh1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICDlr7nlupQgeSDovbTnlLvluIPlnZDmoIdcbiAgICogQHBhcmFtICB7TnVtYmVyfSB0YWcg6buY6K6k5Li6IDDvvIzlj6/lj5blgLwgMCwgMVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgIOi/lOWbnuefqemYtemAhuWPmOaNouWQjueahOS4iemYtuWQkemHjyBbeCwgeSwgel1cbiAgICovXG4gIGludmVydE1hdHJpeCh4LCB5LCB0YWcgPSAwKSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgY29uc3QgaW52ZXJzZWRNYXRyaXggPSBtYXQzLmludmVydChbXSwgbWF0cml4KTtcbiAgICBjb25zdCB2ZWN0b3IgPSBbIHgsIHksIHRhZyBdO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0Myh2ZWN0b3IsIHZlY3RvciwgaW52ZXJzZWRNYXRyaXgpO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cblxuICAvKipcbiAgICog5bCG5b2S5LiA5YyW55qE5Z2Q5qCH54K55pWw5o2u6L2s5o2i5Li655S75biD5Z2Q5qCH77yM5bm25qC55o2u5Z2Q5qCH57O75b2T5YmN55+p6Zi16L+b6KGM5Y+Y5o2iXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg5b2S5LiA5YyW55qE5Z2Q5qCH54K5XG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAg6L+U5Zue6L+b6KGM55+p6Zi15Y+Y5o2i5ZCO55qE55S75biD5Z2Q5qCHXG4gICAqL1xuICBjb252ZXJ0KHBvaW50KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmNvbnZlcnRQb2ludChwb2ludCk7XG4gICAgY29uc3QgdmVjdG9yID0gdGhpcy5hcHBseU1hdHJpeCh4LCB5LCAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdmVjdG9yWzBdLFxuICAgICAgeTogdmVjdG9yWzFdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiDlsIbov5vooYzov4fnn6npmLXlj5jmjaLnlLvluIPlnZDmoIfovazmjaLkuLrlvZLkuIDljJblnZDmoIdcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDnlLvluIPlnZDmoIdcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICDov5Tlm57lvZLkuIDljJbnmoTlnZDmoIfngrlcbiAgICovXG4gIGludmVydChwb2ludCkge1xuICAgIGNvbnN0IHZlY3RvciA9IHRoaXMuaW52ZXJ0TWF0cml4KHBvaW50LngsIHBvaW50LnksIDEpO1xuICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHtcbiAgICAgIHg6IHZlY3RvclswXSxcbiAgICAgIHk6IHZlY3RvclsxXVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIOWdkOagh+ezu+aXi+i9rOWPmOaNolxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJhZGlhbiDml4vovazlvKfluqZcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAg6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAqL1xuICByb3RhdGUocmFkaWFuKSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgbWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFsgLWNlbnRlci54LCAtY2VudGVyLnkgXSk7XG4gICAgbWF0My5yb3RhdGUobWF0cml4LCBtYXRyaXgsIHJhZGlhbik7XG4gICAgbWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFsgY2VudGVyLngsIGNlbnRlci55IF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIOWdkOagh+ezu+WPjeWwhOWPmOaNolxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpbSDlj43lsITnu7TluqZcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAg6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAqL1xuICByZWZsZWN0KGRpbSkge1xuICAgIHN3aXRjaCAoZGltKSB7XG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgdGhpcy5fc3dhcERpbSgneCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3knOlxuICAgICAgICB0aGlzLl9zd2FwRGltKCd5Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fc3dhcERpbSgneScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiDlnZDmoIfns7vmr5Tkvovlj5jmjaJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBzMSB4IOaWueWQkee8qeaUvuavlOS+i1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHMyIHkg5pa55ZCR57yp5pS+5q+U5L6LXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAg6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAqL1xuICBzY2FsZShzMSwgczIpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWyAtY2VudGVyLngsIC1jZW50ZXIueSBdKTtcbiAgICBtYXQzLnNjYWxlKG1hdHJpeCwgbWF0cml4LCBbIHMxLCBzMiBdKTtcbiAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWyBjZW50ZXIueCwgY2VudGVyLnkgXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICog5Z2Q5qCH57O75bmz56e75Y+Y5o2iXG4gICAqIEBwYXJhbSAge051bWJlcn0geCB4IOaWueWQkeW5s+enu+WDj+e0oFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgeSDmlrnlkJHlubPnp7vlg4/ntKBcbiAgICogQHJldHVybiB7T2JqZWN0fSAgIOi/lOWbnuWdkOagh+ezu+WvueixoVxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWyB4LCB5IF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIOWwhuWdkOagh+ezuyB4IHkg5Lik5Liq6L206L+b6KGM6L2s572uXG4gICAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAqL1xuICB0cmFuc3Bvc2UoKSB7XG4gICAgdGhpcy5pc1RyYW5zcG9zZWQgPSAhdGhpcy5pc1RyYW5zcG9zZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZDtcbiJdfQ==

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview G2 鍥捐〃鐨勫叆鍙ｆ枃浠�
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var View = __webpack_require__(279);

var G = __webpack_require__(16);

var Canvas = G.Canvas;
var DomUtil = Util.DomUtil;

var Global = __webpack_require__(5);

var Plot = __webpack_require__(283);

var Controller = __webpack_require__(121);

var mergeBBox = __webpack_require__(123);

var bboxOfBackPlot = __webpack_require__(122);

var plotRange2BBox = __webpack_require__(124);

var AUTO_STR = 'auto';

function _isScaleExist(scales, compareScale) {
  var flag = false;
  Util.each(scales, function (scale) {
    var scaleValues = [].concat(scale.values);
    var compareScaleValues = [].concat(compareScale.values);

    if (scale.type === compareScale.type && scale.field === compareScale.field && scaleValues.sort().toString() === compareScaleValues.sort().toString()) {
      flag = true;
      return;
    }
  });
  return flag;
}

function isEqualArray(arr1, arr2) {
  return Util.isEqualWith(arr1, arr2, function (v1, v2) {
    return v1 === v2;
  });
}
/**
 * 鍥捐〃鐨勫叆鍙�
 * @class Chart
 */


var Chart = /*#__PURE__*/function (_View) {
  _inheritsLoose(Chart, _View);

  function Chart() {
    return _View.apply(this, arguments) || this;
  }

  var _proto = Chart.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var viewCfg = _View.prototype.getDefaultCfg.call(this);

    return Util.mix(viewCfg, {
      id: null,
      forceFit: false,
      container: null,
      wrapperEl: null,
      canvas: null,
      width: 500,
      height: 500,
      pixelRatio: null,
      backPlot: null,
      frontPlot: null,
      plotBackground: null,
      padding: Global.plotCfg.padding,
      background: null,
      autoPaddingAppend: 5,
      limitInPlot: false,
      renderer: Global.renderer,
      // renderer: 'svg',
      views: []
    });
  };

  _proto.init = function init() {
    var self = this;
    var viewTheme = self.get('viewTheme');

    self._initCanvas();

    self._initPlot();

    self._initEvents();

    _View.prototype.init.call(this);

    var tooltipController = new Controller.Tooltip({
      chart: self,
      viewTheme: viewTheme,
      options: {}
    });
    self.set('tooltipController', tooltipController);
    var legendController = new Controller.Legend({
      chart: self,
      viewTheme: viewTheme
    });
    self.set('legendController', legendController);
    self.set('_id', 'chart'); // 闃叉鍚岀敤鎴疯瀹氱殑 id 鍚屽悕

    self.emit('afterinit'); // 鍒濆鍖栧畬姣�
  };

  _proto._isAutoPadding = function _isAutoPadding() {
    var padding = this.get('padding');

    if (Util.isArray(padding)) {
      return padding.includes(AUTO_STR);
    }

    return padding === AUTO_STR;
  };

  _proto._getAutoPadding = function _getAutoPadding() {
    var padding = this.get('padding'); // 鍥句緥鍦ㄦ渶鍓嶉潰鐨勪竴灞�

    var frontPlot = this.get('frontPlot');
    var frontBBox = frontPlot.getBBox(); // 鍧愭爣杞村湪鏈€鍚庨潰鐨勪竴灞�

    var backPlot = this.get('backPlot'); // 杩欐浠ｇ爜涓存椂澶勭悊浜唗itle 杩囬暱鐨勬儏鍐碉紝浣嗘槸鏄潪甯镐笉濂界殑浠ｇ爜

    var backBBox = bboxOfBackPlot(backPlot, plotRange2BBox(this.get('plotRange')));
    var box = mergeBBox(frontBBox, backBBox);
    var outter = [0 - box.minY, // 涓婇潰瓒呭嚭鐨勯儴鍒�
    box.maxX - this.get('width'), // 鍙宠竟瓒呭嚭鐨勯儴鍒�
    box.maxY - this.get('height'), // 涓嬭竟瓒呭嚭鐨勯儴鍒�
    0 - box.minX]; // 濡傛灉鍘熷鐨� padding 鍐呴儴瀛樺湪 'auto' 鍒欐浛鎹㈠搴旂殑杈�

    var autoPadding = Util.toAllPadding(padding);

    for (var i = 0; i < autoPadding.length; i++) {
      if (autoPadding[i] === AUTO_STR) {
        var tmp = Math.max(0, outter[i]);
        autoPadding[i] = tmp + this.get('autoPaddingAppend');
      }
    }

    return autoPadding;
  } // 鍒濆鍖栫敾甯�
  ;

  _proto._initCanvas = function _initCanvas() {
    var container = this.get('container');
    var id = this.get('id'); // 濡傛灉鏈缃� container 浣跨敤 ID, 鍏煎 2.x 鐗堟湰

    if (!container && id) {
      container = id;
      this.set('container', id);
    }

    var width = this.get('width');
    var height = this.get('height');

    if (Util.isString(container)) {
      container = document.getElementById(container);

      if (!container) {
        throw new Error('Please specify the container for the chart!');
      }

      this.set('container', container);
    }

    var wrapperEl = DomUtil.createDom('<div style="position:relative;"></div>');
    container.appendChild(wrapperEl);
    this.set('wrapperEl', wrapperEl);

    if (this.get('forceFit')) {
      width = DomUtil.getWidth(container, width);
      this.set('width', width);
    }

    var renderer = this.get('renderer');
    var canvas = new Canvas({
      containerDOM: wrapperEl,
      width: width,
      height: height,
      // NOTICE: 鏈夐棶棰樻壘闈掓钩
      pixelRatio: renderer === 'svg' ? 1 : this.get('pixelRatio'),
      renderer: renderer
    });
    this.set('canvas', canvas);
  } // 鍒濆鍖栫粯鍥惧尯闂�
  ;

  _proto._initPlot = function _initPlot() {
    var self = this;

    self._initPlotBack(); // 鏈€搴曞眰鐨勬槸鑳屾櫙鐩稿叧鐨� group


    var canvas = self.get('canvas');
    var backPlot = canvas.addGroup({
      zIndex: 1
    }); // 鍥捐〃鏈€鍚庨潰鐨勫鍣�

    var plotContainer = canvas.addGroup({
      zIndex: 0
    }); // 鍥捐〃鎵€鍦ㄧ殑瀹瑰櫒

    var frontPlot = canvas.addGroup({
      zIndex: 3
    }); // 鍥捐〃鍓嶉潰鐨勫鍣�

    self.set('backPlot', backPlot);
    self.set('middlePlot', plotContainer);
    self.set('frontPlot', frontPlot);
  } // 鍒濆鍖栬儗鏅�
  ;

  _proto._initPlotBack = function _initPlotBack() {
    var self = this;
    var canvas = self.get('canvas');
    var viewTheme = self.get('viewTheme');
    var plot = canvas.addGroup(Plot, {
      padding: this.get('padding'),
      plotBackground: Util.mix({}, viewTheme.plotBackground, self.get('plotBackground')),
      background: Util.mix({}, viewTheme.background, self.get('background'))
    });
    self.set('plot', plot);
    self.set('plotRange', plot.get('plotRange'));
  };

  _proto._initEvents = function _initEvents() {
    if (this.get('forceFit')) {
      window.addEventListener('resize', Util.wrapBehavior(this, '_initForceFitEvent'));
    }
  };

  _proto._initForceFitEvent = function _initForceFitEvent() {
    var timer = setTimeout(Util.wrapBehavior(this, 'forceFit'), 200);
    clearTimeout(this.get('resizeTimer'));
    this.set('resizeTimer', timer);
  } // 缁樺埗鍥句緥
  ;

  _proto._renderLegends = function _renderLegends() {
    var options = this.get('options');
    var legendOptions = options.legends;

    if (Util.isNil(legendOptions) || legendOptions !== false) {
      // 娌℃湁鍏抽棴鍥句緥
      var legendController = this.get('legendController');
      legendController.options = legendOptions || {};
      legendController.plotRange = this.get('plotRange');

      if (legendOptions && legendOptions.custom) {
        // 鐢ㄦ埛鑷畾涔夊浘渚�
        legendController.addCustomLegend();
      } else {
        var geoms = this.getAllGeoms();
        var scales = [];
        Util.each(geoms, function (geom) {
          var view = geom.get('view');
          var attrs = geom.getAttrsForLegend();
          Util.each(attrs, function (attr) {
            var type = attr.type;
            var scale = attr.getScale(type);

            if (scale.field && scale.type !== 'identity' && !_isScaleExist(scales, scale)) {
              scales.push(scale);
              var filteredValues = view.getFilteredOutValues(scale.field);
              legendController.addLegend(scale, attr, geom, filteredValues);
            }
          });
        }); // 鍙岃酱鐨勬儏鍐�

        var yScales = this.getYScales();

        if (scales.length === 0 && yScales.length > 1) {
          legendController.addMixedLegend(yScales, geoms);
        }
      }

      legendController.alignLegends();
    }
  } // 缁樺埗 tooltip
  ;

  _proto._renderTooltips = function _renderTooltips() {
    var options = this.get('options');

    if (Util.isNil(options.tooltip) || options.tooltip !== false) {
      // 鐢ㄦ埛娌℃湁鍏抽棴 tooltip
      var tooltipController = this.get('tooltipController');
      tooltipController.options = options.tooltip || {};
      tooltipController.renderTooltip();
    }
  }
  /**
   * 鑾峰彇鎵€鏈夌殑鍑犱綍鏍囪
   * @return {Array} 鎵€鏈夌殑鍑犱綍鏍囪
   */
  ;

  _proto.getAllGeoms = function getAllGeoms() {
    var geoms = [];
    geoms = geoms.concat(this.get('geoms'));
    var views = this.get('views');
    Util.each(views, function (view) {
      geoms = geoms.concat(view.get('geoms'));
    });
    return geoms;
  }
  /**
   * 鑷€傚簲瀹藉害
   * @chainable
   * @return {Chart} 鍥捐〃瀵硅薄
   */
  ;

  _proto.forceFit = function forceFit() {
    var self = this;

    if (!self || self.destroyed) {
      return;
    }

    var container = self.get('container');
    var oldWidth = self.get('width');
    var width = DomUtil.getWidth(container, oldWidth);

    if (width !== 0 && width !== oldWidth) {
      var height = self.get('height');
      self.changeSize(width, height);
    }

    return self;
  };

  _proto.resetPlot = function resetPlot() {
    var plot = this.get('plot');
    var padding = this.get('padding');

    if (!isEqualArray(padding, plot.get('padding'))) {
      // 閲嶇疆 padding锛屼粎褰損adding 鍙戠敓鏇存敼
      plot.set('padding', padding);
      plot.repaint();
    }
  }
  /**
   * 鏀瑰彉澶у皬
   * @param  {Number} width  鍥捐〃瀹藉害
   * @param  {Number} height 鍥捐〃楂樺害
   * @return {Chart} 鍥捐〃瀵硅薄
   */
  ;

  _proto.changeSize = function changeSize(width, height) {
    var self = this;
    var canvas = self.get('canvas');
    canvas.changeSize(width, height);
    var plot = this.get('plot');
    self.set('width', width);
    self.set('height', height); // change size 鏃堕噸鏂拌绠楄竟妗�

    plot.repaint(); // 淇濇寔杈规涓嶅彉锛岄槻姝㈣嚜鍔� padding 鏃剁粯鍒跺閬�

    this.set('keepPadding', true);
    self.repaint();
    this.set('keepPadding', false);
    this.emit('afterchangesize');
    return self;
  }
  /**
   * 鏀瑰彉瀹藉害
   * @param  {Number} width  鍥捐〃瀹藉害
   * @return {Chart} 鍥捐〃瀵硅薄
   */
  ;

  _proto.changeWidth = function changeWidth(width) {
    return this.changeSize(width, this.get('height'));
  }
  /**
   * 鏀瑰彉瀹藉害
   * @param  {Number} height  鍥捐〃楂樺害
   * @return {Chart} 鍥捐〃瀵硅薄
   */
  ;

  _proto.changeHeight = function changeHeight(height) {
    return this.changeSize(this.get('width'), height);
  }
  /**
   * 鍒涘缓涓€涓鍥�
   * @param  {Object} cfg 瑙嗗浘鐨勯厤缃」
   * @return {View} 瑙嗗浘瀵硅薄
   */
  ;

  _proto.view = function view(cfg) {
    cfg = cfg || {};
    cfg.theme = this.get('theme');
    cfg.parent = this;
    cfg.backPlot = this.get('backPlot');
    cfg.middlePlot = this.get('middlePlot');
    cfg.frontPlot = this.get('frontPlot');
    cfg.canvas = this.get('canvas');

    if (Util.isNil(cfg.animate)) {
      cfg.animate = this.get('animate');
    }

    cfg.options = Util.mix({}, this._getSharedOptions(), cfg.options);
    var view = new View(cfg);
    view.set('_id', 'view' + this.get('views').length); // 鏍囪瘑 ID锛岄槻姝㈠悓鐢ㄦ埛璁惧畾鐨� id 閲嶅悕

    this.get('views').push(view);
    this.emit('addview', {
      view: view
    });
    return view;
  } // isShapeInView() {
  //   return true;
  // }
  ;

  _proto.removeView = function removeView(view) {
    var views = this.get('views');
    Util.Array.remove(views, view);
    view.destroy();
  };

  _proto._getSharedOptions = function _getSharedOptions() {
    var options = this.get('options');
    var sharedOptions = {};
    Util.each(['scales', 'coord', 'axes'], function (name) {
      sharedOptions[name] = Util.cloneDeep(options[name]);
    });
    return sharedOptions;
  }
  /**
   * @override
   * 褰撳墠chart 鐨勮寖鍥�
   */
  ;

  _proto.getViewRegion = function getViewRegion() {
    var plotRange = this.get('plotRange');
    return {
      start: plotRange.bl,
      end: plotRange.tr
    };
  }
  /**
   * 璁剧疆鍥句緥閰嶇疆淇℃伅
   * @param  {String|Object} field 瀛楁鍚�
   * @param  {Object} [cfg] 鍥句緥鐨勯厤缃」
   * @return {Chart} 褰撳墠鐨勫浘琛ㄥ璞�
   */
  ;

  _proto.legend = function legend(field, cfg) {
    var options = this.get('options');

    if (!options.legends) {
      options.legends = {};
    }

    var legends = {};

    if (field === false) {
      options.legends = false;
    } else if (Util.isObject(field)) {
      legends = field;
    } else if (Util.isString(field)) {
      legends[field] = cfg;
    } else {
      legends = cfg;
    }

    Util.mix(options.legends, legends);
    return this;
  }
  /**
   * 璁剧疆鎻愮ず淇℃伅
   * @param  {String|Object} visible 鏄惁鍙
   * @param  {Object} [cfg] 鎻愮ず淇℃伅鐨勯厤缃」
   * @return {Chart} 褰撳墠鐨勫浘琛ㄥ璞�
   */
  ;

  _proto.tooltip = function tooltip(visible, cfg) {
    var options = this.get('options');

    if (!options.tooltip) {
      options.tooltip = {};
    }

    if (visible === false) {
      options.tooltip = false;
    } else if (Util.isObject(visible)) {
      Util.mix(options.tooltip, visible);
    } else {
      Util.mix(options.tooltip, cfg);
    }

    return this;
  }
  /**
   * 娓呯┖鍥捐〃
   * @return {Chart} 褰撳墠鐨勫浘琛ㄥ璞�
   */
  ;

  _proto.clear = function clear() {
    this.emit('beforeclear');
    var views = this.get('views');

    while (views.length > 0) {
      var view = views.shift();
      view.destroy();
    }

    _View.prototype.clear.call(this);

    var canvas = this.get('canvas');
    this.resetPlot();
    canvas.draw();
    this.emit('afterclear');
    return this;
  };

  _proto.clearInner = function clearInner() {
    var views = this.get('views');
    Util.each(views, function (view) {
      view.clearInner();
    });
    var tooltipController = this.get('tooltipController');
    tooltipController && tooltipController.clear();

    if (!this.get('keepLegend')) {
      var legendController = this.get('legendController');
      legendController && legendController.clear();
    }

    _View.prototype.clearInner.call(this);
  } // chart 闄や簡view 涓婄粯鍒剁殑缁勪欢澶栵紝杩樹細缁樺埗鍥句緥鍜� tooltip
  ;

  _proto.drawComponents = function drawComponents() {
    _View.prototype.drawComponents.call(this); // 涓€鑸槸鐐瑰嚮鍥句緥鏃讹紝浠呬粎闅愯棌鏌愪簺閫夐」锛岃€屼笉閿€姣佸浘渚�


    if (!this.get('keepLegend')) {
      this._renderLegends(); // 娓叉煋鍥句緥

    }
  }
  /**
   * 缁樺埗鍥捐〃
   * @override
   */
  ;

  _proto.render = function render() {
    var self = this; // 闇€瑕佽嚜鍔ㄨ绠楄竟妗嗭紝鍒欓噸鏂拌缃�

    if (!self.get('keepPadding') && self._isAutoPadding()) {
      self.beforeRender(); // 鍒濆鍖栧悇涓� view 鍜� 缁樺埗

      self.drawComponents();

      var autoPadding = self._getAutoPadding();

      var plot = self.get('plot'); // 鍦ㄨ绠楀嚭鏉ョ殑杈规涓嶄竴鑷寸殑鎯呭喌锛岄噸鏂版敼鍙樿竟妗�

      if (!isEqualArray(plot.get('padding'), autoPadding)) {
        plot.set('padding', autoPadding);
        plot.repaint();
      }
    }

    var middlePlot = self.get('middlePlot');

    if (self.get('limitInPlot') && !middlePlot.attr('clip')) {
      var clip = Util.getClipByRange(self.get('plotRange')); // TODO Polar coord

      middlePlot.attr('clip', clip); // clip.attr('fill', 'grey');
      // clip.attr('opacity', 0.5);
      // middlePlot.add(clip);
    }

    _View.prototype.render.call(this);

    self._renderTooltips(); // 娓叉煋 tooltip

  };

  _proto.repaint = function repaint() {
    // 閲嶇粯鏃堕渶瑕佸垽瀹氬綋鍓嶇殑 padding 鏄惁鍙戠敓杩囨敼鍙橈紝濡傛灉鍙戠敓杩囨敼鍙樿繘琛岃皟鏁�
    // 闇€瑕佸垽瀹氭槸鍚︿娇鐢ㄤ簡鑷姩 padding
    if (!this.get('keepPadding')) {
      this.resetPlot();
    }

    _View.prototype.repaint.call(this);
  }
  /**
   * @override
   * 鏄剧ず鎴栬€呴殣钘�
   */
  ;

  _proto.changeVisible = function changeVisible(visible) {
    var wrapperEl = this.get('wrapperEl');
    var visibleStr = visible ? '' : 'none';
    wrapperEl.style.display = visibleStr;
  }
  /**
   * 杩斿洖鍥捐〃鐨� dataUrl 鐢ㄤ簬鐢熸垚鍥剧墖
   * @return {String} dataUrl 璺緞
   */
  ;

  _proto.toDataURL = function toDataURL() {
    var chart = this;
    var canvas = chart.get('canvas');
    var renderer = chart.get('renderer');
    var canvasDom = canvas.get('el');
    var dataURL = '';

    if (renderer === 'svg') {
      var clone = canvasDom.cloneNode(true);
      var svgDocType = document.implementation.createDocumentType('svg', '-//W3C//DTD SVG 1.1//EN', 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');
      var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
      svgDoc.replaceChild(clone, svgDoc.documentElement);
      var svgData = new XMLSerializer().serializeToString(svgDoc);
      dataURL = 'data:image/svg+xml;charset=utf8,' + encodeURIComponent(svgData);
    } else if (renderer === 'canvas') {
      dataURL = canvasDom.toDataURL('image/png');
    }

    return dataURL;
  }
  /**
   * 鍥捐〃瀵煎嚭鍔熻兘
   * @param  {String} [name] 鍥剧墖鐨勫悕绉帮紝榛樿涓� chart(.png|.svg)
   */
  ;

  _proto.downloadImage = function downloadImage(name) {
    var chart = this;
    var link = document.createElement('a');
    var renderer = chart.get('renderer');
    var filename = (name || 'chart') + (renderer === 'svg' ? '.svg' : '.png');
    var canvas = chart.get('canvas');
    canvas.get('timeline').stopAllAnimations();
    setTimeout(function () {
      var dataURL = chart.toDataURL();

      if (window.Blob && window.URL && renderer !== 'svg') {
        var arr = dataURL.split(',');
        var mime = arr[0].match(/:(.*?);/)[1];
        var bstr = atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        var blobObj = new Blob([u8arr], {
          type: mime
        });

        if (window.navigator.msSaveBlob) {
          window.navigator.msSaveBlob(blobObj, filename);
        } else {
          link.addEventListener('click', function () {
            link.download = filename;
            link.href = window.URL.createObjectURL(blobObj);
          });
        }
      } else {
        link.addEventListener('click', function () {
          link.download = filename;
          link.href = dataURL;
        });
      }

      var e = document.createEvent('MouseEvents');
      e.initEvent('click', false, false);
      link.dispatchEvent(e);
    }, 16);
  }
  /**
   * 鏍规嵁鍧愭爣鐐规樉绀哄搴旂殑 tooltip
   * @param  {Object} point 鐢诲竷涓婄殑鐐�
   * @return {Chart}       杩斿洖 chart 瀹炰緥
   */
  ;

  _proto.showTooltip = function showTooltip(point) {
    var views = this.getViewsByPoint(point);

    if (views.length) {
      var tooltipController = this.get('tooltipController');
      tooltipController.showTooltip(point, views);
    }

    return this;
  }
  /**
   * 灏唗ooltip 閿佸畾鍒板綋鍓嶄綅缃笉鑳界Щ鍔�
   * @return {Chart}       杩斿洖 chart 瀹炰緥
   */
  ;

  _proto.lockTooltip = function lockTooltip() {
    var tooltipController = this.get('tooltipController');
    tooltipController.lockTooltip();
    return this;
  }
  /**
   * 灏唗ooltip 閿佸畾瑙ｉ櫎
   * @return {Chart}       杩斿洖 chart 瀹炰緥
   */
  ;

  _proto.unlockTooltip = function unlockTooltip() {
    var tooltipController = this.get('tooltipController');
    tooltipController.unlockTooltip();
    return this;
  }
  /**
   * 闅愯棌 tooltip
  * @return {Chart}       杩斿洖 chart 瀹炰緥
   */
  ;

  _proto.hideTooltip = function hideTooltip() {
    var tooltipController = this.get('tooltipController');
    tooltipController.hideTooltip();
    return this;
  }
  /**
   * 鏍规嵁浼犲叆鐨勭敾甯冨潗鏍囷紝鑾峰彇璇ュ鐨� tooltip 涓婄殑璁板綍淇℃伅
   * @param  {Object} point 鐢诲竷鍧愭爣鐐�
   * @return {Array}       杩斿洖缁撴灉
   */
  ;

  _proto.getTooltipItems = function getTooltipItems(point) {
    var self = this;
    var views = self.getViewsByPoint(point);
    var rst = [];
    Util.each(views, function (view) {
      var geoms = view.get('geoms');
      Util.each(geoms, function (geom) {
        var dataArray = geom.get('dataArray');
        var items = [];
        Util.each(dataArray, function (data) {
          var tmpPoint = geom.findPoint(point, data);

          if (tmpPoint) {
            var subItems = geom.getTipItems(tmpPoint);
            items = items.concat(subItems);
          }
        });
        rst = rst.concat(items);
      });
    });
    return rst;
  }
  /**
   * @override
   * 閿€姣佸浘琛�
   */
  ;

  _proto.destroy = function destroy() {
    this.emit('beforedestroy');
    clearTimeout(this.get('resizeTimer'));
    var canvas = this.get('canvas');
    var wrapperEl = this.get('wrapperEl');
    wrapperEl.parentNode.removeChild(wrapperEl);

    _View.prototype.destroy.call(this);

    canvas.destroy();
    window.removeEventListener('resize', Util.getWrapBehavior(this, '_initForceFitEvent'));
    this.emit('afterdestroy');
  };

  return Chart;
}(View);

module.exports = Chart;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var Scale = __webpack_require__(154);

var G = __webpack_require__(16);

var Animate = __webpack_require__(119);

var Chart = __webpack_require__(44);

var Global = __webpack_require__(5);

var Shape = __webpack_require__(9);

var Util = __webpack_require__(0);

var G2 = {
  // version
  version: Global.version,
  // visual encoding
  Animate: Animate,
  Chart: Chart,
  Global: Global,
  Scale: Scale,
  Shape: Shape,
  Util: Util,
  // render engine
  G: G,
  DomUtil: Util.DomUtil,
  MatrixUtil: Util.MatrixUtil,
  PathUtil: Util.PathUtil
}; // G2.track = function(enable) {
//   Global.trackable = enable;
// };
// require('./track');

G2.track = function () {
  console.warn('G2 tracks nothing ;-)');
}; // 淇濊瘉涓や釜鐗堟湰鍏卞瓨


if (typeof window !== 'undefined') {
  if (window.G2) {
    console.warn("There are multiple versions of G2. Version " + G2.version + "'s reference is 'window.G2_3'");
  } else {
    window.G2 = G2;
  }
}

module.exports = G2;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview facets of chart
 * @author dxq613@gmail.com
 */
var Global = __webpack_require__(5);

var Util = __webpack_require__(0);

var assign = Util.assign;
var isNil = Util.isNil;
var isArray = Util.isArray;
var cloneDeep = Util.cloneDeep; // 缁戝畾浜嬩欢

var wrapBehavior = Util.wrapBehavior; // 鑾峰彇缁戝畾鐨勪簨浠�

var getWrapBehavior = Util.getWrapBehavior;

var Base = /*#__PURE__*/function () {
  var _proto = Base.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      chart: null,
      group: null,

      /**
       * 鏄惁榛樿鏄剧ず姣忎釜鍒嗛潰鐨則itle
       * @type {Boolean}
       */
      showTitle: true,

      /**
       * 鏄惁鑷姩淇敼鍧愭爣杞寸殑淇℃伅
       * @type {Boolean}
       */
      autoSetAxis: true,

      /**
       * View 鐨勫唴杈规
       * @type {Number|Array}
       */
      padding: 10,

      /**
       * 閬嶅巻姣忎釜view 鐨勫洖璋冨嚱鏁�
       * @type {Function}
       */
      eachView: null,

      /**
       * 鍒嗛潰鐨勫瓧娈靛悕鍒楄〃
       * @type {Array}
       */
      fields: [],

      /**
       * 鍒楀€肩殑鐨勬爣棰�
       * @type {Object}
       */
      colTitle: {
        offsetY: -15,
        style: {
          fontSize: 14,
          textAlign: 'center',
          fill: '#666',
          fontFamily: Global.fontFamily
        }
      },
      rowTitle: {
        offsetX: 15,
        style: {
          fontSize: 14,
          textAlign: 'center',
          rotate: 90,
          fill: '#666',
          fontFamily: Global.fontFamily
        }
      }
    };
  };

  function Base(cfg) {
    var defaultCfg = this.getDefaultCfg();
    assign(this, defaultCfg, cfg);
    this.init();
  }

  _proto.init = function init() {
    if (!this.chart) {
      throw new Error('Facets Error: please specify the chart!');
    }

    this._bindEvent();

    this.initContainer();

    if (this.chart.get('data')) {
      this.initViews();
    }
  };

  _proto.initContainer = function initContainer() {
    var chart = this.chart;
    var frontPlot = chart.get('frontPlot');
    var group = frontPlot.addGroup();
    this.group = group;
  };

  _proto.initViews = function initViews() {
    var chart = this.chart;
    var data = chart.get('data');
    var eachView = this.eachView;
    var facets = this.generateFacets(data);

    for (var i = 0; i < facets.length; i++) {
      var facet = facets[i];
      var region = facet.region;
      var view = chart.view({
        start: region.start,
        end: region.end,
        padding: this.padding
      });
      view.source(facet.data);
      this.beforeProcessView(view, facet);

      if (eachView) {
        eachView(view, facet);
      }

      this.afterProcessView(view, facet);
      facet.view = view;
    }

    this.facets = facets;
  }
  /**
   * 澶勭悊 view 鍓�
   * @protected
   */
  ;

  _proto.beforeProcessView = function beforeProcessView()
  /* view, facet */
  {}
  /**
   * 澶勭悊view
   * @param {Object} view 瑙嗗浘
   * @param {Object} facet 鍒嗛潰淇℃伅
   * @protected
   */
  ;

  _proto.afterProcessView = function afterProcessView(view, facet) {
    if (this.autoSetAxis) {
      this.processAxis(view, facet);
    }
  };

  _proto.processAxis = function processAxis(view, facet) {
    var viewOptions = view.get('options');
    var geoms = view.get('geoms');

    if ((!viewOptions.coord.type || viewOptions.coord.type === 'rect') && geoms.length) {
      var field = geoms[0].get('attrOptions').position.field;
      var fields = isArray(field) ? field : field.split('*').map(function (str) {
        return str.trim();
      });
      var xField = fields[0];
      var yField = fields[1];

      if (isNil(viewOptions.axes)) {
        viewOptions.axes = {};
      }

      var axes = viewOptions.axes;

      if (axes !== false) {
        if (xField && axes[xField] !== false) {
          axes[xField] = axes[xField] || {};
          this.setXAxis(xField, axes, facet);
        }

        if (yField && axes[yField] !== false) {
          axes[yField] = axes[yField] || {};
          this.setYAxis(yField, axes, facet);
        }
      }
    }
  };

  _proto.setXAxis = function setXAxis()
  /* xField, axes, facet */
  {};

  _proto.setYAxis = function setYAxis()
  /* yField, axes, facet */
  {} // 榛樿鏄剧ず鍚勫垪鐨勬爣棰�
  ;

  _proto.renderTitle = function renderTitle(view, facet) {
    this.drawColTitle(view, facet);
  };

  _proto.getScaleText = function getScaleText(field, value, view) {
    var rst;

    if (field) {
      var scales = view.get('scales');
      var scale = scales[field];

      if (!scale) {
        scale = view.createScale(field);
      }

      rst = scale.getText(value);
    } else {
      rst = value;
    }

    return rst;
  };

  _proto.drawColTitle = function drawColTitle(view, facet) {
    var text = this.getScaleText(facet.colField, facet.colValue, view);
    var colTextCfg = assign({
      position: ['50%', '0%'],
      content: text
    }, this.colTitle);
    view.guide().text(colTextCfg);
  };

  _proto.drawRowTitle = function drawRowTitle(view, facet) {
    var text = this.getScaleText(facet.rowField, facet.rowValue, view);
    var rowTextCfg = assign({
      position: ['100%', '50%'],
      content: text
    }, cloneDeep(this.rowTitle));
    view.guide().text(rowTextCfg);
  }
  /**
   * 鏁版嵁杩囨护鍣�
   * @protected
   * @param {Array} conditions 杩囨护鏉′欢
   * @return {Function} 杩囨护鍑芥暟
   */
  ;

  _proto.getFilter = function getFilter(conditions) {
    var filter = function filter(obj) {
      var filtered = true;
      conditions.forEach(function (cond) {
        var field = cond.field;
        var value = cond.value; // const values = cond.values;

        var tmp = true;

        if (!isNil(value) && field) {
          tmp = obj[field] === value;
        }

        filtered = filtered && tmp;
      });
      return filtered;
    };

    return filter;
  }
  /**
   * 鑾峰彇瀛楁瀵瑰簲鐨勫€�
   * @protected
   * @param  {String} field 瀛楁鍚�
   * @param  {Array} data 鏁版嵁
   * @return {Array} 瀛楁瀵瑰簲鐨勫€�
   */
  ;

  _proto.getFieldValues = function getFieldValues(field, data) {
    var rst = [];
    var tmpMap = {};

    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var value = obj[field];

      if (!isNil(value) && !tmpMap[value]) {
        rst.push(value);
        tmpMap[value] = true;
      }
    }

    return rst;
  };

  _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols; // x杞存柟鍚戠殑姣忎釜鍒嗛潰鐨勫亸绉�

    var yWidth = 1 / rows; // y杞存柟鍚戠殑姣忎釜鍒嗛潰鐨勫亸绉�

    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth
    };
    return {
      start: start,
      end: end
    };
  }
  /**
   * 鐢熸垚鍒嗛潰
   * @protected
   * @return {Array} 澶氫釜鍒嗛潰闆嗗悎
   */
  ;

  _proto.generateFacets = function generateFacets()
  /* data */
  {
    return [];
  };

  _proto._bindEvent = function _bindEvent() {
    var chart = this.chart;
    chart.on('afterchangedata', wrapBehavior(this, 'onDataChange'));
    chart.on('beforeclear', wrapBehavior(this, 'onClear'));
    chart.on('beforedestroy', wrapBehavior(this, 'destroy'));
    chart.on('beforepaint', wrapBehavior(this, 'onPaint'));
    chart.on('setdata', wrapBehavior(this, 'onDataChange'));
  };

  _proto._clearEvent = function _clearEvent() {
    var chart = this.chart;

    if (chart) {
      chart.off('afterchangedata', getWrapBehavior(this, 'onDataChange'));
      chart.off('beforeclear', getWrapBehavior(this, 'onClear'));
      chart.off('beforedestroy', getWrapBehavior(this, 'destroy'));
      chart.off('beforepaint', getWrapBehavior(this, 'onPaint'));
      chart.off('setdata', getWrapBehavior(this, 'onDataChange'));
    }
  };

  _proto._clearFacets = function _clearFacets() {
    var facets = this.facets;
    var chart = this.chart;

    if (facets) {
      for (var i = 0; i < facets.length; i++) {
        var facet = facets[i];
        chart.removeView(facet.view);
      }
    }

    this.facets = null;
  };

  _proto.onClear = function onClear() {
    this.onRemove();
  };

  _proto.onPaint = function onPaint() {
    if (this.showTitle) {
      var facets = this.facets;

      for (var i = 0; i < facets.length; i++) {
        var facet = facets[i];
        var view = facet.view;
        this.renderTitle(view, facet);
      }
    }
  };

  _proto.onDataChange = function onDataChange() {
    this._clearFacets();

    this.initViews();
  };

  _proto.onRemove = function onRemove() {
    this._clearFacets();

    this._clearEvent();

    this.group && this.group.remove();
    this.chart = null;
    this.facets = null;
    this.group = null;
  };

  _proto.destroy = function destroy() {
    this.onRemove();
    this.destroyed = true;
  };

  return Base;
}();

module.exports = Base;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

function circlePoint(cx, cy, r, angle) {
  return {
    x: Math.cos(angle) * r + cx,
    y: Math.sin(angle) * r + cy
  };
}

function angleNearTo(angle, min, max, out) {
  var v1;
  var v2;

  if (out) {
    if (angle < min) {
      v1 = min - angle;
      v2 = Math.PI * 2 - max + angle;
    } else if (angle > max) {
      v1 = Math.PI * 2 - angle + min;
      v2 = angle - max;
    }
  } else {
    v1 = angle - min;
    v2 = max - angle;
  }

  return v1 > v2 ? max : min;
}

function nearAngle(angle, startAngle, endAngle, clockwise) {
  var plus = 0;

  if (endAngle - startAngle >= Math.PI * 2) {
    plus = Math.PI * 2;
  }

  startAngle = Util.mod(startAngle, Math.PI * 2);
  endAngle = Util.mod(endAngle, Math.PI * 2) + plus;
  angle = Util.mod(angle, Math.PI * 2);

  if (clockwise) {
    if (startAngle >= endAngle) {
      if (angle > endAngle && angle < startAngle) {
        return angle;
      }

      return angleNearTo(angle, endAngle, startAngle, true);
    }

    if (angle < startAngle || angle > endAngle) {
      return angle;
    }

    return angleNearTo(angle, startAngle, endAngle);
  }

  if (startAngle <= endAngle) {
    if (startAngle < angle && angle < endAngle) {
      return angle;
    }

    return angleNearTo(angle, startAngle, endAngle, true);
  }

  if (angle > startAngle || angle < endAngle) {
    return angle;
  }

  return angleNearTo(angle, endAngle, startAngle);
}

function arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, out) {
  var v = [x, y];
  var v0 = [cx, cy];
  var v1 = [1, 0];
  var subv = Util.vec2.subtract([], v, v0);
  var angle = Util.vec2.angleTo(v1, subv);
  angle = nearAngle(angle, startAngle, endAngle, clockwise);
  var vpoint = [r * Math.cos(angle) + cx, r * Math.sin(angle) + cy];

  if (out) {
    out.x = vpoint[0];
    out.y = vpoint[1];
  }

  var d = Util.vec2.distance(vpoint, v);
  return d;
}

function arcBox(cx, cy, r, startAngle, endAngle, clockwise) {
  var angleRight = 0;
  var angleBottom = Math.PI / 2;
  var angleLeft = Math.PI;
  var angleTop = Math.PI * 3 / 2;
  var points = [];
  var angle = nearAngle(angleRight, startAngle, endAngle, clockwise);

  if (angle === angleRight) {
    points.push(circlePoint(cx, cy, r, angleRight));
  }

  angle = nearAngle(angleBottom, startAngle, endAngle, clockwise);

  if (angle === angleBottom) {
    points.push(circlePoint(cx, cy, r, angleBottom));
  }

  angle = nearAngle(angleLeft, startAngle, endAngle, clockwise);

  if (angle === angleLeft) {
    points.push(circlePoint(cx, cy, r, angleLeft));
  }

  angle = nearAngle(angleTop, startAngle, endAngle, clockwise);

  if (angle === angleTop) {
    points.push(circlePoint(cx, cy, r, angleTop));
  }

  points.push(circlePoint(cx, cy, r, startAngle));
  points.push(circlePoint(cx, cy, r, endAngle));
  var minX = Infinity;
  var maxX = -Infinity;
  var minY = Infinity;
  var maxY = -Infinity;
  Util.each(points, function (point) {
    if (minX > point.x) {
      minX = point.x;
    }

    if (maxX < point.x) {
      maxX = point.x;
    }

    if (minY > point.y) {
      minY = point.y;
    }

    if (maxY < point.y) {
      maxY = point.y;
    }
  });
  return {
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY
  };
}

module.exports = {
  nearAngle: nearAngle,
  projectPoint: function projectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y) {
    var rst = {};
    arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, rst);
    return rst;
  },
  pointDistance: arcProjectPoint,
  box: arcBox
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__(1).vec2;

module.exports = {
  at: function at(p1, p2, t) {
    return (p2 - p1) * t + p1;
  },
  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];

    if (vec2.exactEquals(d, [0, 0])) {
      return NaN;
    }

    var u = [-d[1], d[0]];
    vec2.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2.dot(a, u));
  },
  box: function box(x1, y1, x2, y2, lineWidth) {
    var halfWidth = lineWidth / 2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    return {
      minX: minX - halfWidth,
      minY: minY - halfWidth,
      maxX: maxX + halfWidth,
      maxY: maxY + halfWidth
    };
  },
  len: function len(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var Format = __webpack_require__(37);

var PathSegment = __webpack_require__(50);

var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;
var atan2 = Math.atan2;
var DEFAULT_LENGTH = 10;
var DEFAULT_ANGLE = PI / 3;

function _addArrow(ctx, attrs, x1, y1, x2, y2, isStart) {
  var leftX;
  var leftY;
  var rightX;
  var rightY;
  var offsetX;
  var offsetY;
  var angle;

  if (!attrs.fill) {
    // 闂悎鐨勪笉缁樺埗绠ご
    var arrowLength = attrs.arrowLength || DEFAULT_LENGTH;
    var arrowAngle = attrs.arrowAngle ? attrs.arrowAngle * PI / 180 : DEFAULT_ANGLE; // 杞崲涓哄姬
    // Calculate angle

    angle = atan2(y1 - y2, x1 - x2);
    /* // Adjust angle correctly
    angle -= PI;*/
    // Calculate offset to place arrow at edge of path

    offsetX = Math.abs(attrs.lineWidth * cos(angle)) / 2;
    offsetY = Math.abs(attrs.lineWidth * sin(angle)) / 2;

    if (isStart) {
      offsetX = -offsetX;
      offsetY = -offsetY;
    } // Calculate coordinates for left half of arrow


    leftX = x2 + arrowLength * cos(angle + arrowAngle / 2);
    leftY = y2 + arrowLength * sin(angle + arrowAngle / 2); // Calculate coordinates for right half of arrow

    rightX = x2 + arrowLength * cos(angle - arrowAngle / 2);
    rightY = y2 + arrowLength * sin(angle - arrowAngle / 2);
    ctx.beginPath(); // Draw left half of arrow

    ctx.moveTo(leftX - offsetX, leftY - offsetY);
    ctx.lineTo(x2 - offsetX, y2 - offsetY); // Draw right half of arrow

    ctx.lineTo(rightX - offsetX, rightY - offsetY); // Visually connect arrow to path

    ctx.moveTo(x2 - offsetX, y2 - offsetY);
    ctx.lineTo(x2 + offsetX, y2 + offsetY); // Move back to end of path

    ctx.moveTo(x2, y2);
    ctx.stroke();
  }
}

function parsePath(attrs) {
  var segments = [];
  var pathArray = Format.parsePath(attrs.path);
  var preSegment;

  if (!Array.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {
    return false;
  }

  var count = pathArray.length;

  for (var i = 0; i < pathArray.length; i++) {
    var item = pathArray[i];
    preSegment = new PathSegment(item, preSegment, i === count - 1);
    segments.push(preSegment);
  }

  return segments;
}

function _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, isStart) {
  var shape = isStart ? attrs.startArrow : attrs.endArrow;
  var d = shape.d;
  var deg = 0;
  var x = x2 - x1;
  var y = y2 - y1;
  var tan = Math.atan(x / y);

  if (y === 0 && x < 0) {
    deg = Math.PI;
  } else if (x > 0 && y > 0) {
    deg = Math.PI / 2 - tan;
  } else if (x < 0 && y < 0) {
    deg = -Math.PI / 2 - tan;
  } else if (x >= 0 && y < 0) {
    deg = -tan - Math.PI / 2;
  } else if (x <= 0 && y > 0) {
    deg = Math.PI / 2 - tan;
  }

  var path = parsePath(shape);

  if (!path) {
    return;
  }

  if (d) {
    if (isStart) {
      x2 = x2 + Math.sin(Math.abs(tan)) * d;
      y2 = y2 + Math.cos(Math.abs(tan)) * d - 0.5 * ctx.lineWidth;
    } else {
      x2 = x2 - Math.sin(Math.abs(tan)) * d;
      y2 = y2 - Math.cos(Math.abs(tan)) * d + 0.5 * ctx.lineWidth;
    }
  }

  ctx.save();
  ctx.beginPath();
  ctx.translate(x2, y2);
  ctx.rotate(deg);

  for (var i = 0; i < path.length; i++) {
    path[i].draw(ctx);
  }

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
}

module.exports = {
  addStartArrow: function addStartArrow(ctx, attrs, x1, y1, x2, y2) {
    if (typeof attrs.startArrow === 'object') {
      _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, true);
    } else if (attrs.startArrow) {
      _addArrow(ctx, attrs, x1, y1, x2, y2, true);
    }
  },
  addEndArrow: function addEndArrow(ctx, attrs, x1, y1, x2, y2) {
    if (typeof attrs.endArrow === 'object') {
      _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, false);
    } else if (attrs.endArrow) {
      _addArrow(ctx, attrs, x1, y1, x2, y2, false);
    }
  }
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Inside = __webpack_require__(76);

var Cubic = __webpack_require__(75);

var Quadratic = __webpack_require__(144);

var Ellipse = __webpack_require__(143);

var vec3 = Util.vec3;
var mat3 = Util.mat3;
var ARR_CMD = ['m', 'l', 'c', 'a', 'q', 'h', 'v', 't', 's', 'z'];

function toAbsolute(x, y, curPoint) {
  // 鑾峰彇缁濆鍧愭爣
  return {
    x: curPoint.x + x,
    y: curPoint.y + y
  };
}

function toSymmetry(point, center) {
  // 鐐瑰绉�
  return {
    x: center.x + (center.x - point.x),
    y: center.y + (center.y - point.y)
  };
}

function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}

function vRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}

function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}

function getArcParams(point1, point2, fa, fs, rx, ry, psiDeg) {
  var psi = Util.mod(Util.toRadian(psiDeg), Math.PI * 2);
  var x1 = point1.x;
  var y1 = point1.y;
  var x2 = point2.x;
  var y2 = point2.y;
  var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = Math.sqrt((rx * rx * (ry * ry) - diff) / diff);

  if (fa === fs) {
    f *= -1;
  }

  if (isNaN(f)) {
    f = 0;
  }

  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }

  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }

  return [point1, cx, cy, rx, ry, theta, dTheta, psi, fs];
}

var PathSegment = function PathSegment(item, preSegment, isLast) {
  this.preSegment = preSegment;
  this.isLast = isLast;
  this.init(item, preSegment);
};

Util.augment(PathSegment, {
  init: function init(item, preSegment) {
    var command = item[0];
    preSegment = preSegment || {
      endPoint: {
        x: 0,
        y: 0
      }
    };
    var relative = ARR_CMD.indexOf(command) >= 0; // /[a-z]/.test(command);

    var cmd = relative ? command.toUpperCase() : command;
    var p = item;
    var point1;
    var point2;
    var point3;
    var point;
    var preEndPoint = preSegment.endPoint;
    var p1 = p[1];
    var p2 = p[2];

    switch (cmd) {
      default:
        break;

      case 'M':
        if (relative) {
          point = toAbsolute(p1, p2, preEndPoint);
        } else {
          point = {
            x: p1,
            y: p2
          };
        }

        this.command = 'M';
        this.params = [preEndPoint, point];
        this.subStart = point;
        this.endPoint = point;
        break;

      case 'L':
        if (relative) {
          point = toAbsolute(p1, p2, preEndPoint);
        } else {
          point = {
            x: p1,
            y: p2
          };
        }

        this.command = 'L';
        this.params = [preEndPoint, point];
        this.subStart = preSegment.subStart;
        this.endPoint = point;

        this.endTangent = function () {
          return [point.x - preEndPoint.x, point.y - preEndPoint.y];
        };

        this.startTangent = function () {
          return [preEndPoint.x - point.x, preEndPoint.y - point.y];
        };

        break;

      case 'H':
        if (relative) {
          point = toAbsolute(p1, 0, preEndPoint);
        } else {
          point = {
            x: p1,
            y: preEndPoint.y
          };
        }

        this.command = 'L';
        this.params = [preEndPoint, point];
        this.subStart = preSegment.subStart;
        this.endPoint = point;

        this.endTangent = function () {
          return [point.x - preEndPoint.x, point.y - preEndPoint.y];
        };

        this.startTangent = function () {
          return [preEndPoint.x - point.x, preEndPoint.y - point.y];
        };

        break;

      case 'V':
        if (relative) {
          point = toAbsolute(0, p1, preEndPoint);
        } else {
          point = {
            x: preEndPoint.x,
            y: p1
          };
        }

        this.command = 'L';
        this.params = [preEndPoint, point];
        this.subStart = preSegment.subStart;
        this.endPoint = point;

        this.endTangent = function () {
          return [point.x - preEndPoint.x, point.y - preEndPoint.y];
        };

        this.startTangent = function () {
          return [preEndPoint.x - point.x, preEndPoint.y - point.y];
        };

        break;

      case 'Q':
        if (relative) {
          point1 = toAbsolute(p1, p2, preEndPoint);
          point2 = toAbsolute(p[3], p[4], preEndPoint);
        } else {
          point1 = {
            x: p1,
            y: p2
          };
          point2 = {
            x: p[3],
            y: p[4]
          };
        }

        this.command = 'Q';
        this.params = [preEndPoint, point1, point2];
        this.subStart = preSegment.subStart;
        this.endPoint = point2;

        this.endTangent = function () {
          return [point2.x - point1.x, point2.y - point1.y];
        };

        this.startTangent = function () {
          return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
        };

        break;

      case 'T':
        if (relative) {
          point2 = toAbsolute(p1, p2, preEndPoint);
        } else {
          point2 = {
            x: p1,
            y: p2
          };
        }

        if (preSegment.command === 'Q') {
          point1 = toSymmetry(preSegment.params[1], preEndPoint);
          this.command = 'Q';
          this.params = [preEndPoint, point1, point2];
          this.subStart = preSegment.subStart;
          this.endPoint = point2;

          this.endTangent = function () {
            return [point2.x - point1.x, point2.y - point1.y];
          };

          this.startTangent = function () {
            return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
          };
        } else {
          this.command = 'TL';
          this.params = [preEndPoint, point2];
          this.subStart = preSegment.subStart;
          this.endPoint = point2;

          this.endTangent = function () {
            return [point2.x - preEndPoint.x, point2.y - preEndPoint.y];
          };

          this.startTangent = function () {
            return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];
          };
        }

        break;

      case 'C':
        if (relative) {
          point1 = toAbsolute(p1, p2, preEndPoint);
          point2 = toAbsolute(p[3], p[4], preEndPoint);
          point3 = toAbsolute(p[5], p[6], preEndPoint);
        } else {
          point1 = {
            x: p1,
            y: p2
          };
          point2 = {
            x: p[3],
            y: p[4]
          };
          point3 = {
            x: p[5],
            y: p[6]
          };
        }

        this.command = 'C';
        this.params = [preEndPoint, point1, point2, point3];
        this.subStart = preSegment.subStart;
        this.endPoint = point3;

        this.endTangent = function () {
          return [point3.x - point2.x, point3.y - point2.y];
        };

        this.startTangent = function () {
          return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
        };

        break;

      case 'S':
        if (relative) {
          point2 = toAbsolute(p1, p2, preEndPoint);
          point3 = toAbsolute(p[3], p[4], preEndPoint);
        } else {
          point2 = {
            x: p1,
            y: p2
          };
          point3 = {
            x: p[3],
            y: p[4]
          };
        }

        if (preSegment.command === 'C') {
          point1 = toSymmetry(preSegment.params[2], preEndPoint);
          this.command = 'C';
          this.params = [preEndPoint, point1, point2, point3];
          this.subStart = preSegment.subStart;
          this.endPoint = point3;

          this.endTangent = function () {
            return [point3.x - point2.x, point3.y - point2.y];
          };

          this.startTangent = function () {
            return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];
          };
        } else {
          this.command = 'SQ';
          this.params = [preEndPoint, point2, point3];
          this.subStart = preSegment.subStart;
          this.endPoint = point3;

          this.endTangent = function () {
            return [point3.x - point2.x, point3.y - point2.y];
          };

          this.startTangent = function () {
            return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];
          };
        }

        break;

      case 'A':
        {
          var rx = p1;
          var ry = p2;
          var psi = p[3];
          var fa = p[4];
          var fs = p[5];

          if (relative) {
            point = toAbsolute(p[6], p[7], preEndPoint);
          } else {
            point = {
              x: p[6],
              y: p[7]
            };
          }

          this.command = 'A';
          var params = getArcParams(preEndPoint, point, fa, fs, rx, ry, psi);
          this.params = params;
          var start = preSegment.subStart;
          this.subStart = start;
          this.endPoint = point;
          var startAngle = params[5] % (Math.PI * 2);

          if (Util.isNumberEqual(startAngle, Math.PI * 2)) {
            startAngle = 0;
          }

          var endAngle = params[6] % (Math.PI * 2);

          if (Util.isNumberEqual(endAngle, Math.PI * 2)) {
            endAngle = 0;
          }

          var d = 0.001;

          this.startTangent = function () {
            if (fs === 0) {
              d *= -1;
            }

            var dx = params[3] * Math.cos(startAngle - d) + params[1];
            var dy = params[4] * Math.sin(startAngle - d) + params[2];
            return [dx - start.x, dy - start.y];
          };

          this.endTangent = function () {
            var endAngle = params[6];

            if (endAngle - Math.PI * 2 < 0.0001) {
              endAngle = 0;
            }

            var dx = params[3] * Math.cos(startAngle + endAngle + d) + params[1];
            var dy = params[4] * Math.sin(startAngle + endAngle - d) + params[2];
            return [preEndPoint.x - dx, preEndPoint.y - dy];
          };

          break;
        }

      case 'Z':
        {
          this.command = 'Z';
          this.params = [preEndPoint, preSegment.subStart];
          this.subStart = preSegment.subStart;
          this.endPoint = preSegment.subStart;
        }
    }
  },
  isInside: function isInside(x, y, lineWidth) {
    var self = this;
    var command = self.command;
    var params = self.params;
    var box = self.box;

    if (box) {
      if (!Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {
        return false;
      }
    }

    switch (command) {
      default:
        break;

      case 'M':
        return false;

      case 'TL':
      case 'L':
      case 'Z':
        return Inside.line(params[0].x, params[0].y, params[1].x, params[1].y, lineWidth, x, y);

      case 'SQ':
      case 'Q':
        return Inside.quadraticline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, lineWidth, x, y);

      case 'C':
        {
          return Inside.cubicline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, params[3].x, params[3].y, lineWidth, x, y);
        }

      case 'A':
        {
          var p = params;
          var cx = p[1];
          var cy = p[2];
          var rx = p[3];
          var ry = p[4];
          var theta = p[5];
          var dTheta = p[6];
          var psi = p[7];
          var fs = p[8];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          p = [x, y, 1];
          var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          mat3.translate(m, m, [-cx, -cy]);
          mat3.rotate(m, m, -psi);
          mat3.scale(m, m, [1 / scaleX, 1 / scaleY]);
          vec3.transformMat3(p, p, m);
          return Inside.arcline(0, 0, r, theta, theta + dTheta, 1 - fs, lineWidth, p[0], p[1]);
        }
    }

    return false;
  },
  draw: function draw(context) {
    var command = this.command;
    var params = this.params;
    var point1;
    var point2;
    var point3;

    switch (command) {
      default:
        break;

      case 'M':
        context.moveTo(params[1].x, params[1].y);
        break;

      case 'TL':
      case 'L':
        context.lineTo(params[1].x, params[1].y);
        break;

      case 'SQ':
      case 'Q':
        point1 = params[1];
        point2 = params[2];
        context.quadraticCurveTo(point1.x, point1.y, point2.x, point2.y);
        break;

      case 'C':
        point1 = params[1];
        point2 = params[2];
        point3 = params[3];
        context.bezierCurveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);
        break;

      case 'A':
        {
          var p = params;
          var p1 = p[1];
          var p2 = p[2];
          var cx = p1;
          var cy = p2;
          var rx = p[3];
          var ry = p[4];
          var theta = p[5];
          var dTheta = p[6];
          var psi = p[7];
          var fs = p[8];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(psi);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-psi);
          context.translate(-cx, -cy);
          break;
        }

      case 'Z':
        context.closePath();
        break;
    }
  },
  getBBox: function getBBox(lineWidth) {
    var halfWidth = lineWidth / 2;
    var params = this.params;
    var yDims;
    var xDims;
    var i;
    var l;

    switch (this.command) {
      default:
      case 'M':
      case 'Z':
        break;

      case 'TL':
      case 'L':
        this.box = {
          minX: Math.min(params[0].x, params[1].x) - halfWidth,
          maxX: Math.max(params[0].x, params[1].x) + halfWidth,
          minY: Math.min(params[0].y, params[1].y) - halfWidth,
          maxY: Math.max(params[0].y, params[1].y) + halfWidth
        };
        break;

      case 'SQ':
      case 'Q':
        xDims = Quadratic.extrema(params[0].x, params[1].x, params[2].x);

        for (i = 0, l = xDims.length; i < l; i++) {
          xDims[i] = Quadratic.at(params[0].x, params[1].x, params[2].x, xDims[i]);
        }

        xDims.push(params[0].x, params[2].x);
        yDims = Quadratic.extrema(params[0].y, params[1].y, params[2].y);

        for (i = 0, l = yDims.length; i < l; i++) {
          yDims[i] = Quadratic.at(params[0].y, params[1].y, params[2].y, yDims);
        }

        yDims.push(params[0].y, params[2].y);
        this.box = {
          minX: Math.min.apply(Math, xDims) - halfWidth,
          maxX: Math.max.apply(Math, xDims) + halfWidth,
          minY: Math.min.apply(Math, yDims) - halfWidth,
          maxY: Math.max.apply(Math, yDims) + halfWidth
        };
        break;

      case 'C':
        xDims = Cubic.extrema(params[0].x, params[1].x, params[2].x, params[3].x);

        for (i = 0, l = xDims.length; i < l; i++) {
          xDims[i] = Cubic.at(params[0].x, params[1].x, params[2].x, params[3].x, xDims[i]);
        }

        yDims = Cubic.extrema(params[0].y, params[1].y, params[2].y, params[3].y);

        for (i = 0, l = yDims.length; i < l; i++) {
          yDims[i] = Cubic.at(params[0].y, params[1].y, params[2].y, params[3].y, yDims[i]);
        }

        xDims.push(params[0].x, params[3].x);
        yDims.push(params[0].y, params[3].y);
        this.box = {
          minX: Math.min.apply(Math, xDims) - halfWidth,
          maxX: Math.max.apply(Math, xDims) + halfWidth,
          minY: Math.min.apply(Math, yDims) - halfWidth,
          maxY: Math.max.apply(Math, yDims) + halfWidth
        };
        break;

      case 'A':
        {
          // todo 寰呬紭鍖�
          var p = params;
          var cx = p[1];
          var cy = p[2];
          var rx = p[3];
          var ry = p[4];
          var theta = p[5];
          var dTheta = p[6];
          var psi = p[7];
          var fs = p[8];
          var start = theta;
          var end = theta + dTheta;
          var xDim = Ellipse.xExtrema(psi, rx, ry);
          var minX = Infinity;
          var maxX = -Infinity;
          var xs = [start, end];

          for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
            var xAngle = xDim + i;

            if (fs === 1) {
              if (start < xAngle && xAngle < end) {
                xs.push(xAngle);
              }
            } else {
              if (end < xAngle && xAngle < start) {
                xs.push(xAngle);
              }
            }
          }

          for (i = 0, l = xs.length; i < l; i++) {
            var x = Ellipse.xAt(psi, rx, ry, cx, xs[i]);

            if (x < minX) {
              minX = x;
            }

            if (x > maxX) {
              maxX = x;
            }
          }

          var yDim = Ellipse.yExtrema(psi, rx, ry);
          var minY = Infinity;
          var maxY = -Infinity;
          var ys = [start, end];

          for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
            var yAngle = yDim + i;

            if (fs === 1) {
              if (start < yAngle && yAngle < end) {
                ys.push(yAngle);
              }
            } else {
              if (end < yAngle && yAngle < start) {
                ys.push(yAngle);
              }
            }
          }

          for (i = 0, l = ys.length; i < l; i++) {
            var y = Ellipse.yAt(psi, rx, ry, cy, ys[i]);

            if (y < minY) {
              minY = y;
            }

            if (y > maxY) {
              maxY = y;
            }
          }

          this.box = {
            minX: minX - halfWidth,
            maxX: maxX + halfWidth,
            minY: minY - halfWidth,
            maxY: maxY + halfWidth
          };
          break;
        }
    }
  }
});
module.exports = PathSegment;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */
var isNil = __webpack_require__(6);

var each = __webpack_require__(2);

var Base = __webpack_require__(26);

var numberAuto = __webpack_require__(351);
/**
 * 绾挎€у害閲�
 * @class Scale.Linear
 */


var Linear =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Linear, _Base);

  function Linear() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Linear.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Base.prototype._initDefaultCfg.call(this);

    var self = this;
    self.type = 'linear';
    self.isLinear = true;
    /**
     * 鏄惁涓轰簡鐢ㄦ埛涔犳儻锛屼紭鍖杕in,max鍜宼icks锛屽鏋滆繘琛屼紭鍖栵紝鍒欎細鏍规嵁鐢熸垚鐨則icks璋冩暣min,max锛屽惁鍒欒垗寮�(min,max)鑼冨洿涔嬪鐨則icks
     * @type {Boolean}
     * @default false
     */

    self.nice = false;
    /**
     * min value of the scale
     * @type {Number}
     * @default null
     */

    self.min = null;
    /**
     * min value limitted of the scale
     * @type {Number}
     * @default null
     */

    self.minLimit = null;
    /**
     * max value of the scale
     * @type {Number}
     * @default null
     */

    self.max = null;
    /**
     * max value limitted of the scale
     * @type {Number}
     * @default null
     */

    self.maxLimit = null;
    /**
     * 鑷姩鐢熸垚鏍囪鏃剁殑涓暟
     * @type {Number}
     * @default null
     */

    self.tickCount = null;
    /**
     * 鍧愭爣杞寸偣涔嬮棿鐨勯棿璺濓紝鎸囩殑鏄湡瀹炴暟鎹殑宸€�
     * @type {Number}
     * @default null
     */

    self.tickInterval = null;
    /**
     * 鍧愭爣杞寸偣涔嬮棿鐨勬渶灏忛棿璺濓紝鎸囩殑鏄湡瀹炴暟鎹殑宸€�
     * @type {Number}
     * @default null
     */

    self.minTickInterval = null;
    /**
     * 鐢ㄤ簬璁＄畻鍧愭爣鐐规椂閫艰繎鐨勬暟缁�
     * @type {Array}
     */

    self.snapArray = null;
  }
  /**
   * @protected
   * @override
   */
  ;

  _proto.init = function init() {
    var self = this;

    if (!self.ticks) {
      self.min = self.translate(self.min);
      self.max = self.translate(self.max);
      self.initTicks();
    } else {
      var ticks = self.ticks;
      var firstValue = self.translate(ticks[0]);
      var lastValue = self.translate(ticks[ticks.length - 1]);

      if (isNil(self.min) || self.min > firstValue) {
        self.min = firstValue;
      }

      if (isNil(self.max) || self.max < lastValue) {
        self.max = lastValue;
      }
    }
  }
  /**
   * 璁＄畻鍧愭爣鐐�
   * @protected
   * @return {Array} 璁＄畻瀹屾垚鐨勫潗鏍囩偣
   */
  ;

  _proto.calculateTicks = function calculateTicks() {
    var min = this.min,
        max = this.max,
        minLimit = this.minLimit,
        maxLimit = this.maxLimit,
        tickCount = this.tickCount,
        tickInterval = this.tickInterval,
        minTickInterval = this.minTickInterval,
        snapArray = this.snapArray;

    if (tickCount === 1) {
      throw new Error('linear scale\'tickCount should not be 1');
    }

    if (max < min) {
      throw new Error("max: " + max + " should not be less than min: " + min);
    }

    var tmp = numberAuto({
      min: min,
      max: max,
      minLimit: minLimit,
      maxLimit: maxLimit,
      minCount: tickCount,
      maxCount: tickCount,
      interval: tickInterval,
      minTickInterval: minTickInterval,
      snapArray: snapArray
    });
    return tmp.ticks;
  } // 鍒濆鍖杢icks
  ;

  _proto.initTicks = function initTicks() {
    var self = this;
    var calTicks = self.calculateTicks();

    if (self.nice) {
      // 濡傛灉闇€瑕佷紭鍖栨樉绀虹殑tick
      self.ticks = calTicks;
      self.min = calTicks[0];
      self.max = calTicks[calTicks.length - 1];
    } else {
      var ticks = [];
      each(calTicks, function (tick) {
        if (tick >= self.min && tick <= self.max) {
          ticks.push(tick);
        }
      }); // 濡傛灉 ticks 涓虹┖锛岀洿鎺ヨ緭鍏ユ渶灏忓€笺€佹渶澶у€�

      if (!ticks.length) {
        ticks.push(self.min);
        ticks.push(self.max);
      }

      self.ticks = ticks;
    }
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    if (isNil(value)) {
      return NaN;
    }

    var max = this.max;
    var min = this.min;

    if (max === min) {
      return 0;
    }

    var percent = (value - min) / (max - min);
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  }
  /**
   * @override
   */
  ;

  _proto.invert = function invert(value) {
    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    return this.min + percent * (this.max - this.min);
  };

  return Linear;
}(Base);

Base.Linear = Linear;
module.exports = Linear;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 鎻愬彇鍏叡浠ｇ爜鍒皍til鏂规硶
 * @author dxq613@gmail.com
 */
var isString = __webpack_require__(15);

var isDate = __webpack_require__(192);

module.exports = {
  toTimeStamp: function toTimeStamp(value) {
    if (isString(value)) {
      if (value.indexOf('T') > 0) {
        value = new Date(value).getTime();
      } else {
        value = new Date(value.replace(/-/ig, '/')).getTime();
      }
    }

    if (isDate(value)) {
      value = value.getTime();
    }

    return value;
  }
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);

var indexOf = Array.prototype.indexOf;

var contains = function contains(arr, value) {
  if (!isArrayLike(arr)) {
    return false;
  }
  return indexOf.call(arr, value) > -1;
};

module.exports = contains;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var merge = function merge(dataArray) {
  var rst = [];
  for (var i = 0; i < dataArray.length; i++) {
    rst = rst.concat(dataArray[i]);
  }
  return rst;
};

module.exports = merge;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

var PRECISION = 0.00001; // numbers less than this is considered as 0

module.exports = function isNumberEqual(a, b) {
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;

  return Math.abs(a - b) < precision;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  mat3: __webpack_require__(85),
  vec2: __webpack_require__(174),
  vec3: __webpack_require__(175),
  transform: __webpack_require__(173)
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);

function toArray(value) {
  return isArrayLike(value) ? Array.prototype.slice.call(value) : [];
}

module.exports = toArray;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * util function
                                                                                                                                                                                                                                                                               */

var _core = __webpack_require__(45);

/* eslint-disable no-self-compare */

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  }
  return x !== x && y !== y; //  NaN == NaN
}

function length(obj) {
  if (_core.Util.isArray(obj)) {
    return obj.length;
  } else if (_core.Util.isObject(obj)) {
    return Object.keys(obj).length;
  }

  return 0;
}

exports.default = _core.Util.mix({}, _core.Util, {
  shallowEqual: function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
      return false;
    }

    if (_core.Util.isArray(objA) !== _core.Util.isArray(objB)) {
      return false;
    }

    if (length(objA) !== length(objB)) {
      return false;
    }

    var ret = true;

    _core.Util.each(objA, function (v, k) {
      if (!is(v, objB[k])) {
        ret = false;
        return ret;
      }
      return true;
    });

    return ret;
  },
  without: function without(objA) {
    var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var ret = {};
    _core.Util.each(objA, function (v, k) {
      if (_core.Util.indexOf(keys, k) === -1) {
        ret[k] = v;
      }
    });
    return ret;
  },


  length: length
});

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
});


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__namespaces__ = __webpack_require__(98);



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */] && document.documentElement.namespaceURI === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var fullname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tweenValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we鈥檙e done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we鈥檙e done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(node, id).value[name];
  };
}


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTheme = exports.track = exports.Interactions = exports.PathUtil = exports.Animate = exports.Shape = exports.Util = exports.G2 = exports.Facet = exports.Label = exports.Guide = exports.View = exports.Geom = exports.Tooltip = exports.Legend = exports.Axis = exports.Coord = exports.Chart = undefined;

var _Chart = __webpack_require__(422);

Object.defineProperty(exports, 'Chart', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Chart).default;
  }
});

var _Coord = __webpack_require__(424);

Object.defineProperty(exports, 'Coord', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Coord).default;
  }
});

var _Axis = __webpack_require__(420);

Object.defineProperty(exports, 'Axis', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Axis).default;
  }
});

var _Legend = __webpack_require__(430);

Object.defineProperty(exports, 'Legend', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Legend).default;
  }
});

var _Tooltip = __webpack_require__(431);

Object.defineProperty(exports, 'Tooltip', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Tooltip).default;
  }
});

var _Geom = __webpack_require__(427);

Object.defineProperty(exports, 'Geom', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Geom).default;
  }
});

var _View = __webpack_require__(432);

Object.defineProperty(exports, 'View', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_View).default;
  }
});

var _Guide = __webpack_require__(428);

Object.defineProperty(exports, 'Guide', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Guide).default;
  }
});

var _Label = __webpack_require__(429);

Object.defineProperty(exports, 'Label', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Label).default;
  }
});

var _Facet = __webpack_require__(426);

Object.defineProperty(exports, 'Facet', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Facet).default;
  }
});

var _core = __webpack_require__(45);

var _core2 = _interopRequireDefault(_core);

var _interaction = __webpack_require__(322);

var _interaction2 = _interopRequireDefault(_interaction);

var _util = __webpack_require__(58);

var _util2 = _interopRequireDefault(_util);

var _themes = __webpack_require__(438);

var _themes2 = _interopRequireDefault(_themes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.G2 = _core2.default;
exports.Util = _util2.default;
exports.Shape = _core.Shape;
exports.Animate = _core.Animate;
exports.PathUtil = _core.PathUtil;
exports.Interactions = _interaction2.default;
var track = exports.track = function track() {};
var setTheme = exports.setTheme = function setTheme(theme) {
  var themeObj = theme;
  if (typeof theme === 'string' && _themes2.default[theme]) {
    themeObj = _themes2.default[theme];
  }
  _core2.default.Global.setTheme(themeObj);
};

var BizCharts = {
  G2: _core2.default,
  Util: _util2.default,
  Shape: _core.Shape,
  Animate: _core.Animate,
  PathUtil: _core.PathUtil,
  track: track,
  setTheme: setTheme,
  Interactions: _interaction2.default
};

exports.default = BizCharts;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  Position: __webpack_require__(235),
  Color: __webpack_require__(233),
  Shape: __webpack_require__(236),
  Size: __webpack_require__(237),
  Opacity: __webpack_require__(234),
  ColorUtil: __webpack_require__(107)
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview Chart銆乂iew銆丟eometry 鐨勫熀绫�
 * @author dxq613@gmail.com
 */
var EventEmitter = __webpack_require__(105);

var Util = __webpack_require__(3);

var Base =
/*#__PURE__*/
function (_EventEmitter) {
  _inheritsLoose(Base, _EventEmitter);

  var _proto = Base.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {};
  };

  function Base(cfg) {
    var _this;

    _this = _EventEmitter.call(this) || this;

    var self = _assertThisInitialized(_this);

    var attrs = {
      visible: true
    };
    var defaultCfg = self.getDefaultCfg();
    self._attrs = attrs;
    Util.deepMix(attrs, defaultCfg, cfg);
    return _this;
  }

  _proto.get = function get(name) {
    return this._attrs[name];
  };

  _proto.set = function set(name, value) {
    this._attrs[name] = value;
  }
  /**
   * @protected
   * @param {Boolean} visible 鏄惁鍙
   * 鏄剧ず銆侀殣钘�
   */
  ;

  _proto.changeVisible = function changeVisible()
  /* visible */
  {};

  _proto.destroy = function destroy() {
    var self = this;
    self._attrs = {};
    self.removeAllListeners();
    self.destroyed = true;
  };

  return Base;
}(EventEmitter);

module.exports = Base;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The base class of continuous legend
 * @author sima.zhang
 */
var Util = __webpack_require__(3);

var Legend = __webpack_require__(112);

var Slider = __webpack_require__(261);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var TRIGGER_WIDTH = 8;
var Event = Util.Event;
var Group = Util.Group;

var Continuous =
/*#__PURE__*/
function (_Legend) {
  _inheritsLoose(Continuous, _Legend);

  function Continuous() {
    return _Legend.apply(this, arguments) || this;
  }

  var _proto = Continuous.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Legend.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'continuous-legend',

      /**
       * 瀛愰」
       * @type {Array}
       */
      items: null,

      /**
       * 甯冨眬鏂瑰紡
       * horizontal 姘村钩
       * vertical 鍨傜洿
       * @type {String}
       */
      layout: 'vertical',

      /**
       * 瀹藉害
       * @type {Number}
       */
      width: 20,

      /**
       * 楂樺害
       * @type {Number}
       */
      height: 156,

      /**
       * 榛樿鏂囨湰鍥惧舰灞炴€�
       * @type {ATTRS}
       */
      textStyle: {
        fill: '#333',
        textAlign: 'center',
        textBaseline: 'middle',
        stroke: '#fff',
        lineWidth: 5,
        fontFamily: FONT_FAMILY
      },
      hoverTextStyle: {
        fill: 'rgba(0,0,0,0.25)'
      },

      /**
       * 杩炵画鍥句緥鏄惁鍙粦鍔�
       * @type {Boolean}
       */
      slidable: true,

      /**
       * 涓ゅご婊戝潡鐨勬牱寮�
       * @type {object}
       */
      triggerAttr: {
        fill: '#fff',
        // shadowOffsetX: -2,
        // shadowOffsetY: 2,
        shadowBlur: 10,
        shadowColor: 'rgba(0,0,0,0.65)',
        radius: 2
      },

      /**
       * slider 鐨勮寖鍥�
       * @type {array}}
       */
      _range: [0, 100],

      /**
       * 涓棿 bar 鑳屾櫙鐏拌壊
       * @type {ATTRS}
       */
      middleBackgroundStyle: {
        fill: '#D9D9D9'
      },

      /**
       * 鏂囨湰涓庡浘渚嬮棿璺�
       * @type {Number}
       */
      textOffset: 4,

      /**
       * line segment to seperate the unslidable slider blocks
       * @type {object}
       */
      lineStyle: {
        lineWidth: 1,
        stroke: '#fff'
      },

      /**
       * the pointer while activate the legend by mouse hovering or called by outside
       * @type {object}
       */
      pointerStyle: {
        // color: '#ccc',
        fill: 'rgb(230, 230, 230)'
      }
    });
  };

  _proto._calStartPoint = function _calStartPoint() {
    var start = {
      x: 10,
      y: this.get('titleGap') - TRIGGER_WIDTH
    };
    var titleShape = this.get('titleShape');

    if (titleShape) {
      var titleBox = titleShape.getBBox();
      start.y += titleBox.height;
    }

    return start;
  };

  _proto.beforeRender = function beforeRender() {
    var items = this.get('items');

    if (!Util.isArray(items) || Util.isEmpty(items)) {
      return;
    }

    _Legend.prototype.beforeRender.call(this);

    this.set('firstItem', items[0]);
    this.set('lastItem', items[items.length - 1]);
  };

  _proto._formatItemValue = function _formatItemValue(value) {
    var formatter = this.get('formatter') || this.get('itemFormatter');

    if (formatter) {
      value = formatter.call(this, value);
    }

    return value;
  };

  _proto.render = function render() {
    _Legend.prototype.render.call(this);

    if (this.get('slidable')) {
      this._renderSlider();
    } else {
      this._renderUnslidable();
    }
  };

  _proto._renderSlider = function _renderSlider() {
    var minHandleElement = new Group();
    var maxHandleElement = new Group();
    var backgroundElement = new Group();

    var start = this._calStartPoint();

    var group = this.get('group');
    var slider = group.addGroup(Slider, {
      minHandleElement: minHandleElement,
      maxHandleElement: maxHandleElement,
      backgroundElement: backgroundElement,
      layout: this.get('layout'),
      range: this.get('_range'),
      width: this.get('width'),
      height: this.get('height')
    });
    slider.translate(start.x, start.y);
    this.set('slider', slider);

    var shape = this._renderSliderShape();

    shape.attr('clip', slider.get('middleHandleElement'));

    this._renderTrigger();
  } // the middle bar
  ;

  _proto._addMiddleBar = function _addMiddleBar(parent, name, attrs) {
    // background of the middle bar
    parent.addShape(name, {
      attrs: Util.mix({}, attrs, this.get('middleBackgroundStyle'))
    }); // frontground of the middle bar

    return parent.addShape(name, {
      attrs: attrs
    });
  };

  _proto._renderTrigger = function _renderTrigger() {
    var min = this.get('firstItem');
    var max = this.get('lastItem');
    var layout = this.get('layout');
    var textStyle = this.get('textStyle');
    var triggerAttr = this.get('triggerAttr');
    var minBlockAttr = Util.mix({}, triggerAttr);
    var maxBlockAttr = Util.mix({}, triggerAttr);
    var minTextAttr = Util.mix({
      text: this._formatItemValue(min.value) + ''
    }, textStyle);
    var maxTextAttr = Util.mix({
      text: this._formatItemValue(max.value) + ''
    }, textStyle);

    if (layout === 'vertical') {
      this._addVerticalTrigger('min', minBlockAttr, minTextAttr);

      this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr);
    } else {
      this._addHorizontalTrigger('min', minBlockAttr, minTextAttr);

      this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr);
    }
  };

  _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr) {
    var slider = this.get('slider');
    var trigger = slider.get(type + 'HandleElement');
    var width = this.get('width');
    var button = trigger.addShape('rect', {
      attrs: Util.mix({
        x: width / 2 - TRIGGER_WIDTH - 2,
        y: type === 'min' ? 0 : -TRIGGER_WIDTH,
        width: 2 * TRIGGER_WIDTH + 2,
        height: TRIGGER_WIDTH
      }, blockAttr)
    });
    var text = trigger.addShape('text', {
      attrs: Util.mix(textAttr, {
        x: width + this.get('textOffset'),
        y: type === 'max' ? -4 : 4,
        textAlign: 'start',
        lineHeight: 1,
        textBaseline: 'middle'
      })
    });
    var layout = this.get('layout');
    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
    button.attr('cursor', trigerCursor);
    text.attr('cursor', trigerCursor);
    this.set(type + 'ButtonElement', button);
    this.set(type + 'TextElement', text);
  };

  _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr) {
    var slider = this.get('slider');
    var trigger = slider.get(type + 'HandleElement');
    var button = trigger.addShape('rect', {
      attrs: Util.mix({
        x: type === 'min' ? -TRIGGER_WIDTH : 0,
        y: -TRIGGER_WIDTH - this.get('height') / 2,
        width: TRIGGER_WIDTH,
        height: 2 * TRIGGER_WIDTH
      }, blockAttr)
    });
    var text = trigger.addShape('text', {
      attrs: Util.mix(textAttr, {
        x: type === 'min' ? -TRIGGER_WIDTH - 4 : TRIGGER_WIDTH + 4,
        y: TRIGGER_WIDTH / 2 + this.get('textOffset') + 10,
        textAlign: type === 'min' ? 'end' : 'start',
        textBaseline: 'middle'
      })
    });
    var layout = this.get('layout');
    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
    button.attr('cursor', trigerCursor);
    text.attr('cursor', trigerCursor);
    this.set(type + 'ButtonElement', button);
    this.set(type + 'TextElement', text);
  };

  _proto._bindEvents = function _bindEvents() {
    var _this = this;

    if (this.get('slidable')) {
      var slider = this.get('slider');
      slider.on('sliderchange', function (ev) {
        var range = ev.range;

        var firstItemValue = _this.get('firstItem').value;

        var lastItemValue = _this.get('lastItem').value;

        var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);
        var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);

        _this._updateElement(minValue, maxValue);

        var itemFiltered = new Event('itemfilter', ev, true, true);
        itemFiltered.range = [minValue, maxValue];

        _this.emit('itemfilter', itemFiltered);
      });
    }

    if (this.get('hoverable')) {
      this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMouseMove'));
      this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseLeave'));
    }
  } // update the text of min and max trigger
  ;

  _proto._updateElement = function _updateElement(min, max) {
    var minTextElement = this.get('minTextElement');
    var maxTextElement = this.get('maxTextElement');

    if (max > 1) {
      // 瀵逛簬澶т簬 1 鐨勫€硷紝榛樿鏄剧ず涓烘暣鏁�
      min = parseInt(min, 10);
      max = parseInt(max, 10);
    }

    minTextElement.attr('text', this._formatItemValue(min) + '');
    maxTextElement.attr('text', this._formatItemValue(max) + '');
  };

  _proto._onMouseLeave = function _onMouseLeave() {
    var hoverPointer = this.get('group').findById('hoverPointer');
    hoverPointer && hoverPointer.destroy();
    var hoverText = this.get('group').findById('hoverText');
    hoverText && hoverText.destroy();
    this.get('canvas').draw();
  } // activate the legend while mouse moving
  ;

  _proto._onMouseMove = function _onMouseMove(ev) {
    var height = this.get('height');
    var width = this.get('width');
    var items = this.get('items');
    var el = this.get('canvas').get('el');
    var el_bbox = el.getBoundingClientRect();
    var bbox = this.get('group').getBBox();
    var value;

    if (this.get('layout') === 'vertical') {
      var valuePadding = 5;

      if (this.get('type') === 'color-legend') {
        valuePadding = 30;
      }

      var titleOffset = this.get('titleGap');
      var titleShape = this.get('titleShape');
      if (titleShape) titleOffset += titleShape.getBBox().maxY - titleShape.getBBox().minY;
      var currentPage = ev.clientY || ev.event.clientY;
      currentPage = currentPage - el_bbox.y - this.get('group').attr('matrix')[7] + bbox.y - valuePadding + titleOffset;
      value = items[0].value + (1 - currentPage / height) * (items[items.length - 1].value - items[0].value);
    } else {
      var _currentPage = ev.clientX || ev.event.clientX;

      _currentPage = _currentPage - el_bbox.x - this.get('group').attr('matrix')[6];
      value = items[0].value + _currentPage / width * (items[items.length - 1].value - items[0].value);
    }

    value = value.toFixed(2);
    this.activate(value);
    this.emit('mousehover', {
      value: value
    });
  } // activated by mouse moving or being called
  ;

  _proto.activate = function activate(value) {
    if (!value) {
      return;
    }

    var hoverPointer = this.get('group').findById('hoverPointer');
    var hoverText = this.get('group').findById('hoverText');
    var items = this.get('items');

    if (value < items[0].value || value > items[items.length - 1].value) {
      return;
    }

    var height = this.get('height');
    var width = this.get('width');
    var titleShape = this.get('titleShape');
    var titleGap = this.get('titleGap');
    var points = [];
    var page = (value - items[0].value) / (items[items.length - 1].value - items[0].value);
    var textStyle;

    if (this.get('layout') === 'vertical') {
      // revise the offset
      var paddingY = 0,
          paddingX = 0;

      if (this.get('type') === 'color-legend') {
        paddingY = titleGap;
        if (titleShape) paddingY += titleShape.getBBox().height;
      }

      if (this.get('slidable')) {
        if (this.get('type') === 'color-legend') {
          paddingY -= 13;
        } else {
          paddingY = titleGap - 15;
          if (titleShape) paddingY += titleShape.getBBox().height;
        }

        paddingX += 10;
      }

      page = (1 - page) * height;
      points = [[paddingX, page + paddingY], [paddingX - 10, page + paddingY - 5], [paddingX - 10, page + paddingY + 5]];
      textStyle = Util.mix({}, {
        x: width + this.get('textOffset') / 2 + paddingX,
        y: page + paddingY,
        text: this._formatItemValue(value) + '' // 浠ュ瓧绗︿覆鏍煎紡灞曠ず

      }, this.get('textStyle'), {
        textAlign: 'start'
      });
    } else {
      var _paddingY = 0,
          _paddingX = 0;

      if (this.get('type') === 'color-legend') {
        _paddingY = titleGap;
        if (titleShape) _paddingY += titleShape.getBBox().height;
      }

      if (this.get('slidable')) {
        if (this.get('type') === 'color-legend') {
          // hoverPointer涓夎褰㈢殑楂�
          _paddingY -= 7;
        } else {
          _paddingY = titleGap;
          if (!titleShape) _paddingY -= 7;
        }

        _paddingX += 10;
      }

      page *= width;
      points = [[page + _paddingX, _paddingY], [page + _paddingX - 5, _paddingY - 10], [page + _paddingX + 5, _paddingY - 10]];
      textStyle = Util.mix({}, {
        x: page - 5,
        y: height + this.get('textOffset') + _paddingY,
        text: this._formatItemValue(value) + '' // 浠ュ瓧绗︿覆鏍煎紡灞曠ず

      }, this.get('textStyle'));
    }

    var hoverTextStyle = Util.mix(textStyle, this.get('hoverTextStyle'));

    if (!hoverText) {
      // mouse enter the legend, add hoverText
      hoverText = this.get('group').addShape('text', {
        attrs: hoverTextStyle
      });
      hoverText.set('id', 'hoverText');
    } else {
      // mouse move, update hoverText
      hoverText.attr(hoverTextStyle);
    }

    if (!hoverPointer) {
      // mouse enter the legend, add hoverPointer
      hoverPointer = this.get('group').addShape('Polygon', {
        attrs: Util.mix({
          points: points
        }, this.get('pointerStyle'))
      });
      hoverPointer.set('id', 'hoverPointer');
    } else {
      // mouse move, update hoverPointer
      hoverPointer.attr(Util.mix({
        points: points
      }, this.get('pointerStyle')));
    }

    this.get('canvas').draw();
  };

  _proto.deactivate = function deactivate() {
    var hoverPointer = this.get('group').findById('hoverPointer');
    hoverPointer && hoverPointer.destroy();
    var hoverText = this.get('group').findById('hoverText');
    hoverText && hoverText.destroy();
    this.get('canvas').draw();
  };

  return Continuous;
}(Legend);

module.exports = Continuous;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Component = __webpack_require__(66);

var Util = __webpack_require__(3);

var Tooltip =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Tooltip, _Component);

  function Tooltip() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Tooltip.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Component.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * tooltip container
       * @type {Dom / String}
       */

      /**
       * 鍙充笅瑙掑潗鏍�
       * @type {Number}
       */
      x: 0,

      /**
       * y 鍙充笅瑙掑潗鏍�
       * @type {Number}
       */
      y: 0,

      /**
       * tooltip 璁板綍椤�
       * @type {Array}
       */
      items: null,

      /**
       * tooltip 鏍囬
       * @type {Array}
       */
      titleContent: null,

      /**
       * 鏄惁灞曠ず title
       * @type {Boolean}
       */
      showTitle: true,

      /**
       * 瑙嗗浘鑼冨洿
       * @type {Object}
       */
      plotRange: null,

      /**
       * x杞翠笂锛岀Щ鍔ㄥ埌浣嶇疆鐨勫亸绉婚噺
       * @type {Number}
       */
      offset: 10,
      // TODO:鏀寔xy涓や釜鏂瑰悜涓婄殑offset

      /**
       * 鏃堕棿鎴�
       * @type {Number}
       */
      timeStamp: 0,

      /**
       * 灏� tooltip 灞曠ず鍦ㄦ寚瀹氬尯鍩熷唴
       * @type {Boolean}
       */
      inPlot: true,

      /**
       * tooltip 杈呭姪绾块厤缃�
       * @type {Object}
       */
      crosshairs: null
    });
  };

  _proto.isContentChange = function isContentChange(title, items) {
    var titleContent = this.get('titleContent');
    var lastItems = this.get('items');
    var isChanged = !(title === titleContent && lastItems.length === items.length);

    if (!isChanged) {
      Util.each(items, function (item, index) {
        var preItem = lastItems[index];

        for (var key in item) {
          if (item.hasOwnProperty(key)) {
            if (!Util.isObject(item[key]) && item[key] !== preItem[key]) {
              isChanged = true;
              break;
            }
          }
        }

        if (isChanged) {
          return false;
        }
      });
    }

    return isChanged;
  };

  _proto.setContent = function setContent(title, items) {
    var timeStamp = new Date().valueOf();
    this.set('items', items);
    this.set('titleContent', title);
    this.set('timeStamp', timeStamp);
    this.render();
    return this;
  };

  _proto.setPosition = function setPosition(x, y) {
    this.set('x', x);
    this.set('y', y);
  };

  _proto.render = function render() {};

  _proto.clear = function clear() {};

  _proto.show = function show() {
    this.set('visible', true);
  };

  _proto.hide = function hide() {
    this.set('visible', false);
  };

  return Tooltip;
}(Component);

module.exports = Tooltip;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(16),
    Group = _require.Group;

var _require2 = __webpack_require__(30),
    Label = _require2.Label; // const visualCenter = require('@antv/component/lib/label/utils/visual-center');


var Global = __webpack_require__(5);

var Util = __webpack_require__(0);

var IGNORE_ARR = ['line', 'point', 'path'];
var ORIGIN = '_origin';

function avg(arr) {
  var sum = 0;
  Util.each(arr, function (value) {
    sum += value;
  });
  return sum / arr.length;
} // 璁＄畻澶氳竟褰㈤噸蹇�: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon


function getCentroid(xs, ys) {
  if (Util.isNumber(xs) && Util.isNumber(ys)) {
    return [xs, ys];
  }

  var i = -1,
      x = 0,
      y = 0;
  var former,
      current = xs.length - 1;
  var diff,
      k = 0;

  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff;
    y += (ys[former] + ys[current]) * diff;
  }

  k *= 3;
  return [x / k, y / k];
}

var GeomLabels = function GeomLabels(cfg) {
  GeomLabels.superclass.constructor.call(this, cfg);
};

Util.extend(GeomLabels, Group);
Util.augment(GeomLabels, {
  getDefaultCfg: function getDefaultCfg() {
    return {
      label: Global.label,

      /**
       * 鐢ㄦ埛浼犲叆鐨勬枃鏈厤缃俊鎭�
       * @type {Object}
       */
      labelCfg: null,

      /**
       * 鎵€鍦ㄧ殑鍧愭爣绯�
       * @type {Object}
       */
      coord: null,

      /**
       * 鍥捐〃鐨勭被鍨�
       * @type {String}
       */
      geomType: null,
      zIndex: 6
    };
  },
  _renderUI: function _renderUI() {
    GeomLabels.superclass._renderUI.call(this);

    this.initLabelsCfg();
    var labelsGroup = this.addGroup();
    var lineGroup = this.addGroup({
      elCls: 'x-line-group'
    });
    var labelRenderer = this.get('labelRenderer');
    this.set('labelsGroup', labelsGroup);
    this.set('lineGroup', lineGroup);
    this.get('labelRenderer').set('group', labelsGroup);
    labelRenderer.set('group', labelsGroup);
    labelRenderer.set('lineGroup', lineGroup);
  },
  // 鍒濆鍖杔abels鐨勯厤缃」
  initLabelsCfg: function initLabelsCfg() {
    var self = this;
    var labelRenderer = new Label();
    var labels = self.getDefaultLabelCfg();
    var labelCfg = self.get('labelCfg'); // Util.merge(labels, labelCfg.cfg);

    Util.deepMix(labels, labelCfg.globalCfg || labelCfg.cfg);
    labelRenderer.set('config', false);

    if (labels.labelLine) {
      labelRenderer.set('labelLine', labels.labelLine);
    }

    labelRenderer.set('coord', self.get('coord'));
    this.set('labelRenderer', labelRenderer);
    self.set('label', labels);
  },

  /**
   * @protected
   * 榛樿鐨勬枃鏈牱寮�
   * @return {Object} default label config
   */
  getDefaultLabelCfg: function getDefaultLabelCfg() {
    var self = this;
    var labelCfg = self.get('labelCfg').cfg || self.get('labelCfg').globalCfg;
    var geomType = self.get('geomType');
    var viewTheme = self.get('viewTheme') || Global;

    if (geomType === 'polygon' || labelCfg && labelCfg.offset < 0 && Util.indexOf(IGNORE_ARR, geomType) === -1) {
      return Util.deepMix({}, self.get('label'), viewTheme.innerLabels, labelCfg);
    }

    return Util.deepMix({}, self.get('label'), viewTheme.label, labelCfg);
  },

  /**
   * @protected
   * 鑾峰彇labels
   * @param {Array} points points
   * @param {Array} shapes shapes
   * @return {Array} label items
   */
  getLabelsItems: function getLabelsItems(points, shapes) {
    var self = this;
    var items = [];
    var geom = self.get('geom');
    var coord = self.get('coord');

    self._getLabelCfgs(points, shapes);

    var labelCfg = self.get('labelItemCfgs'); // 鑾峰彇label鐩稿叧鐨剎锛寉鐨勫€硷紝鑾峰彇鍏蜂綋鐨剎,y,闃叉瀛樺湪鏁扮粍

    Util.each(points, function (point, i) {
      var origin = point[ORIGIN];
      var label = labelCfg[i];

      if (!label) {
        items.push(null);
        return;
      }

      if (!Util.isArray(label.text)) {
        label.text = [label.text];
      }

      var total = label.text.length;
      Util.each(label.text, function (sub, subIndex) {
        if (Util.isNil(sub) || sub === '') {
          items.push(null);
          return;
        }

        var obj = self.getLabelPoint(label, point, subIndex);
        obj = Util.mix({}, label, obj);

        if (!obj.textAlign) {
          obj.textAlign = self.getLabelAlign(obj, subIndex, total);
        }

        if (geom) {
          obj._id = geom._getShapeId(origin) + '-glabel-' + subIndex + '-' + obj.text;
        }

        obj.coord = coord;
        items.push(obj);
      });
    });
    return items;
  },

  /* /!*
   * @protected
   * 濡傛灉鍙戠敓鍐茬獊鍒欎細璋冩暣鏂囨湰鐨勪綅缃�
   * @param {Array} items 鏂囨湰鐨勯泦鍚�
   * @param {Array} shapes 鍏宠仈褰㈢姸
   * @return {Array} adjusted items
   *!/
  adjustItems(items, shapes) {
    // 澶氳竟褰hape鐨刲abel浣嶄簬鍏跺彲瑙嗕腑蹇�
    if (this.get('geomType') === 'polygon') {
      let index,
        shape,
        path,
        center,
        points;
      Util.each(items, (item, i) => {
        if (!item) return;
        shape = shapes[ i ];
        path = shape.attr('path');
        points = [[]];
        index = 0;
        path.forEach((segment, i) => {
          if (segment[ 0 ] === 'z' || segment[ 0 ] === 'Z' && i !== path.length - 1) {
            points.push([]);
            index += 1;
          }
          if (segment.length === 3) {
            points[ index ].push([ segment[ 1 ], segment[ 2 ] ]);
          }
        });
        center = visualCenter(points);
        item.x = center.x;
        item.y = center.y;
      });
    }
    return items;
  }
  */
  adjustItems: function adjustItems(items) {
    Util.each(items, function (item) {
      if (!item) {
        return;
      }

      if (item.offsetX) {
        item.x += item.offsetX;
      }

      if (item.offsetY) {
        item.y += item.offsetY;
      }
    });
    return items;
  },

  /**
   * drawing lines to labels
   * @param  {Array} items labels
   * @param  {Object} labelLine configuration for label lines
   */
  drawLines: function drawLines(items) {
    var self = this;
    Util.each(items, function (point) {
      if (!point) {
        return;
      }

      if (point.offset > 0) {
        self.lineToLabel(point);
      }
    });
  },
  // 瀹氫箟杩炴帴绾�
  lineToLabel: function lineToLabel() {},

  /**
   * @protected
   * 鑾峰彇鏂囨湰鐨勪綅缃俊鎭�
   * @param {Array} labelCfg labels
   * @param {Object} point point
   * @param {Number} index index
   * @return {Object} point
   */
  getLabelPoint: function getLabelPoint(labelCfg, point, index) {
    var self = this;
    var coord = self.get('coord');
    var total = labelCfg.text.length;

    function getDimValue(value, idx) {
      if (Util.isArray(value)) {
        if (labelCfg.text.length === 1) {
          // 濡傛灉浠呬竴涓猯abel,澶氫釜y,鍙栨渶鍚庝竴涓獃
          if (value.length <= 2) {
            value = value[value.length - 1]; // value = value[0];
          } else {
            value = avg(value);
          }
        } else {
          value = value[idx];
        }
      }

      return value;
    }

    var label = {
      text: labelCfg.text[index]
    }; // 澶氳竟褰㈠満鏅�,澶氱敤浜庡湴鍥�

    if (point && this.get('geomType') === 'polygon') {
      var centroid = getCentroid(point.x, point.y); // 澶氳竟褰㈢殑鍦烘櫙涔熸湁 x 鍜� y 鍙槸鏁板瓧鐨勬儏鍐碉紝璀褰� x 鍜� y 閮芥槸鍒嗙被瀛楁鐨勬椂鍊� @see #1184

      label.x = centroid[0];
      label.y = centroid[1];
    } else {
      label.x = getDimValue(point.x, index);
      label.y = getDimValue(point.y, index);
    } // get nearest point of the shape as the label line start point


    if (point && point.nextPoints && (point.shape === 'funnel' || point.shape === 'pyramid')) {
      var maxX = -Infinity;
      point.nextPoints.forEach(function (p) {
        p = coord.convert(p);

        if (p.x > maxX) {
          maxX = p.x;
        }
      });
      label.x = (label.x + maxX) / 2;
    } // sharp edge of the pyramid


    if (point.shape === 'pyramid' && !point.nextPoints && point.points) {
      point.points.forEach(function (p) {
        p = coord.convert(p);

        if (Util.isArray(p.x) && !point.x.includes(p.x) || Util.isNumber(p.x) && point.x !== p.x) {
          label.x = (label.x + p.x) / 2;
        }
      });
    }

    if (labelCfg.position) {
      self.setLabelPosition(label, point, index, labelCfg.position);
    }

    var offsetPoint = self.getLabelOffset(labelCfg, index, total);

    if (labelCfg.offsetX) {
      offsetPoint.x += labelCfg.offsetX;
    }

    if (labelCfg.offsetY) {
      offsetPoint.y += labelCfg.offsetY;
    }

    self.transLabelPoint(label);
    label.start = {
      x: label.x,
      y: label.y
    };
    label.x += offsetPoint.x;
    label.y += offsetPoint.y;
    label.color = point.color;
    return label;
  },
  setLabelPosition: function setLabelPosition() {},
  transLabelPoint: function transLabelPoint(point) {
    var self = this;
    var coord = self.get('coord');
    var tmpPoint = coord.applyMatrix(point.x, point.y, 1);
    point.x = tmpPoint[0];
    point.y = tmpPoint[1];
  },
  getOffsetVector: function getOffsetVector(point) {
    var self = this;
    var offset = point.offset || 0;
    var coord = self.get('coord');
    var vector;

    if (coord.isTransposed) {
      // 濡傛灉x,y缈昏浆锛屽垯鍋忕Щx
      vector = coord.applyMatrix(offset, 0);
    } else {
      // 鍚﹀垯锛屽亸杞瑈
      vector = coord.applyMatrix(0, offset);
    }

    return vector;
  },
  // 鑾峰彇榛樿鐨勫亸绉婚噺
  getDefaultOffset: function getDefaultOffset(point) {
    var self = this;
    var offset = 0;
    var coord = self.get('coord');
    var vector = self.getOffsetVector(point);

    if (coord.isTransposed) {
      // 濡傛灉x,y缈昏浆锛屽垯鍋忕Щx
      offset = vector[0];
    } else {
      // 鍚﹀垯锛屽亸杞瑈
      offset = vector[1];
    }

    var yScale = this.get('yScale');

    if (yScale && point.point) {
      // 浠呰€冭檻 y 鍗曞€肩殑鎯呭喌锛屽鍊肩殑鎯呭喌鍦ㄨ繖閲屼笉鑰冭檻
      var yValue = point.point[yScale.field];

      if (yValue < 0) {
        offset = offset * -1; // 濡傛灉 y 鍊兼槸璐熷€硷紝鍒欏弽鍚�
      }
    }

    return offset;
  },
  // 鑾峰彇鏂囨湰鐨勫亸绉讳綅缃紝x,y
  getLabelOffset: function getLabelOffset(point, index, total) {
    var self = this;
    var offset = self.getDefaultOffset(point);
    var coord = self.get('coord');
    var transposed = coord.isTransposed;
    var yField = transposed ? 'x' : 'y';
    var factor = transposed ? 1 : -1; // y 鏂瑰悜涓婅秺澶э紝鍍忕礌鐨勫潗鏍囪秺灏忥紝鎵€浠ransposed鏃跺皢绯绘暟鍙樻垚

    var offsetPoint = {
      x: 0,
      y: 0
    };

    if (index > 0 || total === 1) {
      // 鍒ゆ柇鏄惁灏忎簬0
      offsetPoint[yField] = offset * factor;
    } else {
      offsetPoint[yField] = offset * factor * -1;
    }

    return offsetPoint;
  },
  getLabelAlign: function getLabelAlign(point, index, total) {
    var self = this;
    var align = 'center';
    var coord = self.get('coord');

    if (coord.isTransposed) {
      var offset = self.getDefaultOffset(point); // var vector = coord.applyMatrix(offset,0);

      if (offset < 0) {
        align = 'right';
      } else if (offset === 0) {
        align = 'center';
      } else {
        align = 'left';
      }

      if (total > 1 && index === 0) {
        if (align === 'right') {
          align = 'left';
        } else if (align === 'left') {
          align = 'right';
        }
      }
    }

    return align;
  },
  _getLabelValue: function _getLabelValue(origin, scales) {
    if (!Util.isArray(scales)) {
      scales = [scales];
    }

    var text = [];
    Util.each(scales, function (scale) {
      var value = origin[scale.field];

      if (Util.isArray(value)) {
        var tmp = [];
        Util.each(value, function (subVal) {
          tmp.push(scale.getText(subVal));
        });
        value = tmp;
      } else {
        value = scale.getText(value);
      }

      if (Util.isNil(value) || value === '') {
        text.push(null);
      }

      text.push(value);
    });
    return text;
  },
  // 鑾峰彇姣忎釜label鐨勯厤缃�
  _getLabelCfgs: function _getLabelCfgs(points) {
    var self = this;
    var labelCfg = this.get('labelCfg');
    var scales = labelCfg.scales;
    var defaultCfg = this.get('label');
    var viewTheme = self.get('viewTheme') || Global;
    var cfgs = [];

    if (labelCfg.globalCfg && labelCfg.globalCfg.type) {
      self.set('type', labelCfg.globalCfg.type);
    }

    Util.each(points, function (point, i) {
      var cfg = {};
      var origin = point[ORIGIN];

      var originText = self._getLabelValue(origin, scales);

      if (labelCfg.callback) {
        // callback涓簲浣跨敤鍘熷鏁版嵁锛岃€屼笉鏄暟鎹瓧绗︿覆
        var originValues = scales.map(function (scale) {
          return origin[scale.field];
        }); // 灏唒oint淇℃伅浠ュ強index淇℃伅涔熻繑鍥烇紝鏂逛究鑳藉鏍规嵁point浠ュ強index锛岃繑鍥炰笉鍚岀殑閰嶇疆

        cfg = labelCfg.callback.apply(null, [].concat(originValues, [point, i]));
      }

      if (!cfg && cfg !== 0) {
        cfgs.push(null);
        return;
      }

      if (Util.isString(cfg) || Util.isNumber(cfg)) {
        cfg = {
          text: cfg
        };
      } else {
        cfg.text = cfg.content || originText[0];
        delete cfg.content;
      }

      cfg = Util.mix({}, defaultCfg, labelCfg.globalCfg || {}, cfg); // 鍏煎鏃х殑婧愭暟鎹啓鍦╥tem.point涓�

      point.point = origin;
      cfg.point = origin;

      if (cfg.htmlTemplate) {
        cfg.useHtml = true;
        cfg.text = cfg.htmlTemplate.call(null, cfg.text, point, i);
        delete cfg.htmlTemplate;
      }

      if (cfg.formatter) {
        cfg.text = cfg.formatter.call(null, cfg.text, point, i);
        delete cfg.formatter;
      }

      if (cfg.label) {
        // 鍏煎鏈変簺鐩存帴鍐欏湪labelCfg.label鐨勯厤缃�
        var label = cfg.label;
        delete cfg.label;
        cfg = Util.mix(cfg, label);
      }

      if (cfg.textStyle) {
        // 鍏煎鏃у啓娉曪紝globalCfg鐨刼ffset浼樺厛绾ч珮
        delete cfg.textStyle.offset;
        var textStyle = cfg.textStyle;

        if (Util.isFunction(textStyle)) {
          cfg.textStyle = textStyle.call(null, cfg.text, point, i);
        }
      }

      if (cfg.labelLine) {
        cfg.labelLine = Util.mix({}, defaultCfg.labelLine, cfg.labelLine);
      } // 鍥犱负 defaultCfg.textStyle 鏈夊彲鑳芥槸鍑芥暟锛屾墍浠ヨ繖閲屽彲鑳芥病鏈夋妸涓婚鐨� label 鏍峰紡鍚堣繘鏉�


      cfg.textStyle = Util.mix({}, defaultCfg.textStyle, viewTheme.label.textStyle, cfg.textStyle);
      delete cfg.items;
      cfgs.push(cfg);
    });
    this.set('labelItemCfgs', cfgs);
  },
  showLabels: function showLabels(points, shapes) {
    var self = this;
    var labelRenderer = self.get('labelRenderer');
    var items = self.getLabelsItems(points, shapes);
    shapes = [].concat(shapes);
    var type = self.get('type');
    items = self.adjustItems(items, shapes);
    self.drawLines(items);
    labelRenderer.set('items', items.filter(function (item, i) {
      if (!item) {
        shapes.splice(i, 1);
        return false;
      }

      return true;
    }));

    if (type) {
      labelRenderer.set('shapes', shapes);
      labelRenderer.set('type', type);
      labelRenderer.set('points', points);
    }

    labelRenderer.set('canvas', this.get('canvas'));
    labelRenderer.draw();
  },
  destroy: function destroy() {
    this.get('labelRenderer').destroy(); // 娓呯悊鏂囨湰

    GeomLabels.superclass.destroy.call(this);
  }
}); // Util.assign(GeomLabels.prototype, Labels.LabelslabelRenderer);

module.exports = GeomLabels;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 闇€瑕佽绠楁墍鍗爔杞翠笂鐨勫搴︾殑杈呭姪绫�
 * @author sima.zhang1990@gmail.com
 * @author dxq613@gmail.com
 */
var Global = __webpack_require__(5);

var Util = __webpack_require__(0); // 宸茬粡鎺掑簭鍚庣殑鏁版嵁鏌ユ壘璺濈鏈€灏忕殑


function findMinDistance(arr, scale) {
  var count = arr.length; // 鏃ユ湡绫诲瀷鐨� values 缁忓父涓婃枃鏈被鍨嬶紝鎵€浠ラ渶瑕佽浆鎹竴涓�

  if (Util.isString(arr[0])) {
    arr = arr.map(function (v) {
      return scale.translate(v);
    });
  }

  var distance = arr[1] - arr[0];

  for (var i = 2; i < count; i++) {
    var tmp = arr[i] - arr[i - 1];

    if (distance > tmp) {
      distance = tmp;
    }
  }

  return distance;
}

var SizeMixin = {
  getDefaultSize: function getDefaultSize() {
    var defaultSize = this.get('defaultSize');
    var viewTheme = this.get('viewTheme') || Global;

    if (!defaultSize) {
      var coord = this.get('coord');
      var xScale = this.getXScale();
      var xValues = xScale.values;
      var dataArray = this.get('dataArray');
      var count;

      if (xScale.isLinear && xValues.length > 1) {
        xValues.sort();
        var interval = findMinDistance(xValues, xScale);
        count = (xScale.max - xScale.min) / interval;

        if (xValues.length > count) {
          count = xValues.length;
        }
      } else {
        count = xValues.length;
      }

      var range = xScale.range;
      var normalizeSize = 1 / count;
      var widthRatio = 1;

      if (this.isInCircle()) {
        if (coord.isTransposed && count > 1) {
          // 鏋佸潗鏍囦笅澶氬眰鐜浘
          widthRatio = viewTheme.widthRatio.multiplePie;
        } else {
          widthRatio = viewTheme.widthRatio.rose;
        }
        /* if (dataArray.length > 1) {
          normalizeSize *= (range[1] - range[0]);
        } */

      } else {
        if (xScale.isLinear) {
          normalizeSize *= range[1] - range[0];
        }

        widthRatio = viewTheme.widthRatio.column; // 鏌辩姸鍥捐闄や互2
      }

      normalizeSize *= widthRatio;

      if (this.hasAdjust('dodge')) {
        var _this$_getDodgeCfg = this._getDodgeCfg(dataArray),
            dodgeCount = _this$_getDodgeCfg.dodgeCount,
            dodgeRatio = _this$_getDodgeCfg.dodgeRatio;

        normalizeSize = normalizeSize / dodgeCount;

        if (dodgeRatio > 0) {
          normalizeSize = dodgeRatio * normalizeSize / widthRatio;
        }
      }

      defaultSize = normalizeSize;
      this.set('defaultSize', defaultSize);
    }

    return defaultSize;
  },
  _getDodgeCfg: function _getDodgeCfg(dataArray) {
    var adjusts = this.get('adjusts');
    var dodgeBy;
    var dodgeRatio;
    var count = dataArray.length;
    Util.each(adjusts, function (adjust) {
      if (adjust.type === 'dodge') {
        dodgeBy = adjust.dodgeBy;
        dodgeRatio = adjust.dodgeRatio;
      }
    });

    if (dodgeBy) {
      var mergeData = Util.Array.merge(dataArray);
      var values = Util.Array.values(mergeData, dodgeBy);
      count = values.length;
    }

    return {
      dodgeCount: count,
      dodgeRatio: dodgeRatio
    };
  },
  getDimWidth: function getDimWidth(dimName) {
    var coord = this.get('coord');
    var start = coord.convertPoint({
      x: 0,
      y: 0
    });
    var end = coord.convertPoint({
      x: dimName === 'x' ? 1 : 0,
      y: dimName === 'x' ? 0 : 1
    });
    var width = 0;

    if (start && end) {
      width = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
    }

    return width;
  },
  _getWidth: function _getWidth() {
    var coord = this.get('coord');
    var width; // x杞寸殑闀垮害

    if (this.isInCircle() && !coord.isTransposed) {
      // 鏋佸潗鏍囦笅 width 涓哄姬闀�
      width = (coord.endAngle - coord.startAngle) * coord.radius;
    } else {
      width = this.getDimWidth('x'); // 涓嶉渶瑕佸垽鏂璽ranspose
    }

    return width;
  },
  _toNormalizedSize: function _toNormalizedSize(size) {
    var width = this._getWidth();

    return size / width;
  },
  _toCoordSize: function _toCoordSize(normalizeSize) {
    var width = this._getWidth();

    return width * normalizeSize;
  },
  getNormalizedSize: function getNormalizedSize(obj) {
    var size = this.getAttrValue('size', obj);

    if (Util.isNil(size)) {
      size = this.getDefaultSize();
    } else {
      size = this._toNormalizedSize(size);
    }

    return size;
  },
  getSize: function getSize(obj) {
    var size = this.getAttrValue('size', obj);

    if (Util.isNil(size)) {
      var normalizeSize = this.getDefaultSize();
      size = this._toCoordSize(normalizeSize);
    }

    return size;
  }
};
module.exports = SizeMixin;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var getColDefs = __webpack_require__(72);

module.exports = function (chart, field) {
  var colDefs = getColDefs(chart);

  if (colDefs && colDefs[field]) {
    return colDefs[field];
  }
};

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var scaleController = chart.get('scaleController') || {};
  return scaleController.defs;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var TimeUtil = __webpack_require__(52);

module.exports = function (data, scale) {
  var result;
  var field = scale.field,
      type = scale.type;
  var values = Util.Array.values(data, field);

  if (type === 'linear') {
    result = Util.Array.getRange(values);

    if (scale.min < result.min) {
      result.min = scale.min;
    }

    if (scale.max > result.max) {
      result.max = scale.max;
    }
  } else if (type === 'timeCat') {
    Util.each(values, function (v, i) {
      values[i] = TimeUtil.toTimeStamp(v);
    });
    values.sort(function (v1, v2) {
      return v1 - v2;
    });
    result = values;
  } else {
    result = values;
  }

  return result;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Format = __webpack_require__(37);

var PathSegment = __webpack_require__(50);

var Marker = function Marker(cfg) {
  Marker.superclass.constructor.call(this, cfg);
};

Marker.Symbols = {
  // 鍦�
  circle: function circle(x, y, r) {
    return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
  },
  // 姝ｆ柟褰�
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  // 鑿卞舰
  diamond: function diamond(x, y, r) {
    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
  },
  // 涓夎褰�
  triangle: function triangle(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];
  },
  // 鍊掍笁瑙掑舰
  'triangle-down': function triangleDown(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
  }
};
Marker.ATTRS = {
  path: null,
  lineWidth: 1
};
Util.extend(Marker, Shape);
Util.augment(Marker, {
  type: 'marker',
  canFill: true,
  canStroke: true,
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      x: 0,
      y: 0,
      lineWidth: 1
    };
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.radius;
    var lineWidth = this.getHitLineWidth();
    var halfWidth = lineWidth / 2 + r;
    return {
      minX: cx - halfWidth,
      minY: cy - halfWidth,
      maxX: cx + halfWidth,
      maxY: cy + halfWidth
    };
  },
  _getPath: function _getPath() {
    var attrs = this._attrs;
    var x = attrs.x;
    var y = attrs.y;
    var r = attrs.radius || attrs.r;
    var symbol = attrs.symbol || 'circle';
    var method;

    if (Util.isFunction(symbol)) {
      method = symbol;
    } else {
      method = Marker.Symbols[symbol];
    }

    if (!method) {
      console.warn(symbol + " marker is not supported.");
      return null;
    }

    return method(x, y, r);
  },
  createPath: function createPath(context) {
    var segments = this._cfg.segments;

    if (segments && !this._cfg.hasUpdate) {
      context.beginPath();

      for (var i = 0; i < segments.length; i++) {
        segments[i].draw(context);
      }

      return;
    }

    var path = Format.parsePath(this._getPath());
    context.beginPath();
    var preSegment;
    segments = [];

    for (var _i = 0; _i < path.length; _i++) {
      var item = path[_i];
      preSegment = new PathSegment(item, preSegment, _i === path.length - 1);
      segments.push(preSegment);
      preSegment.draw(context);
    }

    this._cfg.segments = segments;
    this._cfg.hasUpdate = false;
  }
});
module.exports = Marker;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var vec2 = Util.vec2;

function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p3 + 3 * t * p2) + t * t * (t * p0 + 3 * onet * p1);
}

function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}

function cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, out) {
  var t;
  var interval = 0.005;
  var d = Infinity;

  var _t;

  var v1;
  var d1;
  var d2;
  var v2;
  var prev;
  var next;
  var EPSILON = 0.0001;
  var v0 = [x, y];

  for (_t = 0; _t < 1; _t += 0.05) {
    v1 = [cubicAt(x1, x2, x3, x4, _t), cubicAt(y1, y2, y3, y4, _t)];
    d1 = vec2.squaredDistance(v0, v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity;

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON) {
      break;
    }

    prev = t - interval;
    next = t + interval;
    v1 = [cubicAt(x1, x2, x3, x4, prev), cubicAt(y1, y2, y3, y4, prev)];
    d1 = vec2.squaredDistance(v0, v1);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      v2 = [cubicAt(x1, x2, x3, x4, next), cubicAt(y1, y2, y3, y4, next)];
      d2 = vec2.squaredDistance(v0, v2);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }

  if (out) {
    out.x = cubicAt(x1, x2, x3, x4, t);
    out.y = cubicAt(y1, y2, y3, y4, t);
  }

  return Math.sqrt(d);
}

function cubicExtrema(p0, p1, p2, p3) {
  var a = 3 * p0 - 9 * p1 + 9 * p2 - 3 * p3;
  var b = 6 * p1 - 12 * p2 + 6 * p3;
  var c = 3 * p2 - 3 * p3;
  var extrema = [];
  var t1;
  var t2;
  var discSqrt;

  if (Util.isNumberEqual(a, 0)) {
    if (!Util.isNumberEqual(b, 0)) {
      t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extrema.push(t1);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (Util.isNumberEqual(disc, 0)) {
      extrema.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b + discSqrt) / (2 * a);
      t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extrema.push(t1);
      }

      if (t2 >= 0 && t2 <= 1) {
        extrema.push(t2);
      }
    }
  }

  return extrema;
}

function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
}

function cubiclLen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (Util.isNil(z)) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }

  return z2 * sum;
}

module.exports = {
  at: cubicAt,
  derivativeAt: cubicDerivativeAt,
  projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y) {
    var rst = {};
    cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, rst);
    return rst;
  },
  pointDistance: cubicProjectPoint,
  extrema: cubicExtrema,
  len: cubiclLen
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var Line = __webpack_require__(48);

var Quadratic = __webpack_require__(144);

var Cubic = __webpack_require__(75);

var Arc = __webpack_require__(47);

module.exports = {
  line: function line(x1, y1, x2, y2, lineWidth, x, y) {
    var box = Line.box(x1, y1, x2, y2, lineWidth);

    if (!this.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {
      return false;
    }

    var d = Line.pointDistance(x1, y1, x2, y2, x, y);

    if (isNaN(d)) {
      return false;
    }

    return d <= lineWidth / 2;
  },
  polyline: function polyline(points, lineWidth, x, y) {
    var l = points.length - 1;

    if (l < 1) {
      return false;
    }

    for (var i = 0; i < l; i++) {
      var x1 = points[i][0];
      var y1 = points[i][1];
      var x2 = points[i + 1][0];
      var y2 = points[i + 1][1];

      if (this.line(x1, y1, x2, y2, lineWidth, x, y)) {
        return true;
      }
    }

    return false;
  },
  cubicline: function cubicline(x1, y1, x2, y2, x3, y3, x4, y4, lineWidth, x, y) {
    return Cubic.pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x, y) <= lineWidth / 2;
  },
  quadraticline: function quadraticline(x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    return Quadratic.pointDistance(x1, y1, x2, y2, x3, y3, x, y) <= lineWidth / 2;
  },
  arcline: function arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y) {
    return Arc.pointDistance(cx, cy, r, startAngle, endAngle, clockwise, x, y) <= lineWidth / 2;
  },
  rect: function rect(rx, ry, width, height, x, y) {
    return rx <= x && x <= rx + width && ry <= y && y <= ry + height;
  },
  circle: function circle(cx, cy, r, x, y) {
    return Math.pow(x - cx, 2) + Math.pow(y - cy, 2) <= Math.pow(r, 2);
  },
  box: function box(minX, maxX, minY, maxY, x, y) {
    return minX <= x && x <= maxX && minY <= y && y <= maxY;
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(150);

var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments

var parsePathString = function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }

  if (typeof pathString === typeof []) {
    return pathString;
  }

  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });

    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }

    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }

    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));

        if (!paramCounts[name]) {
          break;
        }
      }
    }
  });
  return data;
}; // http://schepers.cc/getting-to-the-point


var catmullRom2bezier = function catmullRom2bezier(crp, z) {
  var d = [];

  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [{
      x: +crp[i - 2],
      y: +crp[i - 1]
    }, {
      x: +crp[i],
      y: +crp[i + 1]
    }, {
      x: +crp[i + 2],
      y: +crp[i + 3]
    }, {
      x: +crp[i + 4],
      y: +crp[i + 5]
    }];

    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }

    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
  }

  return d;
};

var ellipsePath = function ellipsePath(x, y, rx, ry, a) {
  var res = [];

  if (a === null && ry === null) {
    ry = rx;
  }

  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;

  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
  } else {
    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
  }

  return res;
};

var pathToAbsolute = function pathToAbsolute(pathArray) {
  pathArray = parsePathString(pathArray);

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;

  if (pathArray[0][0] === 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';

  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];

    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();

      switch (r[0]) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;

        case 'V':
          r[1] = +pa[1] + y;
          break;

        case 'H':
          r[1] = +pa[1] + x;
          break;

        case 'R':
          dots = [x, y].concat(pa.slice(1));

          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }

          res.pop();
          res = res.concat(catmullRom2bezier(dots, crz));
          break;

        case 'O':
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;

        case 'U':
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ['U'].concat(res[res.length - 1].slice(-2));
          break;

        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        // for lint

        default:
          for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {
            r[_j] = +pa[_j] + (_j % 2 ? x : y);
          }

      }
    } else if (pa0 === 'R') {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRom2bezier(dots, crz));
      r = ['R'].concat(pa.slice(-2));
    } else if (pa0 === 'O') {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === 'U') {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ['U'].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }

    pa0 = pa0.toUpperCase();

    if (pa0 !== 'O') {
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;

        case 'H':
          x = r[1];
          break;

        case 'V':
          y = r[1];
          break;

        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        // for lint

        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }

  return res;
};

var l2c = function l2c(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};

var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;

  var _23 = 2 / 3;

  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};

var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  if (rx === ry) {
    rx += 1;
  }

  var _120 = Math.PI * 120 / 180;

  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;

  var rotate = function rotate(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return {
      x: X,
      y: Y
    };
  };

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    if (x1 === x2 && y1 === y2) {
      // 鑻ュ姬鐨勮捣濮嬬偣鍜岀粓鐐归噸鍙犲垯閿欏紑涓€鐐�
      x2 += 1;
      y2 += 1;
    } // const cos = Math.cos(Math.PI / 180 * angle);
    // const sin = Math.sin(Math.PI / 180 * angle);


    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);

    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }

    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  }

  res = [m2, m3, m4].concat(res).join().split(',');
  var newres = [];

  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
  }

  return newres;
};

var pathTocurve = function pathTocurve(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = []; // path commands of original path p

  var pcoms2 = []; // path commands of original path p2

  var pfirst = ''; // temporary holder for original path command

  var pcom = ''; // holder for previous path command of original path

  var ii;

  var processPath = function processPath(path, d, pcom) {
    var nx, ny;

    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }

    !(path[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);

    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;

      case 'A':
        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
        break;

      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In "S" case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous

          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }

        path = ['C', nx, ny].concat(path.slice(1));
        break;

      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In "T" case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar

          d.qy = d.y * 2 - d.qy; // to case "S".
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }

        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
        break;

      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
        break;

      case 'L':
        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
        break;

      case 'H':
        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
        break;

      case 'V':
        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
        break;

      case 'Z':
        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
        break;

      default:
        break;
    }

    return path;
  };

  var fixArc = function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];

      while (pi.length) {
        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

        p2 && (pcoms2[i] = 'A'); // the same as above

        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
      }

      pp.splice(i, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  var fixM = function fixM(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
      path2.splice(i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  ii = Math.max(p.length, p2 && p2.length || 0);

  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]); // save current path command

    if (pfirst !== 'C') {
      // C is not saved yet, because it may be result of conversion
      pcoms1[i] = pfirst; // Save current path command

      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
    }

    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

    if (p2) {
      // the same procedures is done to p2
      p2[i] && (pfirst = p2[i][0]);

      if (pfirst !== 'C') {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }

      p2[i] = processPath(p2[i], attrs2, pcom);

      if (pcoms2[i] !== 'A' && pfirst === 'C') {
        pcoms2[i] = 'C';
      }

      fixArc(p2, i);
    }

    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }

  return p2 ? [p, p2] : p;
};

var p2s = /,?([a-z]),?/gi;

var parsePathArray = function parsePathArray(path) {
  return path.join(',').replace(p2s, '$1');
};

var base3 = function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};

var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }

  return z2 * sum;
};

var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;

  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (t > 0 && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    var t1 = (-b + sqrtb2ac) / (2 * a);

    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }

    var t2 = (-b - sqrtb2ac) / (2 * a);

    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length;
  var jlen = j;
  var mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};

var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);

  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }

  return {
    x: px,
    y: py
  };
};

var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};

var rectPath = function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }

  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
  res.parsePathArray = parsePathArray;
  return res;
};

var box = function box(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }

  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    w: width,
    height: height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(' ')
  };
};

var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};

var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!Util.isArray(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }

  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};

var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

  return {
    x: x,
    y: y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha: alpha
  };
};

var interHelper = function interHelper(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }

  for (var _i = 0; _i < n2 + 1; _i++) {
    var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));

    dots2.push({
      x: _d.x,
      y: _d.y,
      t: _i / n2
    });
  }

  for (var _i2 = 0; _i2 < n1; _i2++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[_i2];
      var di1 = dots1[_i2 + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }

        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res++;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
};

var interPathHelper = function interPathHelper(path1, path2, justCount) {
  path1 = pathTocurve(path1);
  path2 = pathTocurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] === 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] === 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = interHelper(bez1, bez2, justCount);

          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }

            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
};

var pathIntersection = function pathIntersection(path1, path2) {
  return interPathHelper(path1, path2);
};

function decasteljau(points, t) {
  var left = [];
  var right = [];

  function recurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var middlePoints = [];

      for (var i = 0; i < points.length - 1; i++) {
        if (i === 0) {
          left.push(points[0]);
        }

        if (i === points.length - 2) {
          right.push(points[i + 1]);
        }

        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }

      recurse(middlePoints, t);
    }
  }

  if (points.length) {
    recurse(points, t);
  }

  return {
    left: left,
    right: right.reverse()
  };
}

function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];

  if (end[0] === 'A') {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === 'C') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === 'S' || end[0] === 'Q') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }

  var leftSegments = points;
  var t = 1 / count;

  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }

  segments.push(leftSegments);
  var result = segments.map(function (segment) {
    var cmd = [];

    if (segment.length === 4) {
      cmd.push('C');
      cmd = cmd.concat(segment[2]);
    }

    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push('Q');
      }

      cmd = cmd.concat(segment[1]);
    }

    if (segment.length === 2) {
      cmd.push('L');
    }

    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}

var splitSegment = function splitSegment(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }

  var segments = [];

  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);

    if (temp[0] === 'M') {
      temp[0] = 'L';
    }

    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }

  return segments;
};

var fillPath = function fillPath(source, target) {
  if (source.length === 1) {
    return source;
  }

  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];

  if (source.length === 1 && source[0][0] === 'M') {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }

    return source;
  }

  for (var _i3 = 0; _i3 < targetLen; _i3++) {
    var index = Math.floor(ratio * _i3);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }

  var filled = segmentsToFill.reduce(function (filled, count, i) {
    if (i === sourceLen) {
      return filled.concat(source[sourceLen]);
    }

    return filled.concat(splitSegment(source[i], source[i + 1], count));
  }, []);
  filled.unshift(source[0]);

  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
    filled.push('Z');
  }

  return filled;
};

var isEqual = function isEqual(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }

  var result = true;
  Util.each(obj1, function (item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};

function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;

  if (add < min) {
    min = add;
    type = 'add';
  }

  if (del < min) {
    min = del;
    type = 'del';
  }

  return {
    type: type,
    min: min
  };
}
/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * 璁＄畻涓ゆ潯path鐨勭紪杈戣窛绂�
 */


var levenshteinDistance = function levenshteinDistance(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment, targetSegment;
  var temp = 0;

  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }

  var dist = [];

  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = {
      min: i
    };
  }

  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = {
      min: j
    };
  }

  for (var _i4 = 1; _i4 <= sourceLen; _i4++) {
    sourceSegment = source[_i4 - 1];

    for (var _j2 = 1; _j2 <= targetLen; _j2++) {
      targetSegment = target[_j2 - 1];

      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }

      var del = dist[_i4 - 1][_j2].min + 1;
      var add = dist[_i4][_j2 - 1].min + 1;
      var modify = dist[_i4 - 1][_j2 - 1].min + temp;
      dist[_i4][_j2] = getMinDiff(del, add, modify);
    }
  }

  return dist;
};

var fillPathByDiff = function fillPathByDiff(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1; // 濡傛灉source鍜宼arget涓嶆槸瀹屽叏涓嶇浉绛�

  if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
    // 鑾峰彇浠巗ource鍒皌arget鎵€闇€鏀瑰姩
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;

      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }

      index = minPos;

      if (diffMatrix[i][index].type) {
        changes.push({
          index: i - 1,
          type: diffMatrix[i][index].type
        });
      }
    } // 瀵箂ource杩涜澧炲垹path


    for (var _i5 = changes.length - 1; _i5 >= 0; _i5--) {
      index = changes[_i5].index;

      if (changes[_i5].type === 'add') {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  } // source灏鹃儴琛ラ綈


  sourceLen = source.length;
  var diff = targetLen - sourceLen;

  if (sourceLen < targetLen) {
    for (var _i6 = 0; _i6 < diff; _i6++) {
      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }

      sourceLen += 1;
    }
  }

  return source;
}; // 灏嗕袱涓偣鍧囧垎鎴恈ount涓偣


function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);

  var formerEnd = _getSegmentPoints(former)[0];

  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);

    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    }
  }

  return result;
}
/*
 * 鎶藉彇pathSegment涓殑鍏抽敭鐐�
 * M,L,A,Q,H,V涓€涓鐐�
 * Q, S鎶藉彇涓€涓鐐癸紝涓€涓帶鍒剁偣
 * C鎶藉彇涓€涓鐐癸紝涓や釜鎺у埗鐐�
 */


function _getSegmentPoints(segment) {
  var points = [];

  switch (segment[0]) {
    case 'M':
      points.push([segment[1], segment[2]]);
      break;

    case 'L':
      points.push([segment[1], segment[2]]);
      break;

    case 'A':
      points.push([segment[6], segment[7]]);
      break;

    case 'Q':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'T':
      points.push([segment[1], segment[2]]);
      break;

    case 'C':
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;

    case 'S':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'H':
      points.push([segment[1], segment[1]]);
      break;

    case 'V':
      points.push([segment[1], segment[1]]);
      break;

    default:
  }

  return points;
}

var formatPath = function formatPath(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }

  var points;

  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      // 鑾峰彇fromPath鐨刾athSegment鐨勭鐐癸紝鏍规嵁toPath鐨勬寚浠ゅ鍏舵敼閫�
      points = _getSegmentPoints(fromPath[i]);

      switch (toPath[i][0]) {
        case 'M':
          fromPath[i] = ['M'].concat(points[0]);
          break;

        case 'L':
          fromPath[i] = ['L'].concat(points[0]);
          break;

        case 'A':
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;

        case 'Q':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'T':
          fromPath[i] = ['T'].concat(points[0]);
          break;

        case 'C':
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'S':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        default:
          fromPath[i] = toPath[i];
      }
    }
  }

  return fromPath;
};

module.exports = {
  parsePathString: parsePathString,
  parsePathArray: parsePathArray,
  pathTocurve: pathTocurve,
  pathToAbsolute: pathToAbsolute,
  catmullRomToBezier: catmullRom2bezier,
  rectPath: rectPath,
  fillPath: fillPath,
  fillPathByDiff: fillPathByDiff,
  formatPath: formatPath,
  intersection: pathIntersection
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = exports.EPSILON = 0.000001;
var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = exports.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(6);
var isArray = __webpack_require__(4);
var each = __webpack_require__(2);

module.exports = function valuesOfKey(data, name) {
  var rst = [];
  var tmpMap = {};
  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];
    if (!isNil(value)) {
      if (!isArray(value)) {
        value = [value];
      }
      each(value, function (val) {
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      });
    }
  }
  return rst;
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray = __webpack_require__(4);

var clone = function clone(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
    return obj;
  }
  var rst = void 0;
  if (isArray(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (_typeof(obj[i]) === 'object' && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (_typeof(obj[k]) === 'object' && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }

  return rst;
};

module.exports = clone;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__(40);
var isArray = __webpack_require__(4);

var MAX_MIX_LEVEL = 5;

function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];
      if (value !== null && isPlainObject(value)) {
        if (!isPlainObject(dist[key])) {
          dist[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key], value, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if (isArray(value)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value);
      } else if (value !== undefined) {
        dist[key] = value;
      }
    }
  }
}

var deepMix = function deepMix() {
  var args = new Array(arguments.length);
  var length = args.length;
  for (var i = 0; i < length; i++) {
    args[i] = arguments[i];
  }
  var rst = args[0];
  for (var _i = 1; _i < length; _i++) {
    _deepMix(rst, args[_i]);
  }
  return rst;
};

module.exports = deepMix;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isArrayLike = __webpack_require__(21);

var filter = function filter(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  each(arr, function (value, index) {
    if (func(value, index)) {
      result.push(value);
    }
  });
  return result;
};

module.exports = filter;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var isObjectLike = __webpack_require__(86);
var isArrayLike = __webpack_require__(21);
var isString = __webpack_require__(15);

var isEqual = function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if (isString(value) || isString(other)) {
    return false;
  }
  if (isArrayLike(value) || isArrayLike(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (isObjectLike(value) || isObjectLike(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var _rst = true;
    for (var _i = 0; _i < valueKeys.length; _i++) {
      _rst = isEqual(value[valueKeys[_i]], other[valueKeys[_i]]);
      if (!_rst) {
        break;
      }
    }
    return _rst;
  }
  return false;
};

module.exports = isEqual;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

var clamp = function clamp(a, min, max) {
  if (a < min) {
    return min;
  } else if (a > max) {
    return max;
  }
  return a;
};

module.exports = clamp;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var mat3 = __webpack_require__(348);

mat3.translate = function (out, a, v) {
  var transMat = new Array(9);
  mat3.fromTranslation(transMat, v);
  return mat3.multiply(out, transMat, a);
};

mat3.rotate = function (out, a, rad) {
  var rotateMat = new Array(9);
  mat3.fromRotation(rotateMat, rad);
  return mat3.multiply(out, rotateMat, a);
};

mat3.scale = function (out, a, v) {
  var scaleMat = new Array(9);
  mat3.fromScaling(scaleMat, v);
  return mat3.multiply(out, scaleMat, a);
};

module.exports = mat3;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isObjectLike = function isObjectLike(value) {
  /**
   * isObjectLike({}) => true
   * isObjectLike([1, 2, 3]) => true
   * isObjectLike(Function) => false
   * isObjectLike(null) => false
   */
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
};

module.exports = isObjectLike;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var deleteFuncMap = {
  Chart: 'deleteChart',
  Coord: 'deleteCoord',
  Geom: 'deleteGeom',
  Axis: 'deleteAxis',
  Tooltip: 'deleteTooltip',
  Legend: 'deleteLegend',
  Label: 'deleteLabel',
  View: 'deleteView',
  Guide: 'deleteGuide',
  GuideLine: 'deleteTypedGuide',
  GuideImage: 'deleteTypedGuide',
  GuideText: 'deleteTypedGuide',
  GuideRegion: 'deleteTypedGuide',
  GuideHtml: 'deleteTypedGuide',
  GuideArc: 'deleteTypedGuide',
  GuideRegionFilter: 'deleteTypedGuide',
  GuideDataMarker: 'deleteTypedGuide',
  GuideDataRegion: 'deleteTypedGuide',
  Facet: 'deleteFacet'
};

var iMerge = {
  merge: function merge(config, deleteInfos, elementInfos, clear) {
    this.mergeDelete(config, deleteInfos, elementInfos);
    this.mergeUpdate(config, clear);
  },
  mergeDelete: function mergeDelete(config, deleteInfos, elementInfos) {
    var _this = this;

    Object.keys(deleteInfos).forEach(function (id) {
      var funName = deleteFuncMap[elementInfos[id].name];
      var deleteConfigContainer = config;
      if (elementInfos[id].viewId) {
        deleteConfigContainer = config.views[elementInfos[id].viewId];
      }
      if (_this[funName]) {
        _this[funName](deleteConfigContainer, id, elementInfos[id].parentInfo.id);
      }
    });
  },
  deleteAxis: function deleteAxis(config, id) {
    if (!config) return;
    delete config.axises[id];
  },
  deleteTooltip: function deleteTooltip(config) {
    if (!config) return;
    delete config.tooltip;
  },
  deleteCoord: function deleteCoord(config) {
    if (!config) return;
    delete config.coord;
  },
  deleteLegend: function deleteLegend(config, id) {
    if (!config) return;
    delete config.legends[id];
  },
  deleteGuide: function deleteGuide(config) {
    if (!config) return;
    delete config.guide;
  },
  deleteGeom: function deleteGeom(config, id) {
    if (!config || !config.geoms) return;

    delete config.geoms[id];
  },
  deleteLabel: function deleteLabel(config, id, parentId) {
    if (!config || !config.geoms || !config.geoms[parentId]) return;

    delete config.geoms[parentId].label;
  },
  deleteFacet: function deleteFacet(config) {
    if (!config) return;

    delete config.facet;
  },
  deleteTypedGuide: function deleteTypedGuide(config, id) {
    if (!config || !config.guide) return;
    delete config.guide.elements[id];
  },
  deleteView: function deleteView(config, id) {
    if (!config) return;
    delete config.views[id];
  },
  mergeUpdate: function mergeUpdate(config, clear) {
    this.mergeChart(config, clear);
    this.mergeAxises(config, clear);
    this.mergeCoord(config, clear);
    this.mergeGeoms(config.geoms, clear);
    this.mergeLegends(config.legends, clear);
    this.mergeTooltip(config, clear);
    this.mergeViews(config.views, clear);
    this.mergeGuide(config.guide, clear);
  },
  mergeChart: function mergeChart(config, clear) {
    if (config.chart && config.chart.updateProps) {
      config.chart.props = config.chart.updateProps;
    }
    if (clear) {
      delete config.chart.g2Instance;
    }
  },
  mergeAxises: function mergeAxises(config, clear) {
    var axises = config.axises;

    if (!axises == null) {
      return;
    }

    for (var id in axises) {
      if (axises[id] && axises[id].updateProps) {
        axises[id].props = axises[id].updateProps;
      }
      if (clear) {
        delete axises[id].g2Instance;
      }
    }
  },
  mergeTooltip: function mergeTooltip(config, clear) {
    if (!config.tooltip) return;
    if (clear) {
      delete config.tooltip.g2Instance;
    }

    if (config.tooltip.updateProps) {
      config.tooltip.props = config.tooltip.updateProps;
    }
  },
  mergeCoord: function mergeCoord(config, clear) {
    if (!config.coord) return;
    if (clear) delete config.coord.g2Instance;
    if (config.coord.updateProps) {
      config.coord.props = config.coord.updateProps;
    }
  },
  mergeLegends: function mergeLegends(legends, clear) {
    if (!legends) return;

    for (var id in legends) {
      if (legends[id]) {
        var legendConfig = legends[id];
        if (clear) {
          delete legendConfig.g2Instance;
        }
        if (legendConfig.updateProps) legendConfig.props = legendConfig.updateProps;
      }
    }
  },
  mergeGeoms: function mergeGeoms(geoms, clear) {
    if (geoms == null) return;

    for (var id in geoms) {
      if (geoms[id]) {
        if (clear) {
          delete geoms[id].g2Instance;
          if (geoms[id].label && geoms[id].label.g2Instance) {
            if (geoms[id].label.updateProps) {
              geoms[id].label.props = geoms[id].label.updateProps;
            }
            delete geoms[id].label.g2Instance;
          }
        }
        if (geoms[id].updateProps) geoms[id].props = geoms[id].updateProps;
      }
    }
  },
  mergeGuide: function mergeGuide(guide, clear) {
    if (guide == null) return;

    var guides = guide.elements;
    for (var id in guides) {
      if (guides[id]) {
        if (clear) {
          delete guides[id].g2Instance;
        }
        if (guides[id].updateProps) {
          guides[id].props = guides[id].updateProps;
        }
      }
    }
  },
  mergeView: function mergeView(view, clear) {
    if (!view) return;
    // merge self
    if (clear && view.g2Instance) {
      delete view.g2Instance;
    }
    if (view.updateProps) {
      view.props = view.updateProps;
    }

    this.mergeCoord(view, clear);
    this.mergeAxises(view, clear);
    this.mergeGeoms(view.geoms, clear);
    this.mergeGuide(view.guide, clear);
  },
  mergeViews: function mergeViews(views, clear) {
    if (views == null) return;

    for (var id in views) {
      if (views[id]) {
        this.mergeView(views[id], clear);
      }
    }
  }
};

exports.default = iMerge;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Prop = exports.Util = undefined;

var _util = __webpack_require__(58);

var _util2 = _interopRequireDefault(_util);

var _prop = __webpack_require__(437);

var _prop2 = _interopRequireDefault(_prop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Util = _util2.default;
exports.Prop = _prop2.default;

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = Color;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return brighter; });
/* harmony export (immutable) */ __webpack_exports__["h"] = color;
/* harmony export (immutable) */ __webpack_exports__["b"] = rgbConvert;
/* harmony export (immutable) */ __webpack_exports__["g"] = rgb;
/* harmony export (immutable) */ __webpack_exports__["a"] = Rgb;
/* unused harmony export hslConvert */
/* harmony export (immutable) */ __webpack_exports__["f"] = hsl;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(90);


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Rgb, rgb, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Hsl, hsl, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = extend;
/* harmony default export */ __webpack_exports__["a"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = basis;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rgb__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__object__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__string__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constant__ = __webpack_require__(202);









/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__constant__["a" /* default */])(b)
      : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */]
      : t === "string" ? ((c = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]) : __WEBPACK_IMPORTED_MODULE_6__string__["a" /* default */])
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */] ? __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]
      : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date__["a" /* default */]
      : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array__["a" /* default */]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object__["a" /* default */]
      : __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */])(a, b);
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = basis;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(96);
/* unused harmony reexport interpolate */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_js__ = __webpack_require__(207);
/* unused harmony reexport interpolateArray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basis_js__ = __webpack_require__(93);
/* unused harmony reexport interpolateBasis */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__basisClosed_js__ = __webpack_require__(208);
/* unused harmony reexport interpolateBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__date_js__ = __webpack_require__(210);
/* unused harmony reexport interpolateDate */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__discrete_js__ = __webpack_require__(465);
/* unused harmony reexport interpolateDiscrete */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__hue_js__ = __webpack_require__(468);
/* unused harmony reexport interpolateHue */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__number_js__ = __webpack_require__(60);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_7__number_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__numberArray_js__ = __webpack_require__(95);
/* unused harmony reexport interpolateNumberArray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__object_js__ = __webpack_require__(211);
/* unused harmony reexport interpolateObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__round_js__ = __webpack_require__(472);
/* unused harmony reexport interpolateRound */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__string_js__ = __webpack_require__(213);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_11__string_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__transform_index_js__ = __webpack_require__(474);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_12__transform_index_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_12__transform_index_js__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__zoom_js__ = __webpack_require__(476);
/* unused harmony reexport interpolateZoom */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__rgb_js__ = __webpack_require__(212);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_14__rgb_js__["a"]; });
/* unused harmony reexport interpolateRgbBasis */
/* unused harmony reexport interpolateRgbBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__hsl_js__ = __webpack_require__(467);
/* unused harmony reexport interpolateHsl */
/* unused harmony reexport interpolateHslLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__lab_js__ = __webpack_require__(469);
/* unused harmony reexport interpolateLab */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__hcl_js__ = __webpack_require__(466);
/* unused harmony reexport interpolateHcl */
/* unused harmony reexport interpolateHclLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__cubehelix_js__ = __webpack_require__(464);
/* unused harmony reexport interpolateCubehelix */
/* unused harmony reexport interpolateCubehelixLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__piecewise_js__ = __webpack_require__(470);
/* unused harmony reexport piecewise */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__quantize_js__ = __webpack_require__(471);
/* unused harmony reexport quantize */























/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isNumberArray;
/* harmony default export */ __webpack_exports__["b"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rgb_js__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array_js__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date_js__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__object_js__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__string_js__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constant_js__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__numberArray_js__ = __webpack_require__(95);










/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__constant_js__["a" /* default */])(b)
      : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number_js__["a" /* default */]
      : t === "string" ? ((c = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb_js__["a" /* default */]) : __WEBPACK_IMPORTED_MODULE_6__string_js__["a" /* default */])
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */] ? __WEBPACK_IMPORTED_MODULE_1__rgb_js__["a" /* default */]
      : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date_js__["a" /* default */]
      : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__numberArray_js__["a" /* isNumberArray */])(b) ? __WEBPACK_IMPORTED_MODULE_8__numberArray_js__["b" /* default */]
      : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* genericArray */]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object_js__["a" /* default */]
      : __WEBPACK_IMPORTED_MODULE_4__number_js__["a" /* default */])(a, b);
});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespaces__ = __webpack_require__(98);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */].hasOwnProperty(prefix) ? {space: __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */][prefix], local: name} : name;
});


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["a"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return event; });
/* harmony export (immutable) */ __webpack_exports__["b"] = customEvent;
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["c"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function none() {}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_on__ = __webpack_require__(99);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var current = __WEBPACK_IMPORTED_MODULE_0__selection_on__["a" /* event */], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(104);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return __WEBPACK_IMPORTED_MODULE_0__timer_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return __WEBPACK_IMPORTED_MODULE_0__timer_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return __WEBPACK_IMPORTED_MODULE_0__timer_js__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__timeout_js__ = __webpack_require__(513);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return __WEBPACK_IMPORTED_MODULE_1__timeout_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__interval_js__ = __webpack_require__(512);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return __WEBPACK_IMPORTED_MODULE_2__interval_js__["a"]; });







/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = now;
/* harmony export (immutable) */ __webpack_exports__["d"] = Timer;
/* harmony export (immutable) */ __webpack_exports__["b"] = timer;
/* harmony export (immutable) */ __webpack_exports__["c"] = timerFlush;
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we鈥檝e set an alarm, if we haven鈥檛 already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter v5.1.0 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */

;(function (exports) {
    'use strict';

    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        }
        else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    function isValidListener (listener) {
        if (typeof listener === 'function' || listener instanceof RegExp) {
            return true
        } else if (listener && typeof listener === 'object') {
            return isValidListener(listener.listener)
        } else {
            return false
        }
    }

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) {
            throw new TypeError('listener must be a function');
        }

        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of its properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    }
                    else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        }
        else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        }
        else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        }
        else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i;
        var key;
        var response;

        for (key in listenersMap) {
            if (listenersMap.hasOwnProperty(key)) {
                listeners = listenersMap[key].slice(0);

                for (i = 0; i < listeners.length; i++) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        }
        else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return EventEmitter;
        }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module === 'object' && module.exports){
        module.exports = EventEmitter;
    }
    else {
        exports.EventEmitter = EventEmitter;
    }
}(this || {}));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var DEFAULT_Y = 0; // 榛樿鐨剏鐨勫€�

var each = __webpack_require__(2);

var ArrayUtil = {
  values: __webpack_require__(79)
};
module.exports = {
  /**
   * 瀵瑰簲鐨勭淮搴︽槸鍚﹀彲浠ヨ皟鏁�
   * @protected
   * @param  {String}  dimName 鍙互璋冩暣鐨勭淮搴� x,y
   * @return {Boolean} 鏄惁鍙互璋冩暣
   */
  isAdjust: function isAdjust(dimName) {
    return this.adjustNames.indexOf(dimName) >= 0;
  },

  /**
   * @protected
   * 鑾峰彇鍙皟鏁村害閲忓搴旂殑鍊�
   * @param  {Frame} mergeData 鏁版嵁
   * @return {Object} 鍊肩殑鏄犲皠
   */
  _getDimValues: function _getDimValues(mergeData) {
    var self = this;
    var valuesMap = {};
    var dims = [];

    if (self.xField && self.isAdjust('x')) {
      dims.push(self.xField);
    }

    if (self.yField && self.isAdjust('y')) {
      dims.push(self.yField);
    }

    each(dims, function (dim) {
      var values = ArrayUtil.values(mergeData, dim);
      values.sort(function (v1, v2) {
        return v1 - v2;
      });
      valuesMap[dim] = values;
    });

    if (!self.yField && self.isAdjust('y')) {
      // 鍙湁涓€缁寸殑鎯呭喌涓�,鍚屾椂璋冩暣y
      var dim = 'y';
      var values = [DEFAULT_Y, 1]; // 榛樿鍒嗗竷鍦▂杞寸殑 0.1 涓� 0.2 涔嬮棿

      valuesMap[dim] = values;
    }

    return valuesMap;
  },
  adjustData: function adjustData(dataArray, mergeData) {
    var self = this;

    var valuesMap = self._getDimValues(mergeData);

    each(dataArray, function (data, index) {
      // 閬嶅巻鎵€鏈夋暟鎹泦鍚�
      each(valuesMap, function (values, dim) {
        // 鏍规嵁涓嶅悓鐨勫害閲忓垎鍒皟鏁翠綅缃�
        self.adjustDim(dim, values, data, dataArray.length, index);
      });
    });
  },
  getAdjustRange: function getAdjustRange(dim, key, values) {
    var self = this;
    var index = values.indexOf(key);
    var length = values.length;
    var pre;
    var next;

    if (!self.yField && self.isAdjust('y')) {
      pre = 0;
      next = 1;
    } else if (length > 1) {
      pre = index === 0 ? values[0] : values[index - 1];
      next = index === length - 1 ? values[length - 1] : values[index + 1];

      if (index !== 0) {
        pre += (key - pre) / 2;
      } else {
        pre -= (next - key) / 2;
      }

      if (index !== length - 1) {
        next -= (next - key) / 2;
      } else {
        next += (key - values[length - 2]) / 2;
      }
    } else {
      pre = key === 0 ? 0 : key - 0.5;
      next = key === 0 ? 1 : key + 0.5;
    }

    return {
      pre: pre,
      next: next
    };
  },

  /**
   * 瀵规暟鎹繘琛屽垎缁�
   * @param  {Array} data 鏁版嵁
   * @param  {String} dim 鍒嗙粍鐨勫瓧娈�
   * @return {Object}  鍒嗙粍鐨勯敭鍊煎鏄犲皠
   */
  groupData: function groupData(data, dim) {
    var groups = {};
    each(data, function (record) {
      var value = record[dim];

      if (value === undefined) {
        value = record[dim] = DEFAULT_Y;
      }

      if (!groups[value]) {
        groups[value] = [];
      }

      groups[value].push(record);
    });
    return groups;
  }
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 棰滆壊璁＄畻鐨勮緟鍔╂柟娉�
 * @author dxq613@gmail.com
 */
var isNumber = __webpack_require__(11);

var isString = __webpack_require__(15);

var each = __webpack_require__(2); // const RGB_REG = /rgb\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;


var RGB_REG = /rgba?\(([\s.,0-9]+)\)/; // 鍒涘缓杈呭姪 tag 鍙栭鑹�

function createTmp() {
  var i = document.createElement('i');
  i.title = 'Web Colour Picker';
  i.style.display = 'none';
  document.body.appendChild(i);
  return i;
} // 鑾峰彇棰滆壊涔嬮棿鐨勬彃鍊�


function getValue(start, end, percent, index) {
  var value = start[index] + (end[index] - start[index]) * percent;
  return value;
} // 鏁扮粍杞崲鎴愰鑹�


function arr2rgb(arr) {
  return '#' + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
} // 灏嗘暟鍊间粠 0-255 杞崲鎴�16杩涘埗瀛楃涓�


function toHex(value) {
  value = Math.round(value);
  value = value.toString(16);

  if (value.length === 1) {
    value = '0' + value;
  }

  return value;
}

function calColor(colors, percent) {
  if (isNaN(percent) || !isNumber(percent) || percent < 0) {
    percent = 0;
  }

  if (percent > 1) {
    percent = 1;
  }

  var steps = colors.length - 1;
  var step = Math.floor(steps * percent);
  var left = steps * percent - step;
  var start = colors[step];
  var end = step === steps ? start : colors[step + 1];
  var rgb = arr2rgb([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);
  return rgb;
} // rgb 棰滆壊杞崲鎴愭暟缁�


function rgb2arr(str) {
  var arr = [];
  arr.push(parseInt(str.substr(1, 2), 16));
  arr.push(parseInt(str.substr(3, 2), 16));
  arr.push(parseInt(str.substr(5, 2), 16));
  return arr;
}

var colorCache = {};
var iEl = null;
var ColorUtil = {
  /**
   * 灏嗛鑹茶浆鎹㈠埌 rgb 鐨勬牸寮�
   * @param  {String} color 棰滆壊
   * @return {String} 灏嗛鑹茶浆鎹㈠埌 '#ffffff' 鐨勬牸寮�
   */
  toRGB: function toRGB(color) {
    // 濡傛灉宸茬粡鏄� rgb鐨勬牸寮�
    if (color[0] === '#' && color.length === 7) {
      return color;
    }

    if (!iEl) {
      // 闃叉闃叉鍦ㄩ〉澶存姤閿�
      iEl = createTmp();
    }

    var rst;

    if (colorCache[color]) {
      rst = colorCache[color];
    } else {
      iEl.style.color = color;
      rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
      var matchs = RGB_REG.exec(rst);
      var cArray = matchs[1].split(/\s*,\s*/);
      rst = arr2rgb(cArray);
      colorCache[color] = rst;
    }

    return rst;
  },
  rgb2arr: rgb2arr,

  /**
   * 鑾峰彇娓愬彉鍑芥暟
   * @param  {Array} colors 澶氫釜棰滆壊
   * @return {String} 棰滆壊鍊�
   */
  gradient: function gradient(colors) {
    var points = [];

    if (isString(colors)) {
      colors = colors.split('-');
    }

    each(colors, function (color) {
      if (color.indexOf('#') === -1) {
        color = ColorUtil.toRGB(color);
      }

      points.push(rgb2arr(color));
    });
    return function (percent) {
      return calColor(points, percent);
    };
  }
};
module.exports = ColorUtil;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = __webpack_require__(31),
    Group = _require.Group;

var Util = __webpack_require__(3);

var Grid =
/*#__PURE__*/
function (_Group) {
  _inheritsLoose(Grid, _Group);

  function Grid() {
    return _Group.apply(this, arguments) || this;
  }

  var _proto = Grid.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    // const cfg = super.getDefaultCfg();
    return {
      zIndex: 1,

      /**
       * 鏍呮牸绾跨殑绫诲瀷
       *  - line 涓嶅皝闂殑绾�
       *  - polygon 灏侀棴鐨勫杈瑰舰
       * @type {String}
       */
      type: 'line',

      /**
       * 绾跨殑鏍峰紡閰嶇疆
       * @type {Object}
       */
      lineStyle: null,

      /**
       * 绾块泦鍚堢殑閰嶇疆
       * @type {Array}
       */
      items: null,

      /**
       * 涓虹綉鏍艰缃氦鏇跨殑鑳屾櫙鑹诧紝鎸囧畾涓€涓€煎垯鍏堟覆鏌撳鏁板眰锛屼袱涓€煎垯浜ゆ浛娓叉煋
       * @type {String | Array}
       */
      alternateColor: null,
      matrix: null,

      /**
       * 鏄惁闅愯棌绗竴鏉＄綉鏍肩嚎锛岄粯璁や负 false
       * @type {Boolean}
       */
      hideFirstLine: false,

      /**
       * 鏄惁闅愯棌鏈€鍚庝竴鏉＄綉鏍肩嚎锛岄粯璁や负 false
       * @type {Boolean}
       */
      hideLastLine: false,

      /**
       * 0鍩虹嚎涓嶅湪杞寸嚎涓婃椂锛屾槸鍚﹀己璋�0鍩虹嚎
       * @type {Boolean}
       */
      hightLightZero: false,

      /**
       * 0鍩虹嚎鏍峰紡
       * @type {Object}
       */
      zeroLineStyle: {
        stroke: '#595959',
        lineDash: [0, 0]
      }
    };
  };

  _proto._renderUI = function _renderUI() {
    _Group.prototype._renderUI.call(this);

    this._drawLines();
  };

  _proto._drawLines = function _drawLines() {
    var self = this;
    var lineStyle = self.get('lineStyle');
    var items = self.get('items');

    if (items && items.length) {
      self._precessItems(items);

      self._drawGridLines(items, lineStyle);
    }
  };

  _proto._precessItems = function _precessItems(items) {
    var self = this;
    var preItem;
    Util.each(items, function (item, index) {
      if (preItem && self.get('alternateColor')) {
        self._drawAlternativeBg(item, preItem, index);
      }

      preItem = item;
    });
  };

  _proto._drawGridLines = function _drawGridLines(items, lineStyle) {
    var self = this;
    var type = this.get('type');
    var gridLine;
    var path;
    var cfg;
    var points;
    var itemsLength = items.length;

    if (type === 'line' || type === 'polygon') {
      Util.each(items, function (item, idx) {
        if (self.get('hideFirstLine') && idx === 0) {
          // 涓嶅睍绀虹涓€鏉＄綉鏍肩嚎
          return;
        }

        if (self.get('hideLastLine') && idx === itemsLength - 1) {
          // 涓嶅睍绀烘渶鍚庝竴鏉＄綉鏍肩嚎
          return;
        }

        points = item.points;
        path = [];

        if (type === 'line') {
          path.push(['M', points[0].x, points[0].y]);
          path.push(['L', points[points.length - 1].x, points[points.length - 1].y]);
        } else {
          Util.each(points, function (point, index) {
            if (index === 0) {
              path.push(['M', point.x, point.y]);
            } else {
              path.push(['L', point.x, point.y]);
            }
          });
        }

        if (self._drawZeroLine(type, idx)) {
          cfg = Util.mix({}, self.get('zeroLineStyle'), {
            path: path
          });
        } else {
          cfg = Util.mix({}, lineStyle, {
            path: path
          });
        }

        gridLine = self.addShape('path', {
          attrs: cfg
        });
        gridLine.name = 'axis-grid';
        gridLine._id = item._id;
        gridLine.set('coord', self.get('coord'));
        self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));
      });
    } else {
      Util.each(items, function (item, idx) {
        if (self.get('hideFirstLine') && idx === 0) {
          // 涓嶅睍绀虹涓€鏉＄綉鏍肩嚎
          return;
        }

        if (self.get('hideLastLine') && idx === itemsLength - 1) {
          // 涓嶅睍绀烘渶鍚庝竴鏉＄綉鏍肩嚎
          return;
        }

        points = item.points;
        path = [];
        Util.each(points, function (point, index) {
          var radius = point.radius;

          if (index === 0) {
            path.push(['M', point.x, point.y]);
          } else {
            path.push(['A', radius, radius, 0, 0, point.flag, point.x, point.y]);
          }
        });
        cfg = Util.mix({}, lineStyle, {
          path: path
        });
        gridLine = self.addShape('path', {
          attrs: cfg
        });
        gridLine.name = 'axis-grid';
        gridLine._id = item._id;
        gridLine.set('coord', self.get('coord'));
        self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));
      });
    }
  };

  _proto._drawZeroLine = function _drawZeroLine(type, idx) {
    var self = this;
    var tickValues = self.get('tickValues');

    if (type === 'line' && tickValues) {
      if (tickValues[idx] === 0 && self.get('hightLightZero')) {
        return true;
      }
    }

    return false;
  };

  _proto._drawAlternativeBg = function _drawAlternativeBg(item, preItem, index) {
    var self = this;
    var alternateColor = self.get('alternateColor');
    var attrs;
    var oddColor;
    var evenColor;

    if (Util.isString(alternateColor)) {
      oddColor = alternateColor;
    } else if (Util.isArray(alternateColor)) {
      oddColor = alternateColor[0];
      evenColor = alternateColor[1];
    }

    if (index % 2 === 0) {
      if (evenColor) {
        attrs = self._getBackItem(preItem.points, item.points, evenColor);
      }
    } else if (oddColor) {
      attrs = self._getBackItem(preItem.points, item.points, oddColor);
    }

    var shape = self.addShape('Path', {
      attrs: attrs
    });
    shape.name = 'axis-grid-rect';
    shape._id = item._id && item._id.replace('grid', 'grid-rect');
    shape.set('coord', self.get('coord'));
    self.get('appendInfo') && shape.setSilent('appendInfo', self.get('appendInfo'));
  };

  _proto._getBackItem = function _getBackItem(start, end, bgColor) {
    var path = [];
    var type = this.get('type');

    if (type === 'line') {
      path.push(['M', start[0].x, start[0].y]);
      path.push(['L', start[start.length - 1].x, start[start.length - 1].y]);
      path.push(['L', end[end.length - 1].x, end[end.length - 1].y]);
      path.push(['L', end[0].x, end[0].y]);
      path.push(['Z']);
    } else if (type === 'polygon') {
      Util.each(start, function (subItem, index) {
        if (index === 0) {
          path.push(['M', subItem.x, subItem.y]);
        } else {
          path.push(['L', subItem.x, subItem.y]);
        }
      });

      for (var i = end.length - 1; i >= 0; i--) {
        path.push(['L', end[i].x, end[i].y]);
      }

      path.push(['Z']);
    } else {
      var flag = start[0].flag;
      Util.each(start, function (subItem, index) {
        var radius = subItem.radius;

        if (index === 0) {
          path.push(['M', subItem.x, subItem.y]);
        } else {
          path.push(['A', radius, radius, 0, 0, subItem.flag, subItem.x, subItem.y]);
        }
      });

      for (var j = end.length - 1; j >= 0; j--) {
        var endSubItem = end[j];
        var endRadius = endSubItem.radius;

        if (j === end.length - 1) {
          path.push(['M', endSubItem.x, endSubItem.y]);
        } else {
          path.push(['A', endRadius, endRadius, 0, 0, flag === 1 ? 0 : 1, endSubItem.x, endSubItem.y]);
        }
      }
    }

    return {
      fill: bgColor,
      path: path
    };
  };

  return Grid;
}(Group);

module.exports = Grid;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(3);

module.exports = {
  getFirstScale: function getFirstScale(scales) {
    var firstScale;
    Util.each(scales, function (scale) {
      if (scale) {
        firstScale = scale;
        return false;
      }
    });
    return firstScale;
  }
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var DomUtil = Util.DomUtil;

var Component = __webpack_require__(36);

var positionAdjust = __webpack_require__(254);

var spirialAdjust = __webpack_require__(255);

var bboxAdjust = __webpack_require__(253);

var LAYOUTS = {
  scatter: positionAdjust,
  map: spirialAdjust,
  treemap: bboxAdjust
};

var Label =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Label, _Component);

  function Label() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Label.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Component.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'label',

      /**
       * label绫诲瀷
       * @type {(String)}
       */
      type: 'default',

      /**
       * 榛樿鏂囨湰鏍峰紡
       * @type {Array}
       */
      textStyle: null,

      /**
       * 鏂囨湰鏄剧ず鏍煎紡鍖栧洖璋冨嚱鏁�
       * @type {Function}
       */
      formatter: null,

      /**
       * 鏄剧ず鐨勬枃鏈泦鍚�
       * @type {Array}
       */
      items: null,

      /**
       * 鏄惁浣跨敤html娓叉煋label
       * @type {String}
       */
      useHtml: false,

      /**
       * html 娓叉煋鏃剁敤鐨勫鍣ㄧ殑妯℃澘锛屽繀椤诲瓨鍦� class = "g-labels"
       * @type {String}
       */
      containerTpl: '<div class="g-labels" style="position:absolute;top:0;left:0;"></div>',

      /**
       * html 娓叉煋鏃跺崟涓� label 鐨勬ā鏉匡紝蹇呴』瀛樺湪 class = "g-label"
       * @type {String}
       */
      itemTpl: '<div class="g-label" style="position:absolute;">{text}</div>',

      /**
       * label鐗靛紩绾垮畾涔�
       * @type {String || Object}
       */
      labelLine: false,

      /**
       * label鐗靛紩绾垮鍣�
       * @type Object
       */
      lineGroup: null,

      /**
       * 闇€娣诲姞label鐨剆hape
       * @type Object
       */
      shapes: null,

      /**
       * 榛樿涓簍rue銆備负false鏃舵寚瀹氱洿鎺ョ敤items娓叉煋鏂囨湰锛屼笉杩涜config
       * @type Object
       */
      config: true,

      /**
       * 鏄惁杩涜鎷惧彇
       * @type Object
       */
      capture: true
    });
  }
  /*
   * 娓呯┖label瀹瑰櫒
   */
  ;

  _proto.clear = function clear() {
    var group = this.get('group');
    var container = this.get('container');

    if (group && !group.get('destroyed')) {
      group.clear();
    }

    if (container) {
      container.innerHTML = '';
    }

    _Component.prototype.clear.call(this);
  }
  /**
   * 閿€姣乬roup
   */
  ;

  _proto.destroy = function destroy() {
    var group = this.get('group');
    var container = this.get('container');

    if (!group.destroy) {
      group.destroy();
    }

    if (container) {
      container.parentNode && container.parentNode.removeChild(container);
    }

    _Component.prototype.destroy.call(this); // 瑕佹渶鍚庤皟鐢� super.destroy 鍚﹀垯 get 灞炴€т細鏃犳晥

  }
  /**
   * label缁樺埗鍏ㄨ繃绋�
   */
  ;

  _proto.render = function render() {
    this.clear();

    this._init();

    this.beforeDraw();
    this.draw();
    this.afterDraw();
  };

  _proto._dryDraw = function _dryDraw() {
    var self = this;
    var items = self.get('items');
    var children = self.getLabels();
    var count = children.length;
    Util.each(items, function (item, index) {
      if (index < count) {
        var label = children[index];
        self.changeLabel(label, item);
      } else {
        var labelShape = self._addLabel(item, index);

        if (labelShape) {
          labelShape._id = item._id;
          labelShape.set('coord', item.coord);
        }
      }
    });

    for (var i = count - 1; i >= items.length; i--) {
      children[i].remove();
    }

    self._adjustLabels();

    if (self.get('labelLine') || !self.get('config')) {
      self.drawLines();
    }
  }
  /**
   * 鏇存柊label
   * 1. 灏唅tems涓巊roup涓殑children瀵规瘮锛屾洿鏂�/鏂板/鍒犻櫎labels
   * 2. labels甯冨眬浼樺寲
   * 3. 鐢籰abel杩炴帴绾�
   * 4. 缁樺埗鍒扮敾甯�
   */
  ;

  _proto.draw = function draw() {
    this._dryDraw();

    this.get('canvas').draw();
  }
  /*
   * 鏇存柊label
   * oldLabel shape鎴杔abel dom
   * newLabel label data
   * index items涓殑涓嬫爣
   */
  ;

  _proto.changeLabel = function changeLabel(oldLabel, newLabel) {
    if (!oldLabel) {
      return;
    }

    if (oldLabel.tagName) {
      var node = this._createDom(newLabel);

      oldLabel.innerHTML = node.innerHTML;

      this._setCustomPosition(newLabel, oldLabel);
    } else {
      oldLabel._id = newLabel._id;
      oldLabel.attr('text', newLabel.text);

      if (oldLabel.attr('x') !== newLabel.x || oldLabel.attr('y') !== newLabel.y) {
        oldLabel.resetMatrix();

        if (newLabel.textStyle.rotate) {
          oldLabel.rotateAtStart(newLabel.textStyle.rotate);
          delete newLabel.textStyle.rotate;
        }

        oldLabel.attr(newLabel);
      }
    }
  }
  /**
   * 鏄剧ずlabel
   */
  ;

  _proto.show = function show() {
    var group = this.get('group');
    var container = this.get('container');

    if (group) {
      group.show();
    }

    if (container) {
      container.style.opacity = 1;
    }
  }
  /**
   * 闅愯棌label
   */
  ;

  _proto.hide = function hide() {
    var group = this.get('group');
    var container = this.get('container');

    if (group) {
      group.hide();
    }

    if (container) {
      container.style.opacity = 0;
    }
  }
  /**
   * 鐢籰abel杩炴帴绾�
   */
  ;

  _proto.drawLines = function drawLines() {
    var self = this;
    var lineStyle = self.get('labelLine');

    if (typeof lineStyle === 'boolean') {
      self.set('labelLine', {});
    }

    var lineGroup = self.get('lineGroup');

    if (!lineGroup || lineGroup.get('destroyed')) {
      lineGroup = self.get('group').addGroup({
        elCls: 'x-line-group'
      });
      self.set('lineGroup', lineGroup);
    } else {
      lineGroup.clear();
    }

    Util.each(self.get('items'), function (label) {
      self.lineToLabel(label, lineGroup);
    });
  };

  _proto.lineToLabel = function lineToLabel(label, lineGroup) {
    var self = this;

    if (!self.get('config') && !label.labelLine) {
      return;
    }

    var lineStyle = label.labelLine || self.get('labelLine');
    var capture = typeof label.capture === 'undefined' ? self.get('capture') : label.capture;
    var path = lineStyle.path;

    if (path && Util.isFunction(lineStyle.path)) {
      path = lineStyle.path(label);
    }

    if (!path) {
      var start = label.start || {
        x: label.x - label._offset.x,
        y: label.y - label._offset.y
      };
      path = [['M', start.x, start.y], ['L', label.x, label.y]];
    }

    var stroke = label.color;

    if (!stroke) {
      if (label.textStyle && label.textStyle.fill) {
        stroke = label.textStyle.fill;
      } else {
        stroke = '#000';
      }
    }

    var lineShape = lineGroup.addShape('path', {
      attrs: Util.mix({
        path: path,
        fill: null,
        stroke: stroke
      }, lineStyle),
      capture: capture
    }); // label 瀵瑰簲绾跨殑鍔ㄧ敾鍏抽棴

    lineShape.name = self.get('name'); // generate labelLine id according to label id

    lineShape._id = label._id && label._id.replace('glabel', 'glabelline');
    lineShape.set('coord', self.get('coord'));
  } // 鏍规嵁type瀵筶abel甯冨眬
  ;

  _proto._adjustLabels = function _adjustLabels() {
    var self = this;
    var type = self.get('type');
    var labels = self.getLabels();
    var shapes = self.get('shapes');
    var layout = LAYOUTS[type];

    if (type === 'default' || !layout) {
      return;
    }

    layout(labels, shapes);
  }
  /**
   * 鑾峰彇褰撳墠鎵€鏈塴abel瀹炰緥
   * @return {Array} 褰撳墠label瀹炰緥
   */
  ;

  _proto.getLabels = function getLabels() {
    var container = this.get('container');

    if (container) {
      return Util.toArray(container.childNodes);
    }

    return this.get('group').get('children');
  } // 鍏堣绠條abel鐨勬墍鏈夐厤缃」锛岀劧鍚庣敓鎴恖abel瀹炰緥
  ;

  _proto._addLabel = function _addLabel(item, index) {
    var cfg = item;

    if (this.get('config')) {
      cfg = this._getLabelCfg(item, index);
    }

    return this._createText(cfg);
  };

  _proto._getLabelCfg = function _getLabelCfg(item, index) {
    var textStyle = this.get('textStyle') || {};
    var formatter = this.get('formatter');
    var htmlTemplate = this.get('htmlTemplate');

    if (!Util.isObject(item)) {
      var tmp = item;
      item = {};
      item.text = tmp;
    }

    if (Util.isFunction(textStyle)) {
      textStyle = textStyle(item.text, item, index);
    }

    if (formatter) {
      item.text = formatter(item.text, item, index);
    }

    if (htmlTemplate) {
      item.useHtml = true;

      if (Util.isFunction(htmlTemplate)) {
        item.text = htmlTemplate(item.text, item, index);
      }
    }

    if (Util.isNil(item.text)) {
      item.text = '';
    }

    item.text = item.text + ''; // ? 涓轰粈涔堣浆鎹负瀛楃涓�

    var cfg = Util.mix({}, item, {
      textStyle: textStyle
    }, {
      x: item.x || 0,
      y: item.y || 0
    });
    return cfg;
  }
  /**
   * label鍒濆鍖栵紝涓昏閽堝html瀹瑰櫒
   */
  ;

  _proto._init = function _init() {
    if (!this.get('group')) {
      var group = this.get('canvas').addGroup({
        id: 'label-group'
      });
      this.set('group', group);
    }
  };

  _proto.initHtmlContainer = function initHtmlContainer() {
    var container = this.get('container');

    if (!container) {
      var containerTpl = this.get('containerTpl');
      var wrapper = this.get('canvas').get('el').parentNode;
      container = DomUtil.createDom(containerTpl);
      wrapper.style.position = 'relative';
      wrapper.appendChild(container);
      this.set('container', container);
    } else if (Util.isString(container)) {
      container = document.getElementById(container);

      if (container) {
        this.set('container', container);
      }
    }

    return container;
  } // 鍒唄tml dom鍜孏 shape涓ょ鎯呭喌鐢熸垚label瀹炰緥
  ;

  _proto._createText = function _createText(config) {
    // @2018-11-29 by blue.lb 杩欓噷鐢变簬浣跨敤delete瀵艰嚧涔嬪悗鐨勯厤缃棤娉曡幏鍙栧埌point鍜宺otate锛屽嚭鐜伴棶棰橈紝娣辨嫹璐濅竴娆℃瘮杈冨ソ
    var cfg = Util.deepMix({}, config);
    var container = this.get('container');
    var capture = typeof cfg.capture === 'undefined' ? this.get('capture') : cfg.capture;
    var labelShape;

    if (cfg.useHtml || cfg.htmlTemplate) {
      if (!container) {
        container = this.initHtmlContainer();
      }

      var node = this._createDom(cfg);

      container.appendChild(node);

      this._setCustomPosition(cfg, node);
    } else {
      var name = this.get('name');
      var origin = cfg.point;
      var group = this.get('group');
      delete cfg.point; // 涓存椂瑙ｅ喅锛屽惁鍒欏奖鍝嶅姩鐢�

      var rotate = cfg.rotate; // textStyle涓殑rotate铏界劧鍙互姝ｅ父鐢诲嚭锛屼絾鏄湪鍋氬姩鐢荤殑鏃跺€欏彲鑳戒細瀵艰嚧鍔ㄧ敾寮傚父銆傜Щ鍑猴紝鍦ㄥ畾涔夊ソshape鍚庨€氳繃transform瀹炵幇鏁堟灉銆�

      if (cfg.textStyle) {
        if (cfg.textStyle.rotate) {
          rotate = cfg.textStyle.rotate;
          delete cfg.textStyle.rotate;
        }

        cfg = Util.mix({
          x: cfg.x,
          y: cfg.y,
          textAlign: cfg.textAlign,
          text: cfg.text
        }, cfg.textStyle);
      }

      labelShape = group.addShape('text', {
        attrs: cfg,
        capture: capture
      });

      if (rotate) {
        // rotate鏄敤瑙掑害瀹氫箟鐨勶紝杞崲涓哄姬搴�
        if (Math.abs(rotate) > Math.PI * 2) {
          rotate = rotate / 180 * Math.PI;
        }

        labelShape.transform([['t', -cfg.x, -cfg.y], ['r', rotate], ['t', cfg.x, cfg.y]]);
      }

      labelShape.setSilent('origin', origin || cfg);
      labelShape.name = name; // 鐢ㄤ簬浜嬩欢鏍囨敞

      this.get('appendInfo') && labelShape.setSilent('appendInfo', this.get('appendInfo'));
      return labelShape;
    }
  };

  _proto._createDom = function _createDom(cfg) {
    var itemTpl = this.get('itemTpl');
    var str = Util.substitute(itemTpl, {
      text: cfg.text
    });
    return DomUtil.createDom(str);
  } // 鏍规嵁鏂囨湰瀵归綈鏂瑰紡纭畾dom浣嶇疆
  ;

  _proto._setCustomPosition = function _setCustomPosition(cfg, htmlDom) {
    var textAlign = cfg.textAlign || 'left';
    var top = cfg.y;
    var left = cfg.x;
    var width = DomUtil.getOuterWidth(htmlDom);
    var height = DomUtil.getOuterHeight(htmlDom);
    top = top - height / 2;

    if (textAlign === 'center') {
      left = left - width / 2;
    } else if (textAlign === 'right') {
      left = left - width;
    }

    htmlDom.style.top = parseInt(top, 10) + 'px';
    htmlDom.style.left = parseInt(left, 10) + 'px';
  };

  return Label;
}(Component);

module.exports = Label;

/***/ }),
/* 111 */
/***/ (function(module, exports) {

var Greedy =
/*#__PURE__*/
function () {
  function Greedy() {
    this.bitmap = [];
  }

  var _proto = Greedy.prototype;

  _proto.hasGap = function hasGap(bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.floor(bbox.minX);
    var maxX = Math.ceil(bbox.maxX);
    var minY = Math.floor(bbox.minY);
    var maxY = Math.ceil(bbox.maxY) - 1;

    for (var i = minX; i < maxX; i++) {
      if (!bitmap[i]) {
        bitmap[i] = [];
        continue;
      }

      if (i === minX || i === maxX - 1) {
        for (var j = minY; j <= maxY; j++) {
          if (bitmap[i][j]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i][minY] || bitmap[i][maxY]) {
          hasGap = false;
          break;
        }
      }
    }

    return hasGap;
  };

  _proto.fillGap = function fillGap(bbox) {
    var bitmap = this.bitmap;
    var minX = Math.floor(bbox.minX);
    var maxX = Math.ceil(bbox.maxX) - 1;
    var minY = Math.floor(bbox.minY);
    var maxY = Math.ceil(bbox.maxY) - 1;

    for (var i = minX; i <= maxX; i++) {
      for (var j = minY; j < maxY; j += 8) {
        if (!bitmap[i]) {
          bitmap[i] = [];
        }

        bitmap[i][j] = true;
      }

      bitmap[i][maxY] = true;
    }

    for (var _i = minY; _i <= maxY; _i++) {
      bitmap[minX][_i] = true;
      bitmap[maxX][_i] = true;
    }
  };

  return Greedy;
}();

module.exports = Greedy;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Component = __webpack_require__(36);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var Legend =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Legend, _Component);

  var _proto = Legend.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      /**
       * Group 瀹瑰櫒
       * @type {Object}
       */
      container: null,

      /**
       * 鍥句緥鏍囬閰嶇疆
       * @type {Object}
       */
      title: null,

      /**
       * 鍥句緥椤规枃鏈牸寮忓寲
       * @type {Function}
       */
      formatter: null,

      /**
       * 榧犳爣 hover 鍒板浘渚嬩笂鐨勯粯璁や氦浜掓槸鍚﹀紑鍚�
       * @type {Boolean}
       */
      hoverable: true,

      /**
       * TODO锛歳ename
       * 鍥句緥鏍囬璺濈鍥句緥椤圭殑璺濈
       * @type {Number}
       */
      titleGap: 15,

      /**
       * legend 鐩稿浜� container 鐨勪綅缃�
       * @type {Array}
       */
      position: [0, 0],

      /**
       * legend 鍦� position 浣嶇疆涓婄殑鍋忕Щ閲�
       * @type {Array}
       */
      offset: [0, 0],

      /**
       * legend 鍦� position 浣嶇疆涓婃部 x 杞寸殑鍋忕Щ閲忋€傝嫢鍚屾椂璁剧疆浜� offset 鍜� offsetX锛� 浠� offsetX 涓哄噯
       * @type {Number}
       */
      offsetX: null,

      /**
       * legend 鍦� position 浣嶇疆涓婃部 y 杞寸殑鍋忕Щ閲忋€傝嫢鍚屾椂璁剧疆浜� offset 鍜� offsetY锛� 浠� offsetY 涓哄噯
       * @type {Number}
       */
      offsetY: null
    };
  };

  function Legend(cfg) {
    var _this;

    _this = _Component.call(this, cfg) || this;

    _this._init();

    _this.beforeRender();

    _this.render();

    _this._adjustPositionOffset();

    _this._bindEvents();

    return _this;
  }

  _proto._init = function _init() {
    var group = this.get('group');
    var container = this.get('container');
    this.set('canvas', container.get('canvas'));
    var position = this.get('position');
    if (!group) group = container.addGroup({
      x: 0 - position[0],
      y: 0 - position[1]
    });
    this.set('group', group);
  };

  _proto._adjustPositionOffset = function _adjustPositionOffset() {
    var position = this.get('position');
    var offset = this.get('offset');
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');

    if (!Util.isArray(offset)) {
      var layout = this.get('layout');
      offset = layout === 'vertical' ? [offset, 0] : [0, offset];
    }

    if (offsetX) offset[0] = offsetX;
    if (offsetY) offset[1] = offsetY;
    var bbox = this.get('group').getBBox();
    this.move(-bbox.minX + position[0] + offset[0], -bbox.minY + position[1] + offset[1]);
  };

  _proto.beforeRender = function beforeRender() {
    var group = this.get('group');
    var itemsGroup = group.addGroup();
    this.set('itemsGroup', itemsGroup);
  };

  _proto.render = function render() {
    this._renderTitle();
  } // render the title of the legend
  ;

  _proto._renderTitle = function _renderTitle() {
    var title = this.get('title');
    var titleGap = this.get('titleGap');
    titleGap = titleGap || 0;

    if (title && title.text) {
      var group = this.get('group');
      var titleShape = group.addShape('text', {
        attrs: Util.mix({
          x: 0,
          y: 0 - titleGap,
          fill: '#333',
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        }, title)
      });
      titleShape.name = 'legend-title';
      this.get('appendInfo') && titleShape.setSilent('appendInfo', this.get('appendInfo'));
      this.set('titleShape', titleShape);
    }
  } // return the count of checked items
  ;

  _proto.getCheckedCount = function getCheckedCount() {
    var itemsGroup = this.get('itemsGroup');
    var items = itemsGroup.get('children');
    var checkedArr = Util.filter(items, function (item) {
      return item.get('checked');
    });
    return checkedArr.length;
  } // set items for the legend
  ;

  _proto.setItems = function setItems(items) {
    this.set('items', items);
    this.clear();
    this.render();
  } // add an item into the legend
  ;

  _proto.addItem = function addItem(item) {
    var items = this.get('items');
    items.push(item);
    this.clear();
    this.render();
  } // clear all the items of the legend
  ;

  _proto.clear = function clear() {
    var itemsGroup = this.get('itemsGroup');
    itemsGroup.clear();
    var group = this.get('group');
    group.clear();
    this.beforeRender();
  } // destroy the legend
  ;

  _proto.destroy = function destroy() {
    var group = this.get('group');
    group && group.destroy();
    this._attrs = {};
    this.removeAllListeners();

    _Component.prototype.destroy.call(this); // 瑕佹渶鍚庤皟鐢� super.destroy 鍚﹀垯 get 灞炴€т細鏃犳晥

  } // return the width of the legend
  ;

  _proto.getWidth = function getWidth() {
    var bbox = this.get('group').getBBox();
    return bbox.width;
  } // return the height of the legend
  ;

  _proto.getHeight = function getHeight() {
    var bbox = this.get('group').getBBox();
    return bbox.height;
  };

  _proto.move = function move(x, y) {
    this.get('group').move(x, y);
  };

  _proto.draw = function draw() {
    this.get('canvas').draw();
  };

  return Legend;
}(Component);

module.exports = Legend;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Category = __webpack_require__(114);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var DomUtil = Util.DomUtil;
var Group = Util.Group;
var CONTAINER_CLASS = 'g2-legend';
var TITLE_CLASS = 'g2-legend-title';
var LIST_CLASS = 'g2-legend-list';
var ITEM_CLASS = 'g2-legend-list-item';
var TEXT_CLASS = 'g2-legend-text';
var MARKER_CLASS = 'g2-legend-marker'; // find a dom node from the chidren of the node with className.

function findNodeByClass(node, className) {
  return node.getElementsByClassName(className)[0];
}

function getParentNode(node, className) {
  var nodeClass = node.className;

  if (Util.isNil(nodeClass)) {
    return node;
  }

  nodeClass = nodeClass.split(' ');

  if (nodeClass.indexOf(className) > -1) {
    return node;
  }

  if (node.parentNode) {
    if (node.parentNode.className === CONTAINER_CLASS) {
      return node.parentNode;
    }

    return getParentNode(node.parentNode, className);
  }

  return null;
}

function findItem(items, refer) {
  var rst = null;
  var value = refer instanceof Group ? refer.get('value') : refer;
  Util.each(items, function (item) {
    if (item.value === value) {
      rst = item;
      return false;
    }
  });
  return rst;
}

var CatHtml =
/*#__PURE__*/
function (_Category) {
  _inheritsLoose(CatHtml, _Category);

  function CatHtml() {
    return _Category.apply(this, arguments) || this;
  }

  var _proto = CatHtml.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Category.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * type 鏍囪瘑
       * @type {String}
       */
      type: 'category-legend',

      /**
       * html 瀹瑰櫒
       * @type {DOM}
       */
      container: null,

      /**
       * 浣跨敤html鏃剁殑澶栧眰妯℃澘
       * @type {String}
       */
      containerTpl: '<div class="' + CONTAINER_CLASS + '">' + '<h4 class="' + TITLE_CLASS + '"></h4>' + '<ul class="' + LIST_CLASS + '"></ul>' + '</div>',

      /**
       * html 妯℃澘
       * @type {String|Function}
       */
      itemTpl: '<li class="' + ITEM_CLASS + ' item-{index} {checked}" data-color="{originColor}" data-value="{originValue}">' + '<i class="' + MARKER_CLASS + '" style="background-color:{color};"></i>' + '<span class="' + TEXT_CLASS + '">{value}</span></li>',

      /**
       * html style
       * @type {Attrs}
       */
      legendStyle: {},

      /**
       * 鍥句緥鏂囧瓧鏍峰紡
       * @type {ATTRS}
       */
      textStyle: {
        fill: '#333',
        fontSize: 12,
        textAlign: 'middle',
        textBaseline: 'top',
        fontFamily: FONT_FAMILY
      },

      /**
       * 褰撴枃鏈お闀挎椂鏄惁杩涜缂╃暐
       * @type {Boolean}
       */
      abridgeText: false,

      /**
       * abridgeText 涓� true 鏃讹紝榧犳爣鏀剧疆鍦� item 涓婃椂鏄剧ず鍏ㄧО鐨勬偓娴� div 鐨� html 妯℃澘
       * @type {String}
       */
      tipTpl: '<div class="textTip"></div>',

      /**
       * abridgeText 涓� true 鏃讹紝榧犳爣鏀剧疆鍦� item 涓婃椂鏄剧ず鍏ㄧО鐨勬偓娴� div 鐨勬牱寮�
       * @type {Attrs}
       */
      tipStyle: {
        display: 'none',
        fontSize: '12px',
        backgroundColor: '#fff',
        position: 'absolute',
        width: 'auto',
        height: 'auto',
        padding: '3px',
        boxShadow: '2px 2px 5px #888'
      },

      /**
       * useHtml 涓� true 鏃剁敓鏁堬紝鐢ㄤ簬鑷姩瀹氫綅
       * @type {[type]}
       */
      autoPosition: true
    });
  };

  _proto._init = function _init() {
    return;
  };

  _proto.beforeRender = function beforeRender() {
    return;
  };

  _proto.render = function render() {
    this._renderHTML();
  } // user interaction
  ;

  _proto._bindEvents = function _bindEvents() {
    var _this = this;

    var legendWrapper = this.get('legendWrapper');
    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);

    if (this.get('hoverable')) {
      itemListDom.onmousemove = function (ev) {
        return _this._onMousemove(ev);
      };

      itemListDom.onmouseout = function (ev) {
        return _this._onMouseleave(ev);
      };
    }

    if (this.get('clickable')) {
      itemListDom.onclick = function (ev) {
        return _this._onClick(ev);
      };
    }
  } // mouse move listener of an item
  // when mouse over an item, reduce the opacity of the other items.
  ;

  _proto._onMousemove = function _onMousemove(ev) {
    var items = this.get('items');
    var target = ev.target;
    var targetClass = target.className;
    targetClass = targetClass.split(' ');

    if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {
      return;
    }

    var parentDom = getParentNode(target, ITEM_CLASS);
    var hoveredItem = findItem(items, parentDom.getAttribute('data-value'));

    if (hoveredItem) {
      // change the opacity of other items
      this.deactivate();
      this.activate(parentDom.getAttribute('data-value'));
      this.emit('itemhover', {
        item: hoveredItem,
        currentTarget: parentDom,
        checked: hoveredItem.checked
      });
    } else if (!hoveredItem) {
      // restore the opacity of all the items
      this.deactivate();
      this.emit('itemunhover', ev);
    }

    return;
  } // mouse leave listener of an item
  ;

  _proto._onMouseleave = function _onMouseleave(ev) {
    // restore the opacity of all the items when mouse leave
    this.deactivate();
    this.emit('itemunhover', ev);
    return;
  } // the click listener of an item
  ;

  _proto._onClick = function _onClick(ev) {
    var _this2 = this;

    var legendWrapper = this.get('legendWrapper');
    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
    var unCheckedColor = this.get('unCheckColor');
    var items = this.get('items');
    var mode = this.get('selectedMode');
    var childNodes = itemListDom.childNodes;
    var target = ev.target;
    var targetClass = target.className;
    targetClass = targetClass.split(' ');

    if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {
      return;
    }

    var parentDom = getParentNode(target, ITEM_CLASS);
    var textDom = findNodeByClass(parentDom, TEXT_CLASS);
    var markerDom = findNodeByClass(parentDom, MARKER_CLASS);
    var clickedItem = findItem(items, parentDom.getAttribute('data-value'));

    if (!clickedItem) {
      return;
    }

    var domClass = parentDom.className;
    var originColor = parentDom.getAttribute('data-color');

    if (mode === 'single') {
      // 鍗曢€夋ā寮�
      // update checked status
      clickedItem.checked = true; // 鍏朵粬鍥句緥椤瑰叏閮ㄧ疆鐏�

      Util.each(childNodes, function (child) {
        if (child !== parentDom) {
          var childMarkerDom = findNodeByClass(child, MARKER_CLASS);
          childMarkerDom.style.backgroundColor = unCheckedColor;
          child.className = child.className.replace('checked', 'unChecked');
          child.style.color = unCheckedColor;
          var childItem = findItem(items, child.getAttribute('data-value'));
          childItem.checked = false;
        } else {
          if (textDom) {
            textDom.style.color = _this2.get('textStyle').fill;
          }

          if (markerDom) {
            markerDom.style.backgroundColor = originColor;
          }

          parentDom.className = domClass.replace('unChecked', 'checked');
        }
      });
    } else {
      // 娣峰悎妯″紡
      var clickedItemChecked = domClass.indexOf('checked') !== -1; // domClass.includes('checked');

      var count = 0;
      Util.each(childNodes, function (child) {
        if (child.className.indexOf('checked') !== -1) {
          // .includes('checked')
          count++;
        }
      });

      if (!this.get('allowAllCanceled') && clickedItemChecked && count === 1) {
        this.emit('clicklastitem', {
          item: clickedItem,
          currentTarget: parentDom,
          checked: mode === 'single' ? true : clickedItem.checked
        });
        return;
      } // 鍦ㄥ垽鏂渶鍚庝竴涓浘渚嬪悗鍐嶆洿鏂癱hecked鐘舵€侊紝闃叉鐐瑰嚮鏈€鍚庝竴涓浘渚媔tem鏃跺浘渚嬫牱寮忔病鏈夊彉鍖栦絾鏄痗hecked鐘舵€佹敼鍙樹簡 fix #422


      clickedItem.checked = !clickedItem.checked;

      if (clickedItemChecked) {
        if (markerDom) {
          markerDom.style.backgroundColor = unCheckedColor;
        }

        parentDom.className = domClass.replace('checked', 'unChecked');
        parentDom.style.color = unCheckedColor;
      } else {
        if (markerDom) {
          markerDom.style.backgroundColor = originColor;
        }

        parentDom.className = domClass.replace('unChecked', 'checked');
        parentDom.style.color = this.get('textStyle').fill;
      }
    }

    this.emit('itemclick', {
      item: clickedItem,
      currentTarget: parentDom,
      checked: mode === 'single' ? true : clickedItem.checked
    });
    return;
  } // activate an item by reduce the opacity of other items.
  // it is reserved for bi-direction interaction between charts / graph and legend
  ;

  _proto.activate = function activate(value) {
    var _this3 = this;

    var self = this;
    var items = self.get('items');
    var item = findItem(items, value);
    var legendWrapper = self.get('legendWrapper');
    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
    var childNodes = itemListDom.childNodes;
    childNodes.forEach(function (child) {
      var childMarkerDom = findNodeByClass(child, MARKER_CLASS);
      var childItem = findItem(items, child.getAttribute('data-value'));

      if (_this3.get('highlight')) {
        if (childItem === item && childItem.checked) {
          childMarkerDom.style.border = '1px solid #333';
          return;
        }
      } else {
        if (childItem === item) {
          childMarkerDom.style.opacity = self.get('activeOpacity');
        } else {
          if (childItem.checked) childMarkerDom.style.opacity = self.get('inactiveOpacity');
        }
      } // if (childItem !== item && childItem.checked) {
      //   if (this.get('highlight')) {
      //     childMarkerDom.style.border = '1px solid #fff';
      //   } else childMarkerDom.style.opacity = 0.5;
      // } else {
      //   if (this.get('highlight')) {
      //     childMarkerDom.style.border = '1px solid #333';
      //   } else childMarkerDom.style.opacity = 1;
      // }

    });
    return;
  } // restore the opacity of items
  // it is reserved for bi-direction interaction between charts / graph and legend
  ;

  _proto.deactivate = function deactivate() {
    var _this4 = this;

    var self = this;
    var legendWrapper = self.get('legendWrapper');
    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
    var childNodes = itemListDom.childNodes;
    childNodes.forEach(function (child) {
      var childMarkerDom = findNodeByClass(child, MARKER_CLASS);

      if (_this4.get('highlight')) {
        childMarkerDom.style.border = '1px solid #fff';
      } else {
        childMarkerDom.style.opacity = self.get('inactiveOpacity');
      }
    });
    return;
  };

  _proto._renderHTML = function _renderHTML() {
    var _this5 = this;

    // const canvas = this.get('canvas');
    var container = this.get('container'); // const outterNode = container.parentNode;

    var title = this.get('title');
    var containerTpl = this.get('containerTpl');
    var legendWrapper = DomUtil.createDom(containerTpl);
    var titleDom = findNodeByClass(legendWrapper, TITLE_CLASS);
    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS); // ul

    var unCheckedColor = this.get('unCheckColor');
    var LEGEND_STYLE = Util.deepMix({}, {
      CONTAINER_CLASS: {
        height: 'auto',
        width: 'auto',
        position: 'absolute',
        overflowY: 'auto',
        fontSize: '12px',
        fontFamily: FONT_FAMILY,
        lineHeight: '20px',
        color: '#8C8C8C'
      },
      TITLE_CLASS: {
        marginBottom: this.get('titleGap') + 'px',
        fontSize: '12px',
        color: '#333',
        // 榛樿鏍峰紡
        textBaseline: 'middle',
        fontFamily: FONT_FAMILY
      },
      LIST_CLASS: {
        listStyleType: 'none',
        margin: 0,
        padding: 0,
        textAlign: 'center'
      },
      LIST_ITEM_CLASS: {
        cursor: 'pointer',
        marginBottom: '5px',
        marginRight: '24px'
      },
      MARKER_CLASS: {
        width: '9px',
        height: '9px',
        borderRadius: '50%',
        display: 'inline-block',
        marginRight: '4px',
        verticalAlign: 'middle'
      }
    }, this.get('legendStyle')); // fix锛欼E 9 鍏煎闂锛屽厛鍔犲叆 legendWrapper
    // let container = this.get('container');

    if (/^\#/.test(container) || typeof container === 'string' && container.constructor === String) {
      // 濡傛灉浼犲叆 dom 鑺傜偣鐨� id
      var id = container.replace('#', '');
      container = document.getElementById(id);
      container.appendChild(legendWrapper);
    } else {
      var _position = this.get('position');

      var rangeStyle = {};

      if (_position === 'left' || _position === 'right') {
        rangeStyle = {
          maxHeight: (this.get('maxLength') || container.offsetHeight) + 'px'
        };
      } else {
        rangeStyle = {
          maxWidth: (this.get('maxLength') || container.offsetWidth) + 'px'
        };
      }

      DomUtil.modifyCSS(legendWrapper, Util.mix({}, LEGEND_STYLE.CONTAINER_CLASS, rangeStyle, this.get(CONTAINER_CLASS)));
      container.appendChild(legendWrapper);
    }

    DomUtil.modifyCSS(itemListDom, Util.mix({}, LEGEND_STYLE.LIST_CLASS, this.get(LIST_CLASS))); // render title

    if (titleDom) {
      if (title && title.text) {
        titleDom.innerHTML = title.text;
        DomUtil.modifyCSS(titleDom, Util.mix({}, LEGEND_STYLE.TITLE_CLASS, this.get(TITLE_CLASS), title));
      } else {
        legendWrapper.removeChild(titleDom);
      }
    } // 寮€濮嬫覆鏌撳浘渚嬮」


    var items = this.get('items');
    var itemTpl = this.get('itemTpl');
    var position = this.get('position');
    var layout = this.get('layout');
    var itemDisplay = position === 'right' || position === 'left' || layout === 'vertical' ? 'block' : 'inline-block';
    var itemStyle = Util.mix({}, LEGEND_STYLE.LIST_ITEM_CLASS, {
      display: itemDisplay
    }, this.get(ITEM_CLASS));
    var markerStyle = Util.mix({}, LEGEND_STYLE.MARKER_CLASS, this.get(MARKER_CLASS));
    Util.each(items, function (item, index) {
      var checked = item.checked;

      var value = _this5._formatItemValue(item.value);

      var markerColor = item.marker.fill || item.marker.stroke;
      var color = checked ? markerColor : unCheckedColor;
      var domStr;

      if (Util.isFunction(itemTpl)) {
        domStr = itemTpl(value, color, checked, index);
      } else {
        domStr = itemTpl;
      }

      var itemDiv = Util.substitute(domStr, Util.mix({}, item, {
        index: index,
        checked: checked ? 'checked' : 'unChecked',
        value: value,
        color: color,
        originColor: markerColor,
        // @2018-07-09 by blue.lb 淇濡傛灉legend鍊间腑瀛樺湪鍙屽紩鍙�"鏃�, 瀵艰嚧鐨勬棤娉曠偣鍑昏Е鍙憀egend姝ｅ父鎿嶄綔bug
        originValue: item.value.replace(/\"/g, '&quot;')
      })); // li

      var itemDom = DomUtil.createDom(itemDiv);
      itemDom.style.color = _this5.get('textStyle').fill;
      var markerDom = findNodeByClass(itemDom, MARKER_CLASS);
      var textDom = findNodeByClass(itemDom, TEXT_CLASS);
      DomUtil.modifyCSS(itemDom, itemStyle);
      markerDom && DomUtil.modifyCSS(markerDom, markerStyle); // textDom && DomUtil.modifyCSS(textDom, this.get('textStyle'));

      if (!checked) {
        itemDom.style.color = unCheckedColor;

        if (markerDom) {
          markerDom.style.backgroundColor = unCheckedColor;
        }
      }

      itemListDom.appendChild(itemDom); // abridge the text if the width of the text exceeds the width of the item

      if (_this5.get('abridgeText')) {
        var text = value; // const itemWidth = parseFloat(this.get(ITEM_CLASS).width.substr(0, this.get(ITEM_CLASS).width.length - 2));

        var itemWidth = itemDom.offsetWidth;

        var fs = _this5.get('textStyle').fontSize;

        if (isNaN(fs)) {
          // 6.5pt = 6.5 * 1/72 * 96 = 8.6px
          if (fs.indexOf('pt') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2)) * 1 / 72 * 96;else if (fs.indexOf('px') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2));
        }

        var textWidth = fs * text.length;
        var letterNum = Math.floor(itemWidth / fs);

        if (itemWidth < 2 * fs) {
          // unable to contain '...'
          text = '';
        } else if (itemWidth < textWidth) {
          // replace the tail as '...
          if (letterNum > 1) text = text.substr(0, letterNum - 1) + '...';
        }

        textDom.innerText = text; // show the text tip while mouse hovering an item

        itemDom.addEventListener('mouseover', function () {
          var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');
          tipDom.style.display = 'block';
          tipDom.style.left = itemDom.offsetLeft + itemDom.offsetWidth + 'px';
          tipDom.style.top = itemDom.offsetTop + 15 + 'px';
          tipDom.innerText = value;
        }); // hide the text tip while mouse leave the item

        itemDom.addEventListener('mouseout', function () {
          var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');
          tipDom.style.display = 'none';
        });
      }
    }); // append the tip div as a brother node of legend dom

    if (this.get('abridgeText')) {
      var tipTpl = this.get('tipTpl');
      var tipDom = DomUtil.createDom(tipTpl);
      var tipDomStyle = this.get('tipStyle');
      DomUtil.modifyCSS(tipDom, tipDomStyle);
      legendWrapper.parentNode.appendChild(tipDom); // hide the tip while mouse entering the tip dom

      tipDom.addEventListener('mouseover', function () {
        tipDom.style.display = 'none';
      });
    }

    this.set('legendWrapper', legendWrapper);
  };

  _proto._adjustPositionOffset = function _adjustPositionOffset() {
    var autoPosition = this.get('autoPosition'); // @2018-12-29 by maplor. if autoPosition is false, don't set inline-style

    if (autoPosition === false) {
      return;
    }

    var position = this.get('position');
    var offset = this.get('offset');
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    if (offsetX) offset[0] = offsetX;
    if (offsetY) offset[1] = offsetY;
    var legendWrapper = this.get('legendWrapper');
    legendWrapper.style.left = position[0] + 'px';
    legendWrapper.style.top = position[1] + 'px';
    legendWrapper.style.marginLeft = offset[0] + 'px';
    legendWrapper.style.marginTop = offset[1] + 'px';
  };

  _proto.getWidth = function getWidth() {
    return DomUtil.getOuterWidth(this.get('legendWrapper'));
  };

  _proto.getHeight = function getHeight() {
    return DomUtil.getOuterHeight(this.get('legendWrapper'));
  };

  _proto.move = function move(x, y) {
    if (!/^\#/.test(this.get('container'))) {
      DomUtil.modifyCSS(this.get('legendWrapper'), {
        left: x + 'px',
        top: y + 'px'
      });
      this.set('x', x);
      this.set('y', y);
    } else {
      _Category.prototype.move.call(this, x, y);
    }
  };

  _proto.destroy = function destroy() {
    var legendWrapper = this.get('legendWrapper');

    if (legendWrapper && legendWrapper.parentNode) {
      legendWrapper.parentNode.removeChild(legendWrapper);
    }

    _Category.prototype.destroy.call(this);
  };

  return CatHtml;
}(Category);

module.exports = CatHtml;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Legend = __webpack_require__(112);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY; // const DomUtil = Util.DomUtil;


var Event = Util.Event;
var Group = Util.Group; // const Global = require('../../global');
// const CONTAINER_CLASS = 'g2-legend';

function findItem(items, refer) {
  var rst = null;
  var value = refer instanceof Group || refer.name === 'legendGroup' ? refer.get('value') : refer;
  Util.each(items, function (item) {
    if (item.value === value) {
      rst = item;
      return false;
    }
  });
  return rst;
}

function findShapeByName(group, name) {
  return group.findBy(function (node) {
    return node.name === name;
  });
}

var Category =
/*#__PURE__*/
function (_Legend) {
  _inheritsLoose(Category, _Legend);

  function Category() {
    return _Legend.apply(this, arguments) || this;
  }

  var _proto = Category.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Legend.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * type鏍囪瘑
       * @type {String}
       */
      type: 'category-legend',

      /**
       * 瀛愰」闆嗗悎
       * @type {Array}
       */
      items: null,

      /**
       * TODO锛歳ename
       * 鍥句緥椤规按骞虫柟鍚戠殑闂磋窛
       * @type {Number}
       */
      itemGap: 5,

      /**
       * TODO锛歳ename
       * 鍥句緥椤瑰瀭鐩存柟鍚戠殑闂磋窛
       * @type {Number}
       */
      itemMarginBottom: 8,

      /**
       * 鍥句緥椤瑰浘缁�
       * @type {Group}
       */
      itemsGroup: null,

      /**
       * 甯冨眬鏂瑰紡锛� horizontal锛寁ertical
       * @type {String}
       */
      layout: 'horizontal',

      /**
       * 鏄惁鍏佽鍏ㄩ儴鍙栨秷锛岄粯璁� false锛屽嵆蹇呴』淇濈暀涓€涓閫変腑
       * @type {Boolean}
       */
      allowAllCanceled: false,

      /**
       * 杈规鍐呰竟璺�
       * @type {Array}
       */
      backPadding: [0, 0, 0, 0],

      /**
       * 鍥句緥椤瑰彇娑堥€変腑鐨勯鑹�
       * @type {String}
       */
      unCheckColor: '#ccc',

      /**
       * 鍥句緥鑳屾櫙灞傚睘鎬ц缃�
       * @type {Obejct}
       */
      background: {
        fill: '#fff',
        fillOpacity: 0
      },

      /**
       * 鍥句緥椤圭殑瀹藉害锛屽綋鍥句緥鏈夊緢澶氬浘渚嬮」锛屽苟涓旂敤鎴锋兂瑕佽繖浜涘浘渚嬮」鍦ㄥ悓涓€骞抽潰鍐呭瀭鐩村榻愶紝姝ゆ椂杩欎釜灞炴€у彲甯敤鎴峰疄鐜版鏁堟灉
       * @type {Number}
       */
      itemWidth: null,

      /**
       * 鍥句緥鏂囧瓧鏍峰紡
       * @type {ATTRS}
       */
      textStyle: {
        fill: '#333',
        fontSize: 12,
        textAlign: 'start',
        textBaseline: 'middle',
        fontFamily: FONT_FAMILY
      },

      /**
       * marker 鍜屾枃瀛楃殑璺濈
       * @type {Number}
       */
      _wordSpaceing: 8,

      /**
       * 鍥句緥椤规槸鍚﹀彲鐐瑰嚮锛岄粯璁や负 true
       * @type {Boolean}
       */
      clickable: true,

      /**
       * TODO: rename
       * 鍥句緥椤圭殑閫夋嫨妯″紡锛屽閫夊拰鍗曢€� multiple銆乻ingle
       * @type {String}
       */
      selectedMode: 'multiple',

      /**
       * 鍥句緥椤圭殑椤哄簭鏄惁瑕侀€嗗簭锛岄粯璁や负 false
       * @type {Boolean}
       */
      reversed: false,

      /**
       * 鏄惁鑷姩鎹㈣
       * @type {Boolean}
       */
      autoWrap: true,

      /**
       * 鏄惁浠ュ鍔� border 鐨勬柟寮忛珮浜� hover 鐨� item銆傝嫢涓� false 锛屽垯闄嶄綆鍏朵粬 item 鐨勯€忔槑搴︺€�
       * @type {Boolean}
       */
      highlight: false,

      /**
       * 闈瀐ighlight鏂瑰紡涓嬶紝榧犳爣hover鍒發egend鏍峰紡
       * @type {Number}
       */
      activeOpacity: 0.7,

      /**
       * 闈瀐ighlight鏂瑰紡涓嬶紝闈為紶鏍噃over鍒扮殑legend鏍峰紡
       * @type {Number}
       */
      inactiveOpacity: 1
    });
  } // rendering
  ;

  _proto.render = function render() {
    _Legend.prototype.render.call(this);

    this._renderItems();

    this.get('autoWrap') && this._adjustItems(); // 榛樿鑷姩鎹㈣
  } // user iteraction
  ;

  _proto._bindEvents = function _bindEvents() {
    if (this.get('hoverable')) {
      this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMousemove'));
      this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseleave'));
    }

    if (this.get('clickable')) {
      this.get('group').on('click', Util.wrapBehavior(this, '_onClick'));
    }
  } // return the target's parent legend object
  ;

  _proto._getLegendItem = function _getLegendItem(target) {
    var item = target.get('parent');

    if (item && item.name === 'legendGroup') {
      return item;
    }

    return null;
  } // activate an item by reduce the opacity of other items.
  // it is reserved for bi-direction interaction between charts / graph and legend
  ;

  _proto.activate = function activate(value) {
    var _this = this;

    var self = this;
    var itemsGroup = self.get('itemsGroup');
    var children = itemsGroup.get('children');
    var markerItem = void 0;
    children.forEach(function (child) {
      markerItem = findShapeByName(child, 'legend-marker');
      if (!markerItem) return;
      var checked = child.get('checked');

      if (_this.get('highlight')) {
        // change stroke color
        if (child.get('value') === value && checked) {
          markerItem.attr('stroke', '#333');
        } else {
          markerItem.attr('stroke', null);
        }
      } else {
        // change opacity
        if (child.get('value') === value) {
          markerItem.attr('fillOpacity', self.get('activeOpacity'));
        }
      }
    });
    this.get('canvas').draw();
    return;
  } // restore the opacity of items
  // it is reserved for bi-direction interaction between charts / graph and legend
  ;

  _proto.deactivate = function deactivate() {
    var _this2 = this;

    var self = this;
    var itemsGroup = self.get('itemsGroup');
    var children = itemsGroup.get('children');
    var markerItem = void 0;
    var unCheckColor = this.get('unCheckColor');
    children.forEach(function (child) {
      markerItem = findShapeByName(child, 'legend-marker');
      if (!markerItem) return;

      if (_this2.get('highlight')) {
        var oriStroke = markerItem.get('oriStroke');
        var checked = child.get('checked');
        if (oriStroke && !checked) oriStroke = unCheckColor;else oriStroke = '';
        markerItem.attr('stroke', oriStroke);
      } else {
        markerItem.attr('fillOpacity', self.get('inactiveOpacity'));
      }
    });
    this.get('canvas').draw();
    return;
  } // mouse move listener of an item
  // when mouse over an item, reduce the opacity of the other items.
  ;

  _proto._onMousemove = function _onMousemove(ev) {
    var item = this._getLegendItem(ev.currentTarget);

    if (item && item.get('checked')) {
      var items = this.get('items');
      var itemhover = new Event('itemhover', ev, true, true);
      itemhover.item = findItem(items, item);
      itemhover.checked = item.get('checked');
      itemhover.currentTarget = ev.currentTarget; // change the opacity of other items

      this.deactivate();
      this.activate(item.get('value'));
      this.emit('itemhover', itemhover);
    } else {
      this.deactivate();
      this.emit('itemunhover', ev);
    }

    this.get('canvas').draw();
    return;
  } // mouse leave listener of an item
  ;

  _proto._onMouseleave = function _onMouseleave(ev) {
    this.deactivate();
    this.get('canvas').draw();
    this.emit('itemunhover', ev);
    return;
  } // the click listener of an item
  ;

  _proto._onClick = function _onClick(ev) {
    var clickedItem = this._getLegendItem(ev.currentTarget);

    var items = this.get('items');

    if (clickedItem && !clickedItem.get('destroyed')) {
      var checked = clickedItem.get('checked');
      var mode = this.get('selectedMode');
      var item = findItem(items, clickedItem);
      var itemclick = new Event('itemclick', ev, true, true);
      itemclick.item = item;
      itemclick.currentTarget = clickedItem;
      itemclick.appendInfo = ev.currentTarget.get('appendInfo');
      itemclick.checked = mode === 'single' ? true : !checked;

      if (!this.get('allowAllCanceled') && checked && this.getCheckedCount() === 1) {
        this.emit('clicklastitem', itemclick);
        return;
      }

      var unCheckColor = this.get('unCheckColor');
      var checkColor = this.get('textStyle').fill;
      var markerItem = void 0;
      var textItem = void 0;
      var legendItem = void 0;

      if (mode === 'single') {
        var itemsGroup = this.get('itemsGroup');
        var children = itemsGroup.get('children');
        Util.each(children, function (child) {
          markerItem = findShapeByName(child, 'legend-marker');
          textItem = findShapeByName(child, 'legend-text');
          legendItem = findShapeByName(child, 'legend-item');

          if (child !== clickedItem) {
            if (markerItem.attr('fill')) {
              markerItem.attr('fill', unCheckColor);
            }

            if (markerItem.attr('stroke')) {
              markerItem.attr('stroke', unCheckColor);
            }

            textItem.attr('fill', unCheckColor);
            markerItem.setSilent('checked', false);
            textItem.setSilent('checked', false);
            legendItem.setSilent('checked', false);
            child.setSilent('checked', false);
          } else {
            if (markerItem.attr('fill')) {
              item && item.marker && markerItem.attr('fill', item.marker.fill);
            }

            if (markerItem.attr('stroke')) {
              item && item.marker && markerItem.attr('stroke', item.marker.stroke);
            }

            textItem.attr('fill', checkColor);
            markerItem.setSilent('checked', true);
            textItem.setSilent('checked', true);
            legendItem.setSilent('checked', true);
            child.setSilent('checked', true);
          }
        });
      } else {
        markerItem = findShapeByName(clickedItem, 'legend-marker');
        textItem = findShapeByName(clickedItem, 'legend-text');
        legendItem = findShapeByName(clickedItem, 'legend-item');

        if (markerItem.attr('fill')) {
          item && item.marker && markerItem.attr('fill', checked ? unCheckColor : item.marker.fill);
        }

        if (markerItem.attr('stroke')) {
          item && item.marker && markerItem.attr('stroke', checked ? unCheckColor : item.marker.stroke);
        }

        textItem.attr('fill', checked ? unCheckColor : checkColor);
        clickedItem.setSilent('checked', !checked);
        markerItem.setSilent('checked', !checked);
        textItem.setSilent('checked', !checked);
        legendItem.setSilent('checked', !checked);
      }

      this.emit('itemclick', itemclick);
    }

    this.get('canvas').draw();
    return;
  } // render the items
  ;

  _proto._renderItems = function _renderItems() {
    var _this3 = this;

    var items = this.get('items');

    if (this.get('reversed')) {
      items.reverse();
    }

    Util.each(items, function (item, index) {
      _this3._addItem(item, index);
    });

    if (this.get('highlight')) {
      var itemsGroup = this.get('itemsGroup');
      var children = itemsGroup.get('children');
      var markerItem = void 0;
      children.forEach(function (child) {
        markerItem = findShapeByName(child, 'legend-marker');
        var oriStroke = markerItem.get('oriStroke');

        if (!oriStroke) {
          if (markerItem.attr('stroke')) markerItem.set('oriStroke', markerItem.attr('stroke'));else markerItem.set('oriStroke', '');
        }
      });
    }
  } // format the item value
  ;

  _proto._formatItemValue = function _formatItemValue(value) {
    var formatter = this.get('formatter') || this.get('itemFormatter');

    if (formatter) {
      value = formatter.call(this, value);
    }

    return value;
  } // find x of next item
  ;

  _proto._getNextX = function _getNextX() {
    var layout = this.get('layout');
    var itemGap = this.get('itemGap');
    var itemsGroup = this.get('itemsGroup');
    var itemWidth = this.get('itemWidth');
    var children = itemsGroup.get('children');
    var nextX = 0;

    if (layout === 'horizontal') {
      // 姘村钩甯冨眬
      Util.each(children, function (v) {
        nextX += (itemWidth ? itemWidth : v.getBBox().width) + itemGap;
      });
    }

    return nextX;
  } // find y of next item
  ;

  _proto._getNextY = function _getNextY() {
    var itemMarginBottom = this.get('itemMarginBottom');
    var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;
    var layout = this.get('layout');
    var itemsGroup = this.get('itemsGroup');
    var titleShape = this.get('titleShape');
    var children = itemsGroup.get('children');
    var nextY = titleGap;

    if (titleShape) {
      nextY += titleShape.getBBox().height;
    }

    if (layout === 'vertical') {
      // 绔栫洿甯冨眬
      Util.each(children, function (v) {
        nextY += v.getBBox().height + itemMarginBottom;
      });
    }

    return nextY;
  } // add an item to the canvas
  ;

  _proto._addItem = function _addItem(item) {
    var itemsGroup = this.get('itemsGroup');

    var x = this._getNextX();

    var y = this._getNextY();

    var unCheckColor = this.get('unCheckColor');
    var itemGroup = itemsGroup.addGroup({
      x: x,
      y: y,
      value: item.value,
      checked: item.checked
    }); // @2018-10-20 by blue.lb 闇€瑕佽缃畍iewId锛屽惁鍒欏湪emit鐨勬椂鍊欙紝parent鑾峰彇涓嶅埌viewId

    itemGroup.set('viewId', this.get('viewId'));
    var textStyle = this.get('textStyle');
    var wordSpace = this.get('_wordSpaceing');
    var startX = 0;

    if (item.marker) {
      // 濡傛灉鏈塵arker娣诲姞marker
      var markerAttrs = Util.mix({}, item.marker, {
        x: item.marker.radius + x,
        y: y
      });

      if (!item.checked) {
        if (markerAttrs.fill) {
          markerAttrs.fill = unCheckColor;
        }

        if (markerAttrs.stroke) {
          markerAttrs.stroke = unCheckColor;
        }
      }

      var markerShape = itemGroup.addShape('marker', {
        type: 'marker',
        attrs: markerAttrs
      });
      markerShape.attr('cursor', 'pointer');
      markerShape.name = 'legend-marker';
      startX += markerShape.getBBox().width + wordSpace;
    }

    var textAttrs = Util.mix({}, {
      fill: '#333',
      fontSize: 12,
      textAlign: 'start',
      textBaseline: 'middle',
      fontFamily: FONT_FAMILY
    }, textStyle, {
      x: startX + x,
      y: y,
      text: this._formatItemValue(item.value)
    });

    if (!item.checked) {
      Util.mix(textAttrs, {
        fill: unCheckColor
      });
    }

    var textShape = itemGroup.addShape('text', {
      attrs: textAttrs
    });
    textShape.attr('cursor', 'pointer');
    textShape.name = 'legend-text';
    this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 娣诲姞涓€涓寘鍥寸煩褰紝鐢ㄤ簬浜嬩欢鏀寔

    var bbox = itemGroup.getBBox();
    var itemWidth = this.get('itemWidth');
    var wrapperShape = itemGroup.addShape('rect', {
      attrs: {
        x: x,
        y: y - bbox.height / 2,
        fill: '#fff',
        fillOpacity: 0,
        width: itemWidth || bbox.width,
        height: bbox.height
      }
    });
    wrapperShape.attr('cursor', 'pointer');
    wrapperShape.setSilent('origin', item); // 淇濆瓨鍥句緥椤圭浉鍏崇殑鏁版嵁锛屼究浜庝簨浠舵搷浣�

    wrapperShape.name = 'legend-item';
    this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));
    itemGroup.name = 'legendGroup';
    return itemGroup;
  } // auto break the line for horizontal layout
  ;

  _proto._adjustHorizontal = function _adjustHorizontal() {
    var itemsGroup = this.get('itemsGroup');
    var children = itemsGroup.get('children');
    var maxLength = this.get('maxLength');
    var itemGap = this.get('itemGap');
    var itemMarginBottom = this.get('itemMarginBottom');
    var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;
    var row = 0;
    var rowLength = 0;
    var width = void 0;
    var height = void 0;
    var box = void 0;
    var itemWidth = this.get('itemWidth');

    if (itemsGroup.getBBox().width > maxLength) {
      Util.each(children, function (child) {
        box = child.getBBox();
        width = itemWidth || box.width;
        height = box.height + itemMarginBottom;

        if (maxLength - rowLength < width) {
          row++;
          rowLength = 0;
        }

        child.move(rowLength, row * height + titleGap);
        rowLength += width + itemGap;
      });
    }

    return;
  } // auto break the column for vertical layout
  ;

  _proto._adjustVertical = function _adjustVertical() {
    var itemsGroup = this.get('itemsGroup');
    var titleShape = this.get('titleShape');
    var children = itemsGroup.get('children');
    var maxLength = this.get('maxLength'); // 鍨傜洿甯冨眬锛屽垯 maxLength 浠ｈ〃瀹瑰櫒鐨勯珮搴�

    var itemGap = this.get('itemGap');
    var itemMarginBottom = this.get('itemMarginBottom');
    var titleGap = this.get('titleGap');
    var titleHeight = titleShape ? titleShape.getBBox().height + titleGap : 0;
    var itemWidth = this.get('itemWidth');
    var colLength = titleHeight;
    var width = void 0;
    var height = void 0;
    var box = void 0;
    var maxItemWidth = 0;
    var totalLength = 0;

    if (itemsGroup.getBBox().height > maxLength) {
      Util.each(children, function (v) {
        box = v.getBBox();
        width = box.width;
        height = box.height;

        if (itemWidth) {
          maxItemWidth = itemWidth + itemGap;
        } else if (width > maxItemWidth) {
          maxItemWidth = width + itemGap;
        }

        if (maxLength - colLength < height) {
          colLength = titleHeight;
          totalLength += maxItemWidth;
          v.move(totalLength, titleHeight);
        } else {
          v.move(totalLength, colLength);
        }

        colLength += height + itemMarginBottom;
      });
    }

    return;
  } // automatically break the line / column while the width / height exceeds maxLength
  ;

  _proto._adjustItems = function _adjustItems() {
    var layout = this.get('layout');

    if (layout === 'horizontal') {
      this._adjustHorizontal();
    } else {
      this._adjustVertical();
    }
  };

  _proto.getWidth = function getWidth() {
    return _Legend.prototype.getWidth.call(this);
  };

  _proto.getHeight = function getHeight() {
    return _Legend.prototype.getHeight.call(this);
  };

  _proto.move = function move(x, y) {
    _Legend.prototype.move.call(this, x, y);
  };

  return Category;
}(Legend);

module.exports = Category;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var G = __webpack_require__(31);

var Crosshair = __webpack_require__(116);

var MarkerGroupMixin = __webpack_require__(117);

var PositionMixin = __webpack_require__(118);

var Tooltip = __webpack_require__(68);

var Util = __webpack_require__(3);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var DomUtil = Util.DomUtil;
var MatrixUtil = Util.MatrixUtil;

var CanvasTooltip =
/*#__PURE__*/
function (_Tooltip) {
  _inheritsLoose(CanvasTooltip, _Tooltip);

  var _proto = CanvasTooltip.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Tooltip.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 榛樿鑳屾櫙鏉挎牱寮�
       * @type {Object}
       */
      boardStyle: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        fill: 'rgba(255, 255, 255, 0.9)',
        radius: 4,
        stroke: '#e2e2e2',
        lineWidth: 1
      },

      /**
       * 榛樿title鏍峰紡
       * @type {Object}
       */
      titleStyle: {
        fontFamily: FONT_FAMILY,
        text: '',
        textBaseline: 'top',
        fontSize: 12,
        fill: 'rgb(87, 87, 87)',
        lineHeight: 20,
        padding: 20
      },

      /**
       * 榛樿marker鏍峰紡
       * @type {Object}
       */
      markerStyle: {
        radius: 4
      },

      /**
       * 榛樿name鏍峰紡
       * @type {Object}
       */
      nameStyle: {
        fontFamily: FONT_FAMILY,
        fontSize: 12,
        fill: 'rgb(87, 87, 87)',
        textBaseline: 'middle',
        textAlign: 'start',
        padding: 8
      },

      /**
       * 榛樿value鏍峰紡
       * @type {Object}
       */
      valueStyle: {
        fontFamily: FONT_FAMILY,
        fontSize: 12,
        fill: 'rgb(87, 87, 87)',
        textBaseline: 'middle',
        textAlign: 'start',
        padding: 30
      },

      /**
       * 榛樿padding鍊�
       * @type {Object}
       */
      padding: {
        top: 20,
        right: 20,
        bottom: 20,
        left: 20
      },

      /**
       * 榛樿item涔嬮棿鐨刧ap
       * @type {Number}
       */
      itemGap: 10,

      /**
       * 榛樿tooltip浣嶇疆绉诲姩鍔ㄧ敾鐨勬椂闀�
       * @type {Number}
       */
      animationDuration: 200
    });
  };

  function CanvasTooltip(cfg) {
    var _this;

    _this = _Tooltip.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), PositionMixin);
    Util.assign(_assertThisInitialized(_this), MarkerGroupMixin); // crosshair

    var crosshair = _this.get('crosshairs');

    if (crosshair) {
      var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');
      var crosshairGroup = new Crosshair(Util.mix({
        plot: plot,
        plotRange: _this.get('plotRange'),
        canvas: _this.get('canvas')
      }, _this.get('crosshairs')));
      crosshairGroup.hide();

      _this.set('crosshairGroup', crosshairGroup);
    }

    _this._init_();

    if (_this.get('items')) {
      _this.render();
    }

    return _this;
  }

  _proto._init_ = function _init_() {
    var self = this;
    var padding = self.get('padding');
    var parent = self.get('frontPlot'); // marker group

    var markerGroup = parent.addGroup({
      capture: false
    });
    self.set('markerGroup', markerGroup); // container

    var container = parent.addGroup();
    container.hide();
    self.set('container', container); // board

    var board = container.addShape('rect', {
      attrs: Util.mix({}, self.get('boardStyle'))
    });
    self.set('board', board); // title

    var titleStyle = self.get('titleStyle');

    if (self.get('showTitle')) {
      var titleShape = container.addShape('text', {
        attrs: Util.mix({
          x: padding.left,
          y: padding.top
        }, titleStyle)
      });
      self.set('titleShape', titleShape);
      titleShape.name = 'tooltip-title';
    } // items


    var itemsGroup = container.addGroup();
    itemsGroup.move(padding.left, padding.top + titleStyle.lineHeight + titleStyle.padding);
    self.set('itemsGroup', itemsGroup);
  };

  _proto.render = function render() {
    var self = this;
    self.clear();
    var container = self.get('container');
    var board = self.get('board');
    var showTitle = self.get('showTitle');
    var titleContent = self.get('titleContent');
    var titleShape = this.get('titleShape');
    var itemsGroup = this.get('itemsGroup');
    var items = self.get('items');
    var padding = self.get('padding');

    if (titleShape && showTitle) {
      titleShape.attr('text', titleContent);
    }

    if (itemsGroup) {
      var itemGap = self.get('itemGap');
      var x = 0;
      var y = 0;
      Util.each(items, function (item) {
        var itemGroup = self._addItem(item);

        itemGroup.move(x, y);
        itemsGroup.add(itemGroup);
        var itemHeight = itemGroup.getBBox().height;
        y += itemHeight + itemGap;
      });
    } // update board based on bbox


    var bbox = container.getBBox();
    var width = bbox.width + padding.right;
    var height = bbox.height + padding.bottom;
    board.attr('width', width);
    board.attr('height', height); // align value text to right

    self._alignToRight(width);
  };

  _proto.clear = function clear() {
    var titleShape = this.get('titleShape');
    var itemsGroup = this.get('itemsGroup');
    var board = this.get('board');
    titleShape.text = '';
    itemsGroup.clear();
    board.attr('width', 0);
    board.attr('height', 0);
  };

  _proto.show = function show() {
    var container = this.get('container');
    container.show();
    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.show();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.show();

    _Tooltip.prototype.show.call(this);

    this.get('canvas').draw();
  };

  _proto.hide = function hide() {
    var container = this.get('container');
    container.hide();
    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.hide();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.hide();

    _Tooltip.prototype.hide.call(this);

    this.get('canvas').draw();
  };

  _proto.destroy = function destroy() {
    var container = this.get('container');
    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.destroy();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.remove();

    _Tooltip.prototype.destroy.call(this);

    container.remove();
  };

  _proto.setPosition = function setPosition(x, y, target) {
    var container = this.get('container');
    var outterNode = this.get('canvas').get('el');
    var viewWidth = DomUtil.getWidth(outterNode);
    var viewHeight = DomUtil.getHeight(outterNode);
    var bbox = container.getBBox();
    var containerWidth = bbox.width;
    var containerHeight = bbox.height;
    var endx = x;
    var endy = y;
    var position;

    if (this.get('position')) {
      var _containerWidth = bbox.width;
      var _containerHeight = bbox.height;
      position = this._calcTooltipPosition(x, y, this.get('position'), _containerWidth, _containerHeight, target);
      x = position[0];
      y = position[1];
    } else {
      position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);
      x = position[0];
      y = position[1];
    }

    if (this.get('inPlot')) {
      // tooltip 蹇呴』闄愬埗鍦ㄧ粯鍥惧尯鍩熷唴
      var plotRange = this.get('plotRange');
      position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));
      x = position[0];
      y = position[1];
    }

    var markerItems = this.get('markerItems');

    if (!Util.isEmpty(markerItems)) {
      endx = markerItems[0].x;
      endy = markerItems[0].y;
    }

    var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);
    container.stopAnimate();
    container.animate({
      matrix: mat
    }, this.get('animationDuration'));
    var crosshairGroup = this.get('crosshairGroup');

    if (crosshairGroup) {
      var items = this.get('items');
      crosshairGroup.setPosition(endx, endy, items);
    }

    _Tooltip.prototype.setPosition.call(this, x, y);
  };

  _proto._addItem = function _addItem(item) {
    var group = new G.Group();
    var markerRadius = this.get('markerStyle').radius; // marker

    if (item.marker) {
      var markerAttrs = Util.mix({}, item.marker, {
        x: item.marker.radius / 2,
        y: 0,
        symbol: item.marker.activeSymbol || item.marker.symbol
      });
      group.addShape('marker', {
        attrs: markerAttrs
      });
      markerRadius = item.marker.radius;
    } // name


    var nameStyle = this.get('nameStyle');
    group.addShape('text', {
      attrs: Util.mix({
        x: markerRadius + nameStyle.padding,
        y: 0,
        text: item.name
      }, nameStyle)
    }); // value

    var valueStyle = this.get('valueStyle');
    group.addShape('text', {
      attrs: Util.mix({
        x: group.getBBox().width + valueStyle.padding,
        y: 0,
        text: item.value
      }, valueStyle)
    });
    return group;
  };

  _proto._alignToRight = function _alignToRight(width) {
    var _this2 = this;

    var itemsGroup = this.get('itemsGroup');
    var groups = itemsGroup.get('children');
    Util.each(groups, function (g) {
      var children = g.get('children');
      var valueText = children[2];
      var w = valueText.getBBox().width;
      var x = width - w - _this2.get('padding').right * 2;
      valueText.attr('x', x);
    });
  };

  return CanvasTooltip;
}(Tooltip);

module.exports = CanvasTooltip;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Component = __webpack_require__(36);

var Util = __webpack_require__(3);

var Crosshair =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Crosshair, _Component);

  var _proto = Crosshair.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Component.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
        * crosshair鐨勭被鍨�
        * @type {String}
        */
      type: null,

      /**
       * 鐢诲湪鍝眰瑙嗗浘
       * @type {G-Element}
       */
      plot: null,

      /**
       * x杞翠笂锛岀Щ鍔ㄥ埌浣嶇疆鐨勫亸绉婚噺
       * @type {Number}
       */
      plotRange: null,

      /**
       * 榛樿rect crosshair鏍峰紡
       * @type {Object}
       */
      rectStyle: {
        fill: '#CCD6EC',
        opacity: 0.3
      },

      /**
        * 榛樿line crosshair鏍峰紡
        * @type {Object}
        */
      lineStyle: {
        stroke: 'rgba(0, 0, 0, 0.25)',
        lineWidth: 1
      },
      isTransposed: false
    });
  };

  function Crosshair(cfg) {
    var _this;

    _this = _Component.call(this, cfg) || this;

    _this._init_();

    _this.render();

    return _this;
  }

  _proto._init_ = function _init_() {
    var self = this;
    var plot = self.get('plot');
    var group;

    if (self.type === 'rect') {
      group = plot.addGroup({
        zIndex: 0
      });
    } else {
      group = plot.addGroup();
    }

    this.set('container', group);
  };

  _proto._addLineShape = function _addLineShape(attrs, type) {
    var container = this.get('container');
    var shape = container.addShape('line', {
      capture: false,
      attrs: attrs
    }); // shape.hide();

    this.set('crossLineShape' + type, shape);
    return shape;
  };

  _proto._renderHorizontalLine = function _renderHorizontalLine(canvas, plotRange) {
    var style = Util.mix(this.get('lineStyle'), this.get('style'));
    var attrs = Util.mix({
      x1: plotRange ? plotRange.bl.x : canvas.get('width'),
      y1: 0,
      x2: plotRange ? plotRange.br.x : 0,
      y2: 0
    }, style);

    this._addLineShape(attrs, 'X');
  };

  _proto._renderVerticalLine = function _renderVerticalLine(canvas, plotRange) {
    var style = Util.mix(this.get('lineStyle'), this.get('style'));
    var attrs = Util.mix({
      x1: 0,
      y1: plotRange ? plotRange.bl.y : canvas.get('height'),
      x2: 0,
      y2: plotRange ? plotRange.tl.y : 0
    }, style);

    this._addLineShape(attrs, 'Y');
  };

  _proto._renderBackground = function _renderBackground(canvas, plotRange) {
    var style = Util.mix(this.get('rectStyle'), this.get('style'));
    var container = this.get('container');
    var attrs = Util.mix({
      x: plotRange ? plotRange.tl.x : 0,
      y: plotRange ? plotRange.tl.y : canvas.get('height'),
      width: plotRange ? plotRange.br.x - plotRange.bl.x : canvas.get('width'),
      height: plotRange ? Math.abs(plotRange.tl.y - plotRange.bl.y) : canvas.get('height')
    }, style);
    var shape = container.addShape('rect', {
      attrs: attrs,
      capture: false
    }); // shape.hide();

    this.set('crosshairsRectShape', shape);
    return shape;
  };

  _proto._updateRectShape = function _updateRectShape(items) {
    var offset;
    var crosshairsRectShape = this.get('crosshairsRectShape');
    var isTransposed = this.get('isTransposed');
    var firstItem = items[0];
    var lastItem = items[items.length - 1];
    var dim = isTransposed ? 'y' : 'x';
    var attr = isTransposed ? 'height' : 'width';
    var startDim = firstItem[dim];

    if (items.length > 1 && firstItem[dim] > lastItem[dim]) {
      startDim = lastItem[dim];
    }

    if (this.get('width')) {
      // 鐢ㄦ埛瀹氫箟浜� width
      crosshairsRectShape.attr(dim, startDim - this.get('crosshairs').width / 2);
      crosshairsRectShape.attr(attr, this.get('width'));
    } else {
      if (Util.isArray(firstItem.point[dim]) && !firstItem.size) {
        // 鐩存柟鍥�
        var width = firstItem.point[dim][1] - firstItem.point[dim][0];
        crosshairsRectShape.attr(dim, firstItem.point[dim][0]);
        crosshairsRectShape.attr(attr, width);
      } else {
        offset = 3 * firstItem.size / 4;
        crosshairsRectShape.attr(dim, startDim - offset);

        if (items.length === 1) {
          crosshairsRectShape.attr(attr, 3 * firstItem.size / 2);
        } else {
          crosshairsRectShape.attr(attr, Math.abs(lastItem[dim] - firstItem[dim]) + 2 * offset);
        }
      }
    }
  };

  _proto.render = function render() {
    var canvas = this.get('canvas');
    var plotRange = this.get('plotRange');
    var isTransposed = this.get('isTransposed');
    this.clear();

    switch (this.get('type')) {
      case 'x':
        this._renderHorizontalLine(canvas, plotRange);

        break;

      case 'y':
        this._renderVerticalLine(canvas, plotRange);

        break;

      case 'cross':
        this._renderHorizontalLine(canvas, plotRange);

        this._renderVerticalLine(canvas, plotRange);

        break;

      case 'rect':
        this._renderBackground(canvas, plotRange);

        break;

      default:
        isTransposed ? this._renderHorizontalLine(canvas, plotRange) : this._renderVerticalLine(canvas, plotRange);
    }
  };

  _proto.show = function show() {
    var container = this.get('container');

    _Component.prototype.show.call(this);

    container.show();
  };

  _proto.hide = function hide() {
    var container = this.get('container');

    _Component.prototype.hide.call(this);

    container.hide();
  };

  _proto.clear = function clear() {
    var container = this.get('container');
    this.set('crossLineShapeX', null);
    this.set('crossLineShapeY', null);
    this.set('crosshairsRectShape', null);

    _Component.prototype.clear.call(this);

    container.clear();
  };

  _proto.destroy = function destroy() {
    var container = this.get('container');

    _Component.prototype.destroy.call(this);

    container.remove();
  };

  _proto.setPosition = function setPosition(x, y, items) {
    var crossLineShapeX = this.get('crossLineShapeX');
    var crossLineShapeY = this.get('crossLineShapeY');
    var crosshairsRectShape = this.get('crosshairsRectShape');

    if (crossLineShapeY && !crossLineShapeY.get('destroyed')) {
      // 绗竴娆¤繘鍏ユ椂锛岀敾甯冮渶瑕佸崟鐙粯鍒讹紝鎵€浠ラ渶瑕佸厛璁惧畾corss鐨勪綅缃�
      crossLineShapeY.move(x, 0);
    }

    if (crossLineShapeX && !crossLineShapeX.get('destroyed')) {
      crossLineShapeX.move(0, y);
    }

    if (crosshairsRectShape && !crosshairsRectShape.get('destroyed')) {
      this._updateRectShape(items);
    }
  };

  return Crosshair;
}(Component);

module.exports = Crosshair;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(3);

var MarkerGroupMixin = {
  setMarkers: function setMarkers(markerItems, markerCfg) {
    var self = this;
    var markerGroup = self.get('markerGroup');
    var frontPlot = self.get('frontPlot');

    if (!markerGroup) {
      markerGroup = frontPlot.addGroup({
        zIndex: 1,
        capture: false // 涓嶈繘琛屾嬀鍙�

      });
      self.set('markerGroup', markerGroup);
    } else {
      markerGroup.clear();
    }

    Util.each(markerItems, function (item) {
      var attrs = Util.mix({
        fill: item.color,
        symbol: 'circle',
        shadowColor: item.color
      }, markerCfg, {
        x: item.x,
        y: item.y
      });

      if (item.marker && item.marker.activeSymbol) {
        attrs.symbol = item.marker.activeSymbol;
      }

      markerGroup.addShape('marker', {
        color: item.color,
        attrs: attrs
      });
    });
    this.set('markerItems', markerItems);
  },
  clearMarkers: function clearMarkers() {
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.clear();
  }
};
module.exports = MarkerGroupMixin;

/***/ }),
/* 118 */
/***/ (function(module, exports) {

var GAP = 20;
var PositionMixin = {
  _calcTooltipPosition: function _calcTooltipPosition(x, y, position, containerWidth, containerHeight, target) {
    var rectWidth = 0;
    var rectHeight = 0;
    var gap = 20;

    if (target) {
      var rect = target.getBBox();
      rectWidth = rect.width;
      rectHeight = rect.height;
      x = rect.x;
      y = rect.y;
      gap = 5;
    }

    switch (position) {
      case 'inside':
        x = x + rectWidth / 2 - containerWidth / 2;
        y = y + rectHeight / 2 - containerHeight / 2;
        break;

      case 'top':
        x = x + rectWidth / 2 - containerWidth / 2;
        y = y - containerHeight - gap;
        break;

      case 'left':
        x = x - containerWidth - gap;
        y = y + rectHeight / 2 - containerHeight / 2;
        break;

      case 'right':
        x = x + rectWidth + gap;
        y = y + rectHeight / 2 - containerHeight / 2;
        break;

      case 'bottom':
      default:
        x = x + rectWidth / 2 - containerWidth / 2;
        y = y + rectHeight + gap;
        break;
    }

    return [x, y];
  },
  _constraintPositionInBoundary: function _constraintPositionInBoundary(x, y, width, height, viewWidth, viewHeight) {
    if (x + width + GAP > viewWidth) {
      x -= width + GAP;
      x = x < 0 ? 0 : x;
    } else if (x + GAP < 0) {
      x = GAP;
    } else {
      x += GAP;
    }

    if (y + height + GAP > viewHeight) {
      y -= height + GAP;
      y = y < 0 ? 0 : y;
    } else if (y + GAP < 0) {
      y = GAP;
    } else {
      y += GAP;
    }

    return [x, y];
  },
  _constraintPositionInPlot: function _constraintPositionInPlot(x, y, width, height, plotRange, enterable) {
    if (x + width > plotRange.tr.x) {
      if (enterable) {
        // fix: https://github.com/antvis/g2/issues/1414
        // 褰� enterable 寮€鍚椂锛屽鏋滆缃� tooltip 涓庨紶鏍囩殑闂磋窛杩囧ぇ鏍规湰灏辫拷閫愪笉涓� tooltip
        x -= width + 1;
      } else {
        x -= width + 2 * GAP;
      }
    }

    if (x < plotRange.tl.x) {
      x = plotRange.tl.x;
    }

    if (!enterable) {
      if (y + height > plotRange.bl.y) {
        y -= height + 2 * GAP;
      }

      if (y < plotRange.tl.y) {
        y = plotRange.tl.y;
      }
    }

    return [x, y];
  }
};
module.exports = PositionMixin;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Default animation configuration for geoms
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var Action = __webpack_require__(270);

var defaultAnimationCfg = {
  appear: {
    duration: 450,
    easing: 'easeQuadOut'
  },
  // 鍒濆鍏ュ満鍔ㄧ敾閰嶇疆
  update: {
    duration: 450,
    easing: 'easeQuadInOut'
  },
  // 鏇存柊鏃跺彂鐢熷彉鏇寸殑鍔ㄧ敾閰嶇疆
  enter: {
    duration: 400,
    easing: 'easeQuadInOut',
    delay: 100
  },
  // 鏇存柊鏃舵柊澧炲厓绱犵殑鍏ュ満鍔ㄧ敾閰嶇疆
  leave: {
    duration: 350,
    easing: 'easeQuadIn'
  } // 鏇存柊鏃堕攢姣佸姩鐢婚厤缃�

};
var Animate = {
  line: {
    appear: function appear() {
      return Action.appear.clipIn;
    },
    enter: function enter() {
      return Action.enter.clipIn;
    },
    leave: function leave() {
      return Action.leave.lineWidthOut;
    }
  },
  path: {
    appear: function appear() {
      return Action.appear.clipIn;
    },
    enter: function enter() {
      return Action.enter.clipIn;
    },
    leave: function leave() {
      return Action.leave.lineWidthOut;
    }
  },
  area: {
    appear: function appear() {
      return Action.appear.clipIn;
    },
    enter: function enter() {
      return Action.enter.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    cfg: {
      appear: {
        duration: 500,
        easing: 'easeQuadOut'
      },
      update: {
        duration: 450,
        easing: 'easeQuadInOut'
      },
      enter: {
        duration: 600,
        delay: 150,
        easing: 'easeQuadInOut'
      },
      leave: {
        easing: 'easeQuadOut',
        duration: 350
      }
    }
  },
  polygon: {
    appear: function appear() {
      return Action.appear.zoomIn;
    },
    enter: function enter() {
      return Action.enter.zoomIn;
    },
    leave: function leave() {
      return Action.leave.zoomOut;
    }
  },
  edge: {
    appear: function appear() {
      return Action.appear.pathIn;
    },
    enter: function enter() {
      return Action.enter.pathIn;
    },
    leave: function leave() {
      return Action.leave.pathOut;
    }
  },
  interval: {
    appear: function appear(coord) {
      var result;

      if (coord.isPolar) {
        result = Action.appear.zoomIn;

        if (coord.isTransposed || coord.type === 'theta') {
          result = Action.appear.fanIn;
        }
      } else if (coord.isRect) {
        result = coord.isTransposed ? Action.appear.scaleInX : Action.appear.scaleInY;
      } else {
        result = Action.appear.zoomIn;
      }

      return result;
    },
    enter: function enter(coord) {
      if (coord.isRect || coord.isTransposed || coord.type === 'theta') {
        return Action.enter.fadeIn;
      }

      return Action.enter.zoomIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    update: function update(coord) {
      if (coord.type === 'theta') {
        return Action.update.fanIn;
      }
    }
  },
  point: {
    appear: function appear() {
      return Action.appear.zoomIn;
    },
    enter: function enter() {
      return Action.enter.zoomIn;
    },
    leave: function leave() {
      return Action.leave.zoomOut;
    }
  },
  schema: {
    appear: function appear() {
      return Action.appear.clipIn;
    },
    enter: function enter() {
      return Action.enter.clipIn;
    },
    leave: function leave() {
      return Action.leave.lineWidthOut;
    }
  },
  contour: null,
  heatmap: null,
  label: {
    appear: function appear() {
      return Action.appear.fadeIn;
    },
    enter: function enter() {
      return Action.enter.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    cfg: {
      appear: {
        duration: 900
      }
    }
  },
  'axis-label': {
    enter: function enter() {
      return Action.appear.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    update: function update(coord) {
      if (coord.isPolar) {
        return Action.appear.fadeIn;
      }
    }
  },
  'axis-ticks': {
    enter: function enter() {
      return Action.appear.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    update: function update(coord) {
      if (coord.isPolar) {
        return Action.appear.fadeIn;
      }
    }
  },
  'axis-grid': {
    enter: function enter() {
      return Action.appear.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    update: function update(coord) {
      if (coord.isPolar) {
        return Action.appear.fadeIn;
      }
    }
  },
  'axis-grid-rect': {
    enter: function enter() {
      return Action.appear.fadeIn;
    },
    leave: function leave() {
      return Action.leave.fadeOut;
    },
    update: function update() {
      return Action.leave.fadeIn;
    }
  },
  labelLine: {
    appear: function appear() {
      return Action.appear.pathIn;
    },
    enter: function enter() {
      return Action.enter.pathIn;
    },
    leave: function leave() {
      return Action.leave.pathOut;
    }
  }
};
Animate.Action = Action;
Animate.defaultCfg = defaultAnimationCfg; // 鑾峰彇鍔ㄧ敾

Animate.getAnimation = function (geomType, coord, animationType) {
  var geomAnimateCfg = this[geomType];

  if (geomAnimateCfg) {
    var animation = geomAnimateCfg[animationType];

    if (Util.isFunction(animation)) {
      return animation(coord);
    }
  }

  return false;
}; // 鑾峰彇鍔ㄧ敾閰嶇疆


Animate.getAnimateCfg = function (geomType, animationType) {
  var defaultCfg = defaultAnimationCfg[animationType];

  if (this[geomType] && this[geomType].cfg && this[geomType].cfg[animationType]) {
    return Util.deepMix({}, defaultCfg, this[geomType].cfg[animationType]);
  }

  return defaultCfg;
}; // 娉ㄥ唽鍔ㄧ敾


Animate.registerAnimation = function (animationType, animationName, animationFun) {
  if (!this.Action[animationType]) {
    this.Action[animationType] = {};
  }

  this.Action[animationType][animationName] = animationFun;
};

module.exports = Animate;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview Chart銆乂iew銆丟eometry 鐨勫熀绫�
 * @author dxq613@gmail.com
 */
var EventEmitter = __webpack_require__(105);

var Util = __webpack_require__(0);

var Base = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(Base, _EventEmitter);

  var _proto = Base.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {};
  };

  function Base(cfg) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    var attrs = {
      visible: true
    };

    var defaultCfg = _this.getDefaultCfg();

    _this._attrs = attrs;
    Util.assign(attrs, defaultCfg, cfg);
    return _this;
  }

  _proto.get = function get(name) {
    return this._attrs[name];
  };

  _proto.set = function set(name, value) {
    this._attrs[name] = value;
  };

  _proto.show = function show() {
    var visible = this.get('visible');

    if (!visible) {
      this.set('visible', true);
      this.changeVisible(true);
    }
  };

  _proto.hide = function hide() {
    var visible = this.get('visible');

    if (visible) {
      this.set('visible', false);
      this.changeVisible(false);
    }
  }
  /**
   * @protected
   * @param {Boolean} visible 鏄惁鍙
   * 鏄剧ず銆侀殣钘�
   */
  ;

  _proto.changeVisible = function changeVisible()
  /* visible */
  {};

  _proto.destroy = function destroy() {
    this._attrs = {};
    this.removeAllListeners();
    this.destroyed = true;
  };

  return Base;
}(EventEmitter);

module.exports = Base;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  Scale: __webpack_require__(277),
  Coord: __webpack_require__(273),
  Axis: __webpack_require__(272),
  Guide: __webpack_require__(275),
  Legend: __webpack_require__(276),
  Tooltip: __webpack_require__(278),
  Event: __webpack_require__(274)
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var G = __webpack_require__(16);

var Util = __webpack_require__(0);

var mergeBBox = __webpack_require__(123);

function applyMatrix(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }

  var vector = [point.x, point.y, tag];
  Util.vec3.transformMat3(vector, vector, matrix);
  return {
    x: vector[0],
    y: vector[1]
  };
}

function getTitleBBox(title) {
  var bbox = title.getBBox();
  var leftTop = {
    x: bbox.minX,
    y: bbox.minY
  };
  var rightBottom = {
    x: bbox.maxX,
    y: bbox.maxY
  };
  var matrix = title.attr('matrix');
  leftTop = applyMatrix(leftTop, matrix);
  rightBottom = applyMatrix(rightBottom, matrix);
  return {
    minX: leftTop.x,
    minY: leftTop.y,
    maxX: rightBottom.x,
    maxY: rightBottom.y
  };
}

module.exports = function BBoxOfBackPlot(backPlot, defaultBBox) {
  var bbox = defaultBBox;
  Util.each(backPlot.get('children'), function (group) {
    // 杩欐浠ｇ爜鍋囪浜嗗瓙鍏冪礌鏄� axis锛屽悓鏃� title 瓒呭嚭闀垮害锛�
    // 杩欑涓存椂浠ｇ爜闇€瑕佸湪 4.0 涓慨澶嶆帀
    if (group instanceof G.Group) {
      Util.each(group.get('children'), function (element) {
        if (element instanceof G.Group && element.get('children').length || element instanceof G.Path) {
          bbox = mergeBBox(bbox, element.getBBox());
        } else if (element instanceof G.Text) {
          // title
          var elementBBox = getTitleBBox(element);
          bbox = mergeBBox(bbox, elementBBox);
        }
      });
    }
  });
  return bbox;
};

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = function mergeBBox(box1, box2) {
  return {
    minX: Math.min(box1.minX, box2.minX),
    minY: Math.min(box1.minY, box2.minY),
    maxX: Math.max(box1.maxX, box2.maxX),
    maxY: Math.max(box1.maxY, box2.maxY)
  };
};

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = function plotRange2BBox(plotRange) {
  return {
    minX: plotRange.tl.x,
    minY: plotRange.tl.y,
    maxX: plotRange.br.x,
    maxY: plotRange.br.y
  };
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview list facets, support cols
 */
var Base = __webpack_require__(46);
/**
 * 鐢ㄤ簬鐢熸垚鍒嗛潰鐨勭被
 * @class Facets.List
 */


var List = /*#__PURE__*/function (_Base) {
  _inheritsLoose(List, _Base);

  function List() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = List.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    cfg.type = 'list';
    cfg.cols = null; // 鐢ㄦ埛涓嶈缃椂灏辨樉绀轰竴琛�

    return cfg;
  };

  _proto.generateFacets = function generateFacets(data) {
    var self = this;
    var fields = self.fields;
    var colField = fields[0];

    if (!colField) {
      throw 'Please specify for the field for facet!';
    }

    var colValues = self.getFieldValues(colField, data);
    var count = colValues.length;
    var cols = self.cols || count;
    var rows = parseInt((count + cols - 1) / cols);
    var rst = [];
    colValues.forEach(function (xVal, index) {
      var row = parseInt(index / cols);
      var col = index % cols;
      var conditions = [{
        field: colField,
        value: xVal,
        values: colValues
      }];
      var filter = self.getFilter(conditions);
      var subData = data.filter(filter);
      var facet = {
        type: self.type,
        count: count,
        colValue: xVal,
        colField: colField,
        rowField: null,
        rowValue: xVal,
        colIndex: col,
        rowIndex: row,
        cols: cols,
        rows: rows,
        data: subData,
        region: self.getRegion(rows, cols, col, row)
      };
      rst.push(facet);
    });
    return rst;
  } // 璁剧疆 x 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setXAxis = function setXAxis(xField, axes, facet) {
    // 褰撴槸鏈€鍚庝竴琛屾垨鑰呬笅闈㈡病鏈� view 鏃舵枃鏈笉鏄剧ず
    if (facet.rowIndex !== facet.rows - 1 && facet.cols * facet.rowIndex + facet.colIndex + 1 + facet.cols <= facet.count) {
      axes[xField].label = null;
      axes[xField].title = null;
    }
  } // 璁剧疆 y 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setYAxis = function setYAxis(yField, axes, facet) {
    if (facet.colIndex !== 0) {
      axes[yField].title = null;
      axes[yField].label = null;
    }
  };

  return List;
}(Base);

module.exports = List;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 鍒嗛潰鐨勫熀绫�
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(46);
/**
 * 鐭╁舰鐨� facet 鏈変互涓嬪睘鎬э細
 * - colField 鍒楃殑瀛楁
 * - rowField 琛岀殑瀛楁
 * - colValue 鍒楀瓧娈电殑鍊�
 * - rowValue 琛屽瓧娈电殑鍊�
 * - cols 鍒楁暟
 * - rows 琛屾暟
 * - colIndex 鍒楃殑搴忓彿
 * - rowIndex 琛岀殑搴忓彿
 */

/**
 * 鐢ㄤ簬鐢熸垚鍒嗛潰鐨勭被
 * @class Facets.Rect
 */


var Rect = /*#__PURE__*/function (_Base) {
  _inheritsLoose(Rect, _Base);

  function Rect() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Rect.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    cfg.type = 'rect';
    return cfg;
  };

  _proto.generateFacets = function generateFacets(data) {
    var self = this;
    var fields = self.fields; // var defs = self.defs;

    var rst = [];
    var rows = 1;
    var cols = 1;
    var colField = fields[0];
    var rowField = fields[1];
    var colValues = [''];
    var rowValues = [''];

    if (colField) {
      colValues = self.getFieldValues(colField, data);
      cols = colValues.length;
    }

    if (rowField) {
      rowValues = self.getFieldValues(rowField, data);
      rows = rowValues.length;
    } // 鑾峰彇姣忎釜缁村害瀵瑰簲鐨刦rame


    colValues.forEach(function (xVal, xIndex) {
      rowValues.forEach(function (yVal, yIndex) {
        var conditions = [{
          field: colField,
          value: xVal,
          values: colValues
        }, {
          field: rowField,
          value: yVal,
          values: rowValues
        }];
        var filter = self.getFilter(conditions);
        var subData = data.filter(filter);
        var facet = {
          type: self.type,
          colValue: xVal,
          rowValue: yVal,
          colField: colField,
          rowField: rowField,
          colIndex: xIndex,
          rowIndex: yIndex,
          cols: cols,
          rows: rows,
          data: subData,
          region: self.getRegion(rows, cols, xIndex, yIndex)
        };
        rst.push(facet);
      });
    });
    return rst;
  } // 璁剧疆 x 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setXAxis = function setXAxis(xField, axes, facet) {
    if (facet.rowIndex !== facet.rows - 1) {
      axes[xField].title = null;
      axes[xField].label = null;
    } else if (facet.colIndex !== parseInt((facet.cols - 1) / 2)) {
      axes[xField].title = null;
    }
  } // 璁剧疆 y 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setYAxis = function setYAxis(yField, axes, facet) {
    if (facet.colIndex !== 0) {
      axes[yField].title = null;
      axes[yField].label = null;
    } else if (facet.rowIndex !== parseInt((facet.rows - 1) / 2)) {
      axes[yField].title = null;
    }
  };

  _proto.renderTitle = function renderTitle(view, facet) {
    if (facet.rowIndex === 0) {
      this.drawColTitle(view, facet);
    }

    if (facet.colIndex === facet.cols - 1) {
      this.drawRowTitle(view, facet);
    }
  };

  return Rect;
}(Base);

module.exports = Rect;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var Labels = __webpack_require__(69);

var PathUtil = __webpack_require__(25);

var Util = __webpack_require__(0);

var PolarLabels = function PolarLabels(cfg) {
  PolarLabels.superclass.constructor.call(this, cfg);
};

Util.extend(PolarLabels, Labels);
Util.augment(PolarLabels, {
  getPointRauis: function getPointRauis(coord, point) {
    return PathUtil.getPointRadius(coord, point);
  },
  getCirclePoint: function getCirclePoint(angle, offset, point) {
    var self = this;
    var coord = self.get('coord');
    var center = coord.getCenter();

    var labelEmit = self._isEmitLabels();

    var r = self.getPointRauis(coord, point);

    if (r === 0) {
      return null;
    }

    if (coord.isTransposed && r > offset && !labelEmit) {
      var appendAngle = Math.asin(offset / (2 * r));
      angle = angle + appendAngle * 2;
    } else {
      r = r + offset;
    }

    return {
      x: center.x + r * Math.cos(angle),
      y: center.y + r * Math.sin(angle),
      angle: angle,
      r: r
    };
  },
  getArcPoint: function getArcPoint(point, index) {
    var self = this;
    var outerPoint; // 鍦嗗姬涓婄殑涓偣
    // var coord = self.get('coord');

    index = index || 0;

    if (Util.isArray(point.x) || Util.isArray(point.y)) {
      outerPoint = {
        x: Util.isArray(point.x) ? point.x[index] : point.x,
        y: Util.isArray(point.y) ? point.y[index] : point.y
      };
    } else {
      outerPoint = point;
    }

    self.transLabelPoint(outerPoint);
    return outerPoint;
  },
  // 鑾峰彇鐐规墍鍦ㄧ殑瑙掑害
  getPointAngle: function getPointAngle(point) {
    var self = this;
    var coord = self.get('coord');
    return PathUtil.getPointAngle(coord, point);
  },
  // 鑾峰彇涓績鐨勪綅缃�
  getMiddlePoint: function getMiddlePoint(points) {
    var self = this;
    var coord = self.get('coord');
    var count = points.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    Util.each(points, function (point) {
      middlePoint.x += point.x;
      middlePoint.y += point.y;
    });
    middlePoint.x /= count;
    middlePoint.y /= count;
    middlePoint = coord.convert(middlePoint);
    return middlePoint;
  },
  // 鏄惁灞呬腑
  _isToMiddle: function _isToMiddle(point) {
    return point.x.length > 2;
  },

  /**
   * @protected
   * 鑾峰彇鏂囨湰鐨勪綅缃俊鎭�
   * @param {Array} label labels
   * @param {Object} point point
   * @param {Number} index index
   * @return {Object} point
   */
  getLabelPoint: function getLabelPoint(label, point, index) {
    // if (Util.isNil(point.x)) return;
    var self = this;
    var text = label.text[index];
    var factor = 1;
    var arcPoint;

    if (self._isToMiddle(point)) {
      arcPoint = self.getMiddlePoint(point.points);
    } else {
      if (label.text.length === 1 && index === 0) {
        index = 1;
      } else if (index === 0) {
        factor = -1;
      }

      arcPoint = self.getArcPoint(point, index);
    }

    var offset = self.getDefaultOffset(label);
    offset = offset * factor;
    var middleAngle = self.getPointAngle(arcPoint);
    var labelPoint = self.getCirclePoint(middleAngle, offset, arcPoint);

    if (!labelPoint) {
      labelPoint = {
        text: ''
      };
    } else {
      labelPoint.text = text;
      labelPoint.angle = middleAngle;
      labelPoint.color = point.color;
    }

    if (label.autoRotate || typeof label.autoRotate === 'undefined') {
      var rotate = labelPoint.textStyle ? labelPoint.textStyle.rotate : null;

      if (!rotate) {
        rotate = labelPoint.rotate || self.getLabelRotate(middleAngle, offset, point);
      }

      labelPoint.rotate = rotate;
    }

    labelPoint.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPoint;
  },
  _isEmitLabels: function _isEmitLabels() {
    var labels = this.get('label');
    return labels.labelEmit;
  },

  /**
   * @protected
   * 鑾峰彇鏂囨湰鏃嬭浆鐨勬柟鍚�
   * @param {Number} angle angle
   * @return {Number} angle
   */
  getLabelRotate: function getLabelRotate(angle) {
    var self = this;
    var rotate;
    rotate = angle * 180 / Math.PI;
    rotate += 90;

    if (self._isEmitLabels()) {
      rotate -= 90;
    }

    if (rotate) {
      if (rotate > 90) {
        rotate = rotate - 180;
      } else if (rotate < -90) {
        rotate = rotate + 180;
      }
    }

    return rotate / 180 * Math.PI;
  },
  // override
  getLabelAlign: function getLabelAlign(point) {
    var self = this;
    var coord = self.get('coord');
    var align;

    if (self._isEmitLabels()) {
      if (point.angle <= Math.PI / 2 && point.angle > -Math.PI / 2) {
        align = 'left';
      } else {
        align = 'right';
      }
    } else if (!coord.isTransposed) {
      align = 'center';
    } else {
      var center = coord.getCenter();
      var offset = self.getDefaultOffset(point);

      if (Math.abs(point.x - center.x) < 1) {
        align = 'center';
      } else if (point.angle > Math.PI || point.angle <= 0) {
        if (offset > 0) {
          align = 'left';
        } else {
          align = 'right';
        }
      } else {
        if (offset > 0) {
          align = 'right';
        } else {
          align = 'left';
        }
      }
    }

    return align;
  }
});
module.exports = PolarLabels;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 鍒嗗壊鏁版嵁鐢ㄤ簬澶勭悊瀛樺湪 null 鍊肩殑鎶樼嚎鍥俱€佸尯鍩熷浘
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var Global = __webpack_require__(5);

module.exports = {
  splitData: function splitData(data) {
    var viewTheme = this.get('viewTheme') || Global;
    if (!data.length) return [];
    var arr = [];
    var tmp = [];
    var yScale = this.getYScale();
    var yDim = yScale.field;
    var yValue;
    Util.each(data, function (obj) {
      yValue = obj._origin ? obj._origin[yDim] : obj[yDim];

      if (viewTheme.connectNulls) {
        // 濡傛灉蹇借 Null 鐩存帴杩炴帴鑺傜偣锛屽垯灏� value = null 鐨勬暟鎹繃婊ゆ帀
        if (!Util.isNil(yValue)) {
          tmp.push(obj);
        }
      } else {
        if (Util.isArray(yValue) && Util.isNil(yValue[0]) || Util.isNil(yValue)) {
          if (tmp.length) {
            arr.push(tmp);
            tmp = [];
          }
        } else {
          tmp.push(obj);
        }
      }
    });

    if (tmp.length) {
      arr.push(tmp);
    }

    return arr;
  }
};

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = {
  toFront: function toFront(shape) {
    var parent = shape.get('parent');
    var originIndex = parent.get('children').indexOf(shape);
    shape.set('_originIndex', originIndex);
    shape.toFront(); // 绉诲姩鍒版渶涓婇潰
  },
  resetZIndex: function resetZIndex(shape) {
    var parent = shape.get('parent');
    var originIndex = shape.get('_originIndex');
    var siblings = parent.get('children');
    var currentIndex = siblings.indexOf(shape);

    if (originIndex >= 0 && originIndex !== currentIndex) {
      siblings.splice(currentIndex, 1); // 浠庢暟缁勪腑绉婚櫎

      siblings.splice(originIndex, 0, shape); // 閲嶆柊鍔犲叆鏁扮粍锛岃繑鍥炲師鍏堢殑浣嶇疆
    }
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 璺緞鍥撅紝鏃犲簭鐨勭嚎鍥�
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var SplitMixin = __webpack_require__(128);

var Util = __webpack_require__(0);

var Path = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Path, _GeomBase);

  var _proto = Path.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'path';
    cfg.shapeType = 'line';
    return cfg;
  };

  function Path(cfg) {
    var _this;

    _this = _GeomBase.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), SplitMixin);
    return _this;
  }

  _proto.getDrawCfg = function getDrawCfg(obj) {
    var cfg = _GeomBase.prototype.getDrawCfg.call(this, obj);

    cfg.isStack = this.hasStack();
    return cfg;
  };

  _proto.draw = function draw(data, container, shapeFactory, index) {
    var self = this;
    var splitArray = this.splitData(data);
    var cfg = this.getDrawCfg(data[0]);

    self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);

    cfg.origin = data; // path,line 绛夊浘鐨刼rigin 鏄暣涓簭鍒�

    Util.each(splitArray, function (subData, splitedIndex) {
      if (!Util.isEmpty(subData)) {
        cfg.splitedIndex = splitedIndex; // 浼犲叆鍒嗗壊鐗囨绱㈠紩 鐢ㄤ簬鐢熸垚id

        cfg.points = subData;
        var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);
        self.appendShapeInfo(geomShape, index + splitedIndex);
      }
    });
  };

  return Path;
}(GeomBase);

GeomBase.Path = Path;
module.exports = Path;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

var _html, _tooltip;

/**
 * @fileOverview G2 3.0 default theme
 * @author sima.zhang
 */
var DEFAULT_COLOR = '#1890FF';
var COLOR_PLATE_8 = ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'];
var COLOR_PLATE_16 = ['#1890FF', '#41D9C7', '#2FC25B', '#FACC14', '#E6965C', '#223273', '#7564CC', '#8543E0', '#5C8EE6', '#13C2C2', '#5CA3E6', '#3436C7', '#B381E6', '#F04864', '#D598D9'];
var COLOR_PLATE_24 = ['#1890FF', '#66B5FF', '#41D9C7', '#2FC25B', '#6EDB8F', '#9AE65C', '#FACC14', '#E6965C', '#57AD71', '#223273', '#738AE6', '#7564CC', '#8543E0', '#A877ED', '#5C8EE6', '#13C2C2', '#70E0E0', '#5CA3E6', '#3436C7', '#8082FF', '#DD81E6', '#F04864', '#FA7D92', '#D598D9'];
var COLOR_PIE = ['#1890FF', '#13C2C2', '#2FC25B', '#FACC14', '#F04864', '#8543E0', '#3436C7', '#223273'];
var COLOR_PIE_16 = ['#1890FF', '#73C9E6', '#13C2C2', '#6CD9B3', '#2FC25B', '#9DD96C', '#FACC14', '#E6965C', '#F04864', '#D66BCA', '#8543E0', '#8E77ED', '#3436C7', '#737EE6', '#223273', '#7EA2E6'];
var FONT_FAMILY = '"-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",SimSun, "sans-serif"'; // tooltip 鐩稿叧 dom 鐨� css 绫诲悕

var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
var TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';
var TOOLTIP_LIST_CLASS = 'g2-tooltip-list';
var TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';
var TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';
var TOOLTIP_VALUE_CLASS = 'g2-tooltip-value'; // html 娓叉煋鐨� legend 鐩稿叧 dom 鐨� css 绫诲瀷

var LEGEND_CONTAINER_CLASS = 'g2-legend';
var LEGEND_TITLE_CLASS = 'g2-legend-title';
var LEGEND_LIST_CLASS = 'g2-legend-list';
var LEGEND_LIST_ITEM_CLASS = 'g2-legend-list-item';
var LEGEND_MARKER_CLASS = 'g2-legend-marker';
var Theme = {
  defaultColor: DEFAULT_COLOR,
  // 榛樿涓婚鑹�
  plotCfg: {
    padding: [20, 20, 95, 80]
  },
  fontFamily: FONT_FAMILY,
  defaultLegendPosition: 'bottom',
  // 榛樿鍥句緥鐨勫睍绀轰綅缃�
  colors: COLOR_PLATE_8,
  colors_16: COLOR_PLATE_16,
  colors_24: COLOR_PLATE_24,
  colors_pie: COLOR_PIE,
  colors_pie_16: COLOR_PIE_16,
  shapes: {
    point: ['hollowCircle', 'hollowSquare', 'hollowDiamond', 'hollowBowtie', 'hollowTriangle', 'hollowHexagon', 'cross', 'tick', 'plus', 'hyphen', 'line'],
    line: ['line', 'dash', 'dot'],
    area: ['area']
  },
  sizes: [1, 10],
  opacities: [0.1, 0.9],
  axis: {
    top: {
      // zIndex: 1, // 榛樿涓婁笅鏂瑰悜鐨勫潗鏍囪酱浣嶄簬宸﹀彸鍧愭爣杞寸殑涓婃柟
      position: 'top',
      title: null,
      label: {
        offset: 16,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          lineHeight: 16,
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        },
        autoRotate: true
      },
      line: {
        lineWidth: 1,
        stroke: '#BFBFBF'
      },
      tickLine: {
        lineWidth: 1,
        stroke: '#BFBFBF',
        length: 4,
        alignWithLabel: true
      }
    },
    bottom: {
      position: 'bottom',
      title: null,
      label: {
        offset: 16,
        autoRotate: true,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          lineHeight: 16,
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        }
      },
      line: {
        lineWidth: 1,
        stroke: '#BFBFBF'
      },
      tickLine: {
        lineWidth: 1,
        stroke: '#BFBFBF',
        length: 4,
        alignWithLabel: true
      }
    },
    left: {
      position: 'left',
      title: null,
      label: {
        offset: 8,
        autoRotate: true,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          lineHeight: 16,
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        }
      },
      line: null,
      tickLine: null,
      grid: {
        zIndex: -1,
        lineStyle: {
          stroke: '#E9E9E9',
          lineWidth: 1,
          lineDash: [3, 3]
        },
        hideFirstLine: true
      }
    },
    right: {
      position: 'right',
      title: null,
      label: {
        offset: 8,
        autoRotate: true,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          lineHeight: 16,
          textBaseline: 'middle',
          fontFamily: FONT_FAMILY
        }
      },
      line: null,
      tickLine: null,
      grid: {
        lineStyle: {
          stroke: '#E9E9E9',
          lineWidth: 1,
          lineDash: [3, 3]
        },
        hideFirstLine: true
      }
    },
    circle: {
      zIndex: 1,
      title: null,
      label: {
        offset: 8,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          lineHeight: 16,
          fontFamily: FONT_FAMILY
        }
      },
      line: {
        lineWidth: 1,
        stroke: '#BFBFBF'
      },
      tickLine: {
        lineWidth: 1,
        stroke: '#BFBFBF',
        length: 4,
        alignWithLabel: true
      },
      grid: {
        lineStyle: {
          stroke: '#E9E9E9',
          lineWidth: 1,
          lineDash: [3, 3]
        },
        hideFirstLine: true
      }
    },
    radius: {
      zIndex: 0,
      label: {
        offset: 12,
        textStyle: {
          fill: '#545454',
          fontSize: 12,
          textBaseline: 'middle',
          lineHeight: 16,
          fontFamily: FONT_FAMILY
        }
      },
      line: {
        lineWidth: 1,
        stroke: '#BFBFBF'
      },
      tickLine: {
        lineWidth: 1,
        stroke: '#BFBFBF',
        length: 4,
        alignWithLabel: true
      },
      grid: {
        lineStyle: {
          stroke: '#E9E9E9',
          lineWidth: 1,
          lineDash: [3, 3]
        },
        type: 'circle'
      }
    },
    helix: {
      grid: null,
      label: null,
      title: null,
      line: {
        lineWidth: 1,
        stroke: '#BFBFBF'
      },
      tickLine: {
        lineWidth: 1,
        length: 4,
        stroke: '#BFBFBF',
        alignWithLabel: true
      }
    }
  },
  label: {
    offset: 20,
    textStyle: {
      fill: '#545454',
      fontSize: 12,
      textBaseline: 'middle',
      fontFamily: FONT_FAMILY
    }
  },
  treemapLabels: {
    offset: 10,
    textStyle: {
      fill: '#fff',
      fontSize: 12,
      textBaseline: 'top',
      fontStyle: 'bold',
      fontFamily: FONT_FAMILY
    }
  },
  innerLabels: {
    textStyle: {
      fill: '#fff',
      fontSize: 12,
      textBaseline: 'middle',
      fontFamily: FONT_FAMILY
    }
  },
  // 鍦╰heta鍧愭爣绯讳笅鐨勯ゼ鍥炬枃鏈唴閮ㄧ殑鏍峰紡
  thetaLabels: {
    labelHeight: 14,
    offset: 30 // 鍦╰heta鍧愭爣绯讳笅鐨勯ゼ鍥炬枃鏈殑鏍峰紡

  },
  legend: {
    right: {
      position: 'right',
      layout: 'vertical',
      itemMarginBottom: 8,
      // layout 涓� vertical 鏃跺悇涓浘渚嬮」鐨勯棿璺�
      width: 16,
      height: 156,
      title: null,
      legendStyle: {
        LIST_CLASS: {
          textAlign: 'left'
        }
      },
      textStyle: {
        fill: '#8C8C8C',
        fontSize: 12,
        textAlign: 'start',
        textBaseline: 'middle',
        lineHeight: 0,
        fontFamily: FONT_FAMILY
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    left: {
      position: 'left',
      layout: 'vertical',
      itemMarginBottom: 8,
      width: 16,
      height: 156,
      title: null,
      textStyle: {
        fill: '#8C8C8C',
        fontSize: 12,
        textAlign: 'start',
        textBaseline: 'middle',
        lineHeight: 20,
        fontFamily: FONT_FAMILY
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    top: {
      position: 'top',
      offset: [0, 6],
      layout: 'horizontal',
      title: null,
      itemGap: 10,
      width: 156,
      height: 16,
      textStyle: {
        fill: '#8C8C8C',
        fontSize: 12,
        textAlign: 'start',
        textBaseline: 'middle',
        lineHeight: 20,
        fontFamily: FONT_FAMILY
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    bottom: {
      position: 'bottom',
      offset: [0, 6],
      layout: 'horizontal',
      title: null,
      itemGap: 10,
      width: 156,
      height: 16,
      textStyle: {
        fill: '#8C8C8C',
        fontSize: 12,
        textAlign: 'start',
        textBaseline: 'middle',
        lineHeight: 20,
        fontFamily: FONT_FAMILY
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    // 瀹氫箟 html 娓叉煋鍥句緥鐨勬牱寮�
    html: (_html = {}, _html["" + LEGEND_CONTAINER_CLASS] = {
      height: 'auto',
      width: 'auto',
      position: 'absolute',
      overflow: 'auto',
      fontSize: '12px',
      fontFamily: FONT_FAMILY,
      lineHeight: '20px',
      color: '#8C8C8C'
    }, _html["" + LEGEND_TITLE_CLASS] = {
      marginBottom: '4px'
    }, _html["" + LEGEND_LIST_CLASS] = {
      listStyleType: 'none',
      margin: 0,
      padding: 0
    }, _html["" + LEGEND_LIST_ITEM_CLASS] = {
      listStyleType: 'none',
      cursor: 'pointer',
      marginBottom: '5px',
      marginRight: '24px'
    }, _html["" + LEGEND_MARKER_CLASS] = {
      width: '9px',
      height: '9px',
      borderRadius: '50%',
      display: 'inline-block',
      marginRight: '8px',
      verticalAlign: 'middle'
    }, _html),
    // 涓嶈兘婊戝姩鐨勮繛缁浘渚嬫牱寮�
    gradient: {
      textStyle: {
        fill: '#8C8C8C',
        fontSize: 12,
        textAlign: 'center',
        textBaseline: 'middle',
        lineHeight: 20,
        fontFamily: FONT_FAMILY
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      lineStyle: {
        lineWidth: 1,
        stroke: '#fff'
      },
      unCheckColor: '#bfbfbf'
    },
    margin: [0, 5, 24, 5],
    // 鍥句緥璺熷洓涓竟鐨勫潗鏍囪酱銆佺粯鍥惧尯鍩熺殑闂磋窛
    legendMargin: 24 // 鍥句緥涔嬮棿鐨勯棿璺�

  },
  tooltip: (_tooltip = {
    useHtml: true,
    crosshairs: false,
    offset: 15,
    marker: {
      symbol: 'circle',
      activeSymbol: 'circle'
    }
  }, _tooltip["" + TOOLTIP_CONTAINER_CLASS] = {
    position: 'absolute',
    visibility: 'hidden',
    // @2018-07-25 by blue.lb 杩欓噷鍘绘帀娴姩锛岀伀鐙愪笂瀛樺湪鏍峰紡閿欎綅
    // whiteSpace: 'nowrap',
    zIndex: 8,
    transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    boxShadow: '0px 0px 10px #aeaeae',
    borderRadius: '3px',
    color: 'rgb(87, 87, 87)',
    fontSize: '12px',
    fontFamily: FONT_FAMILY,
    lineHeight: '20px',
    padding: '10px 10px 6px 10px'
  }, _tooltip["" + TOOLTIP_TITLE_CLASS] = {
    marginBottom: '4px'
  }, _tooltip["" + TOOLTIP_LIST_CLASS] = {
    margin: 0,
    listStyleType: 'none',
    padding: 0
  }, _tooltip["" + TOOLTIP_LIST_ITEM_CLASS] = {
    listStyleType: 'none',
    marginBottom: '4px',
    padding: 0,
    marginTop: 0,
    marginLeft: 0,
    marginRight: 0
  }, _tooltip["" + TOOLTIP_MARKER_CLASS] = {
    width: '5px',
    height: '5px',
    display: 'inline-block',
    marginRight: '8px'
  }, _tooltip["" + TOOLTIP_VALUE_CLASS] = {
    display: 'inline-block',
    float: 'right',
    marginLeft: '30px'
  }, _tooltip),
  tooltipMarker: {
    symbol: function symbol(x, y, r) {
      return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
    },
    stroke: '#fff',
    shadowBlur: 10,
    shadowOffsetX: 0,
    shadowOffSetY: 0,
    shadowColor: 'rgba(0,0,0,0.09)',
    lineWidth: 2,
    radius: 4
  },
  // 鎻愮ず淇℃伅鍦ㄦ姌绾垮浘銆佸尯鍩熷浘涓婂舰鎴愮偣鐨勬牱寮�
  tooltipCrosshairsRect: {
    type: 'rect',
    rectStyle: {
      fill: '#CCD6EC',
      opacity: 0.3
    }
  },
  // tooltip 杈呭姪鑳屾櫙妗嗘牱寮�
  tooltipCrosshairsLine: {
    lineStyle: {
      stroke: 'rgba(0, 0, 0, 0.25)',
      lineWidth: 1
    }
  },
  shape: {
    point: {
      lineWidth: 1,
      fill: DEFAULT_COLOR,
      radius: 4
    },
    hollowPoint: {
      fill: '#fff',
      lineWidth: 1,
      stroke: DEFAULT_COLOR,
      radius: 3
    },
    interval: {
      lineWidth: 0,
      fill: DEFAULT_COLOR,
      fillOpacity: 0.85
    },
    hollowInterval: {
      fill: '#fff',
      stroke: DEFAULT_COLOR,
      fillOpacity: 0,
      lineWidth: 2
    },
    area: {
      lineWidth: 0,
      fill: DEFAULT_COLOR,
      fillOpacity: 0.6
    },
    polygon: {
      lineWidth: 0,
      fill: DEFAULT_COLOR,
      fillOpacity: 1
    },
    hollowPolygon: {
      fill: '#fff',
      stroke: DEFAULT_COLOR,
      fillOpacity: 0,
      lineWidth: 2
    },
    hollowArea: {
      fill: '#fff',
      stroke: DEFAULT_COLOR,
      fillOpacity: 0,
      lineWidth: 2
    },
    line: {
      stroke: DEFAULT_COLOR,
      lineWidth: 2,
      fill: null
    },
    edge: {
      stroke: DEFAULT_COLOR,
      lineWidth: 1,
      fill: null
    },
    schema: {
      stroke: DEFAULT_COLOR,
      lineWidth: 1,
      fill: null
    }
  },
  guide: {
    line: {
      lineStyle: {
        stroke: 'rgba(0, 0, 0, .65)',
        lineDash: [2, 2],
        lineWidth: 1
      },
      text: {
        position: 'start',
        autoRotate: true,
        style: {
          fill: 'rgba(0, 0, 0, .45)',
          fontSize: 12,
          textAlign: 'start',
          fontFamily: FONT_FAMILY,
          textBaseline: 'bottom'
        }
      }
    },
    text: {
      style: {
        fill: 'rgba(0,0,0,.5)',
        fontSize: 12,
        textBaseline: 'middle',
        textAlign: 'start',
        fontFamily: FONT_FAMILY
      }
    },
    region: {
      style: {
        lineWidth: 0,
        // 杈呭姪妗嗙殑杈规瀹藉害
        fill: '#000',
        // 杈呭姪妗嗗～鍏呯殑棰滆壊
        fillOpacity: 0.04 // 杈呭姪妗嗙殑鑳屾櫙閫忔槑搴�

      } // 杈呭姪妗嗙殑鍥惧舰鏍峰紡灞炴€�

    },
    html: {
      alignX: 'middle',
      alignY: 'middle'
    },
    dataRegion: {
      style: {
        region: {
          lineWidth: 0,
          fill: '#000000',
          opacity: 0.04
        },
        text: {
          textAlign: 'center',
          textBaseline: 'bottom',
          fontSize: 12,
          fill: 'rgba(0, 0, 0, .65)'
        }
      }
    },
    dataMarker: {
      top: true,
      style: {
        point: {
          r: 3,
          fill: '#FFFFFF',
          stroke: '#1890FF',
          lineWidth: 2
        },
        line: {
          stroke: '#A3B1BF',
          lineWidth: 1
        },
        text: {
          fill: 'rgba(0, 0, 0, .65)',
          opacity: 1,
          fontSize: 12,
          textAlign: 'start'
        }
      },
      display: {
        point: true,
        line: true,
        text: true
      },
      lineLength: 20,
      direction: 'upward',
      autoAdjust: true
    }
  },
  pixelRatio: null
};
module.exports = Theme;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Theme entry
 * @author sima.zhang
 */
var Theme = {
  default: __webpack_require__(131),
  dark: __webpack_require__(327)
};
module.exports = Theme;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Attribute = __webpack_require__(330);

var Transform = __webpack_require__(333);

var Animate = __webpack_require__(329);

var EventEmitter = __webpack_require__(105);

var Element = function Element(cfg) {
  this._cfg = {
    zIndex: 0,
    capture: true,
    visible: true,
    destroyed: false
  }; // 閰嶇疆瀛樻斁鍦�

  Util.assign(this._cfg, this.getDefaultCfg(), cfg); // Element.CFG涓嶅悎骞讹紝鎻愬崌鎬ц兘 鍚堝苟榛樿閰嶇疆锛岀敤鎴烽厤缃�->缁ф壙榛樿閰嶇疆->Element榛樿閰嶇疆

  this.initAttrs(this._cfg.attrs); // 鍒濆鍖栫粯鍥惧睘鎬�

  this._cfg.attrs = {};
  this.initTransform(); // 鍒濆鍖栧彉鎹�

  this.init(); // 绫诲瀷鍒濆鍖�
};

Element.CFG = {
  /**
   * 鍞竴鏍囩ず
   * @type {Number}
   */
  id: null,

  /**
   * Z杞寸殑灞傚彔鍏崇郴锛孼鍊艰秺澶х鐢ㄦ埛瓒婅繎
   * @type {Number}
   */
  zIndex: 0,

  /**
   * Canvas瀵硅薄
   * @type: {Object}
   */
  canvas: null,

  /**
   * 鐖跺厓绱犳寚閽�
   * @type {Object}
   */
  parent: null,

  /**
   * 鐢ㄦ潵璁剧疆褰撳墠瀵硅薄鏄惁鑳借鎹曟崏
   * true 鑳�
   * false 涓嶈兘
   * 瀵硅薄榛樿鏄兘鍙互琚崟鎹夌殑, 褰揷apture涓篺alse鏃讹紝group.getShape(x, y)鏂规硶鏃犳硶鑾峰緱璇ュ厓绱�
   * 閫氳繃灏嗕笉蹇呰鎹曟崏鐨勫厓绱犵殑璇ュ睘鎬ц缃垚false, 鏉ユ彁楂樻崟鎹夋€ц兘
   * @type {Boolean}
   **/
  capture: true,

  /**
   * 鐢诲竷鐨勪笂涓嬫枃
   * @type {Object}
   */
  context: null,

  /**
   * 鏄惁鏄剧ず
   * @type {Boolean}
   */
  visible: true,

  /**
   * 鏄惁琚攢姣�
   * @type: {Boolean}
   */
  destroyed: false
};
Util.augment(Element, Attribute, Transform, EventEmitter, Animate, {
  init: function init() {
    this.setSilent('animable', true);
    this.setSilent('animating', false); // 鍒濆鏃朵笉澶勪簬鍔ㄧ敾鐘舵€�
  },
  getParent: function getParent() {
    return this._cfg.parent;
  },

  /**
   * 鑾峰彇榛樿鐨勯厤缃俊鎭�
   * @protected
   * @return {Object} 榛樿鐨勫睘鎬�
   */
  getDefaultCfg: function getDefaultCfg() {
    return {};
  },
  set: function set(name, value) {
    if (name === 'zIndex' && this._beforeSetZIndex) {
      this._beforeSetZIndex(value);
    }

    if (name === 'loading' && this._beforeSetLoading) {
      this._beforeSetLoading(value);
    }

    this._cfg[name] = value;
    return this;
  },
  // deprecated
  setSilent: function setSilent(name, value) {
    this._cfg[name] = value;
  },
  get: function get(name) {
    return this._cfg[name];
  },
  show: function show() {
    this._cfg.visible = true;
    return this;
  },
  hide: function hide() {
    this._cfg.visible = false;
    return this;
  },
  remove: function remove(destroy, delayRemove) {
    var cfg = this._cfg;
    var parent = cfg.parent;
    var el = cfg.el;

    if (parent) {
      Util.remove(parent.get('children'), this);
    }

    if (el) {
      if (delayRemove) {
        parent && parent._cfg.tobeRemoved.push(el);
      } else {
        el.parentNode.removeChild(el);
      }
    }

    if (destroy || destroy === undefined) {
      this.destroy();
    }

    return this;
  },
  destroy: function destroy() {
    var destroyed = this.get('destroyed');

    if (destroyed) {
      return;
    }

    this._attrs = null;
    this.removeEvent(); // 绉婚櫎鎵€鏈夌殑浜嬩欢

    this._cfg = {
      destroyed: true
    };
  },
  toFront: function toFront() {
    var cfg = this._cfg;
    var parent = cfg.parent;

    if (!parent) {
      return;
    }

    var children = parent._cfg.children;
    var el = cfg.el;
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.push(this);

    if (el) {
      el.parentNode.removeChild(el);
      cfg.el = null;
    }
  },
  toBack: function toBack() {
    var cfg = this._cfg;
    var parent = cfg.parent;

    if (!parent) {
      return;
    }

    var children = parent._cfg.children;
    var el = cfg.el;
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.unshift(this);

    if (el) {
      var parentNode = el.parentNode;
      parentNode.removeChild(el);
      parentNode.insertBefore(el, parentNode.firstChild);
    }
  },
  _beforeSetZIndex: function _beforeSetZIndex(zIndex) {
    var parent = this._cfg.parent;
    this._cfg.zIndex = zIndex;

    if (!Util.isNil(parent)) {
      parent.sort();
    }

    var el = this._cfg.el;

    if (el) {
      var children = parent._cfg.children;
      var index = children.indexOf(this);
      var parentNode = el.parentNode;
      parentNode.removeChild(el);

      if (index === children.length - 1) {
        parentNode.appendChild(el);
      } else {
        parentNode.insertBefore(el, parentNode.childNodes[index]);
      }
    }

    return zIndex;
  },
  _setAttrs: function _setAttrs(attrs) {
    this.attr(attrs);
    return attrs;
  },
  setZIndex: function setZIndex(zIndex) {
    this._cfg.zIndex = zIndex;
    return this._beforeSetZIndex(zIndex);
  },
  clone: function clone() {
    return Util.clone(this);
  },
  getBBox: function getBBox() {}
});
module.exports = Element;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Element = __webpack_require__(133);

var Shape = __webpack_require__(347);

var SHAPE_MAP = {}; // 缂撳瓨鍥惧舰绫诲瀷

var INDEX = '_INDEX';

function getComparer(compare) {
  return function (left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}

function find(children, x, y) {
  var rst;

  for (var i = children.length - 1; i >= 0; i--) {
    var child = children[i];

    if (child._cfg.visible && child._cfg.capture) {
      if (child.isGroup) {
        rst = child.getShape(x, y);
      } else if (child.isHit(x, y)) {
        rst = child;
      }
    }

    if (rst) {
      break;
    }
  }

  return rst;
}

var Group = function Group(cfg) {
  Group.superclass.constructor.call(this, cfg);
  this.set('children', []);
  this.set('tobeRemoved', []);

  this._beforeRenderUI();

  this._renderUI();

  this._bindUI();
};

function initClassCfgs(c) {
  if (c._cfg || c === Group) {
    return;
  }

  var superCon = c.superclass.constructor;

  if (superCon && !superCon._cfg) {
    initClassCfgs(superCon);
  }

  c._cfg = {};
  Util.merge(c._cfg, superCon._cfg);
  Util.merge(c._cfg, c.CFG);
}

Util.extend(Group, Element);
Util.augment(Group, {
  isGroup: true,
  type: 'group',
  canFill: true,
  canStroke: true,
  getDefaultCfg: function getDefaultCfg() {
    initClassCfgs(this.constructor);
    return Util.merge({}, this.constructor._cfg);
  },
  _beforeRenderUI: function _beforeRenderUI() {},
  _renderUI: function _renderUI() {},
  _bindUI: function _bindUI() {},
  addShape: function addShape(type, cfg) {
    var canvas = this.get('canvas');
    cfg = cfg || {};
    var shapeType = SHAPE_MAP[type];

    if (!shapeType) {
      shapeType = Util.upperFirst(type);
      SHAPE_MAP[type] = shapeType;
    }

    if (cfg.attrs && canvas) {
      var attrs = cfg.attrs;

      if (type === 'text') {
        // 涓存椂瑙ｅ喅
        var topFontFamily = canvas.get('fontFamily');

        if (topFontFamily) {
          attrs.fontFamily = attrs.fontFamily ? attrs.fontFamily : topFontFamily;
        }
      }
    }

    cfg.canvas = canvas;
    cfg.type = type;
    var rst = new Shape[shapeType](cfg);
    this.add(rst);
    return rst;
  },

  /** 娣诲姞鍥剧粍
   * @param  {Function|Object|undefined} param 鍥剧粍绫�
   * @param  {Object} cfg 閰嶇疆椤�
   * @return {Object} rst 鍥剧粍
   */
  addGroup: function addGroup(param, cfg) {
    var canvas = this.get('canvas');
    var rst;
    cfg = Util.merge({}, cfg);

    if (Util.isFunction(param)) {
      if (cfg) {
        cfg.canvas = canvas;
        cfg.parent = this;
        rst = new param(cfg);
      } else {
        rst = new param({
          canvas: canvas,
          parent: this
        });
      }

      this.add(rst);
    } else if (Util.isObject(param)) {
      param.canvas = canvas;
      rst = new Group(param);
      this.add(rst);
    } else if (param === undefined) {
      rst = new Group();
      this.add(rst);
    } else {
      return false;
    }

    return rst;
  },

  /** 缁樺埗鑳屾櫙
   * @param  {Array} padding 鍐呰竟璺�
   * @param  {Attrs} attrs 鍥惧舰灞炴€�
   * @param  {Shape} backShape 鑳屾櫙鍥惧舰
   * @return {Object} 鑳屾櫙灞傚璞�
   */
  renderBack: function renderBack(padding, attrs) {
    var backShape = this.get('backShape');
    var innerBox = this.getBBox(); // const parent = this.get('parent'); // getParent

    Util.merge(attrs, {
      x: innerBox.minX - padding[3],
      y: innerBox.minY - padding[0],
      width: innerBox.width + padding[1] + padding[3],
      height: innerBox.height + padding[0] + padding[2]
    });

    if (backShape) {
      backShape.attr(attrs);
    } else {
      backShape = this.addShape('rect', {
        zIndex: -1,
        attrs: attrs
      });
    }

    this.set('backShape', backShape);
    this.sort();
    return backShape;
  },
  removeChild: function removeChild(item, destroy) {
    if (arguments.length >= 2) {
      if (this.contain(item)) {
        item.remove(destroy);
      }
    } else {
      if (arguments.length === 1) {
        if (Util.isBoolean(item)) {
          destroy = item;
        } else {
          if (this.contain(item)) {
            item.remove(true);
          }

          return this;
        }
      }

      if (arguments.length === 0) {
        destroy = true;
      }

      Group.superclass.remove.call(this, destroy);
    }

    return this;
  },

  /**
   * 鍚戠粍涓坊鍔爏hape鎴栬€単roup
   * @param {Object} items 鍥惧舰鎴栬€呭垎缁�
   * @return {Object} group 鏈皧
   */
  add: function add(items) {
    var self = this;
    var children = self.get('children');

    if (Util.isArray(items)) {
      Util.each(items, function (item) {
        var parent = item.get('parent');

        if (parent) {
          parent.removeChild(item, false);
        }

        self._setCfgProperty(item);
      });
      self._cfg.children = children.concat(items);
    } else {
      var item = items;
      var parent = item.get('parent');

      if (parent) {
        parent.removeChild(item, false);
      }

      self._setCfgProperty(item);

      children.push(item);
    }

    return self;
  },
  _setCfgProperty: function _setCfgProperty(item) {
    var cfg = this._cfg;
    item.set('parent', this);
    item.set('canvas', cfg.canvas);

    if (cfg.timeline) {
      item.set('timeline', cfg.timeline);
    }
  },
  contain: function contain(item) {
    var children = this.get('children');
    return children.indexOf(item) > -1;
  },
  getChildByIndex: function getChildByIndex(index) {
    var children = this.get('children');
    return children[index];
  },
  getFirst: function getFirst() {
    return this.getChildByIndex(0);
  },
  getLast: function getLast() {
    var lastIndex = this.get('children').length - 1;
    return this.getChildByIndex(lastIndex);
  },
  getBBox: function getBBox() {
    var self = this;
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var children = self.get('children');

    if (children.length > 0) {
      Util.each(children, function (child) {
        if (child.get('visible')) {
          if (child.isGroup && child.get('children').length === 0) {
            return;
          }

          var _box = child.getBBox();

          if (!_box) {
            return true;
          }

          var leftTop = [_box.minX, _box.minY, 1];
          var leftBottom = [_box.minX, _box.maxY, 1];
          var rightTop = [_box.maxX, _box.minY, 1];
          var rightBottom = [_box.maxX, _box.maxY, 1];
          child.apply(leftTop);
          child.apply(leftBottom);
          child.apply(rightTop);
          child.apply(rightBottom);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);

          if (boxMinX < minX) {
            minX = boxMinX;
          }

          if (boxMaxX > maxX) {
            maxX = boxMaxX;
          }

          if (boxMinY < minY) {
            minY = boxMinY;
          }

          if (boxMaxY > maxY) {
            maxY = boxMaxY;
          }
        }
      });
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }

    var box = {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
    box.x = box.minX;
    box.y = box.minY;
    box.width = box.maxX - box.minX;
    box.height = box.maxY - box.minY;
    return box;
  },
  getCount: function getCount() {
    return this.get('children').length;
  },
  sort: function sort() {
    var children = this.get('children'); // 绋冲畾鎺掑簭

    Util.each(children, function (child, index) {
      child[INDEX] = index;
      return child;
    });
    children.sort(getComparer(function (obj1, obj2) {
      return obj1.get('zIndex') - obj2.get('zIndex');
    }));
    return this;
  },
  findById: function findById(id) {
    return this.find(function (item) {
      return item.get('id') === id;
    });
  },

  /**
   * 鏍规嵁鏌ユ壘鍑芥暟鏌ユ壘鍒嗙粍鎴栬€呭浘褰�
   * @param  {Function} fn 鍖归厤鍑芥暟
   * @return {Canvas.Base} 鍒嗙粍鎴栬€呭浘褰�
   */
  find: function find(fn) {
    if (Util.isString(fn)) {
      return this.findById(fn);
    }

    var children = this.get('children');
    var rst = null;
    Util.each(children, function (item) {
      if (fn(item)) {
        rst = item;
      } else if (item.find) {
        rst = item.find(fn);
      }

      if (rst) {
        return false;
      }
    });
    return rst;
  },

  /**
   * @param  {Function} fn filter mathod
   * @return {Array} all the matching shapes and groups
   */
  findAll: function findAll(fn) {
    var children = this.get('children');
    var rst = [];
    var childRst = [];
    Util.each(children, function (item) {
      if (fn(item)) {
        rst.push(item);
      }

      if (item.findAllBy) {
        childRst = item.findAllBy(fn);
        rst = rst.concat(childRst);
      }
    });
    return rst;
  },

  /**
   * @Deprecated
   * @param  {Function} fn filter method
   * @return {Object} found shape or group
   */
  findBy: function findBy(fn) {
    var children = this.get('children');
    var rst = null;
    Util.each(children, function (item) {
      if (fn(item)) {
        rst = item;
      } else if (item.findBy) {
        rst = item.findBy(fn);
      }

      if (rst) {
        return false;
      }
    });
    return rst;
  },

  /**
   * @Deprecated
   * @param  {Function} fn filter mathod
   * @return {Array} all the matching shapes and groups
   */
  findAllBy: function findAllBy(fn) {
    var children = this.get('children');
    var rst = [];
    var childRst = [];
    Util.each(children, function (item) {
      if (fn(item)) {
        rst.push(item);
      }

      if (item.findAllBy) {
        childRst = item.findAllBy(fn);
        rst = rst.concat(childRst);
      }
    });
    return rst;
  },
  getShape: function getShape(x, y) {
    var self = this;
    var clip = self._attrs.clip;
    var children = self._cfg.children;
    var rst;

    if (clip) {
      var v = [x, y, 1];
      clip.invert(v, self.get('canvas')); // 宸茬粡鍦ㄥ闈㈣浆鎹�

      if (clip.isPointInPath(v[0], v[1])) {
        rst = find(children, x, y);
      }
    } else {
      rst = find(children, x, y);
    }

    return rst;
  },
  clearTotalMatrix: function clearTotalMatrix() {
    var m = this.get('totalMatrix');

    if (m) {
      this.setSilent('totalMatrix', null);
      var children = this._cfg.children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child.clearTotalMatrix();
      }
    }
  },
  clear: function clear(delayRemove) {
    var children = this._cfg.children;

    for (var i = children.length - 1; i >= 0; i--) {
      children[i].remove(true, delayRemove);
    }

    this._cfg.children = [];
    return this;
  },
  destroy: function destroy() {
    if (this.get('destroyed')) {
      return;
    }

    this.clear();
    Group.superclass.destroy.call(this);
  },
  clone: function clone() {
    var self = this;
    var children = self._cfg.children;
    var clone = new Group();
    Util.each(children, function (child) {
      clone.add(child.clone());
    });
    return clone;
  }
});
module.exports = Group;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Event = function Event(type, event, bubbles, cancelable) {
  this.type = type; // 浜嬩欢绫诲瀷

  this.target = null; // 鐩爣

  this.currentTarget = null; // 褰撳墠鐩爣

  this.bubbles = bubbles; // 鍐掓场

  this.cancelable = cancelable; // 鏄惁鑳藉闃绘

  this.timeStamp = new Date().getTime(); // 鏃堕棿鎴�

  this.defaultPrevented = false; // 闃绘榛樿

  this.propagationStopped = false; // 闃绘鍐掓场

  this.removed = false; // 鏄惁琚Щ闄�

  this.event = event; // 瑙﹀彂鐨勫師鐢熶簨浠�
};

Util.augment(Event, {
  preventDefault: function preventDefault() {
    this.defaultPrevented = this.cancelable && true;
  },
  stopPropagation: function stopPropagation() {
    this.propagationStopped = true;
  },
  remove: function remove() {
    this.remove = true;
  },
  clone: function clone() {
    return Util.clone(this);
  },
  toString: function toString() {
    return '[Event (type=' + this.type + ')]';
  }
});
module.exports = Event;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var ArcMath = __webpack_require__(47);

var Arrow = __webpack_require__(49);

function _getArcX(x, radius, angle) {
  return x + radius * Math.cos(angle);
}

function _getArcY(y, radius, angle) {
  return y + radius * Math.sin(angle);
}

var Arc = function Arc(cfg) {
  Arc.superclass.constructor.call(this, cfg);
};

Arc.ATTRS = {
  x: 0,
  y: 0,
  r: 0,
  startAngle: 0,
  endAngle: 0,
  clockwise: false,
  lineWidth: 1,
  startArrow: false,
  endArrow: false
};
Util.extend(Arc, Shape);
Util.augment(Arc, {
  canStroke: true,
  type: 'arc',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      x: 0,
      y: 0,
      r: 0,
      startAngle: 0,
      endAngle: 0,
      clockwise: false,
      lineWidth: 1,
      startArrow: false,
      endArrow: false
    };
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;
    var x = attrs.x,
        y = attrs.y,
        r = attrs.r,
        startAngle = attrs.startAngle,
        endAngle = attrs.endAngle,
        clockwise = attrs.clockwise;
    var lineWidth = this.getHitLineWidth();
    var halfWidth = lineWidth / 2;
    var box = ArcMath.box(x, y, r, startAngle, endAngle, clockwise);
    box.minX -= halfWidth;
    box.minY -= halfWidth;
    box.maxX += halfWidth;
    box.maxY += halfWidth;
    return box;
  },
  getStartTangent: function getStartTangent() {
    var attrs = this._attrs;
    var x = attrs.x,
        y = attrs.y,
        startAngle = attrs.startAngle,
        r = attrs.r,
        clockwise = attrs.clockwise;
    var diff = Math.PI / 180;

    if (clockwise) {
      diff *= -1;
    }

    var result = [];

    var x1 = _getArcX(x, r, startAngle + diff);

    var y1 = _getArcY(y, r, startAngle + diff);

    var x2 = _getArcX(x, r, startAngle);

    var y2 = _getArcY(y, r, startAngle);

    result.push([x1, y1]);
    result.push([x2, y2]);
    return result;
  },
  getEndTangent: function getEndTangent() {
    var attrs = this._attrs;
    var x = attrs.x,
        y = attrs.y,
        endAngle = attrs.endAngle,
        r = attrs.r,
        clockwise = attrs.clockwise;
    var diff = Math.PI / 180;
    var result = [];

    if (clockwise) {
      diff *= -1;
    }

    var x1 = _getArcX(x, r, endAngle + diff);

    var y1 = _getArcY(y, r, endAngle + diff);

    var x2 = _getArcX(x, r, endAngle);

    var y2 = _getArcY(y, r, endAngle);

    result.push([x2, y2]);
    result.push([x1, y1]);
    return result;
  },
  createPath: function createPath(context) {
    var attrs = this._attrs;
    var x = attrs.x,
        y = attrs.y,
        r = attrs.r,
        startAngle = attrs.startAngle,
        endAngle = attrs.endAngle,
        clockwise = attrs.clockwise;
    context = context || self.get('context');
    context.beginPath();
    context.arc(x, y, r, startAngle, endAngle, clockwise);
  },
  afterPath: function afterPath(context) {
    var attrs = this._attrs;
    context = context || this.get('context');

    if (attrs.startArrow) {
      var startPoints = this.getStartTangent();
      Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);
    }

    if (attrs.endArrow) {
      var endPoints = this.getEndTangent();
      Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);
    }
  }
});
module.exports = Arc;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Circle = function Circle(cfg) {
  Circle.superclass.constructor.call(this, cfg);
};

Circle.ATTRS = {
  x: 0,
  y: 0,
  r: 0,
  lineWidth: 1
};
Util.extend(Circle, Shape);
Util.augment(Circle, {
  canFill: true,
  canStroke: true,
  type: 'circle',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1
    };
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    var lineWidth = this.getHitLineWidth();
    var halfWidth = lineWidth / 2 + r;
    return {
      minX: cx - halfWidth,
      minY: cy - halfWidth,
      maxX: cx + halfWidth,
      maxY: cy + halfWidth
    };
  },
  createPath: function createPath(context) {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
    context.closePath();
  }
});
module.exports = Circle;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Dom = function Dom(cfg) {
  Dom.superclass.constructor.call(this, cfg);
};

Util.extend(Dom, Shape);
Util.augment(Dom, {
  canFill: true,
  canStroke: true,
  type: 'dom',
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var lineWidth = this.getHitLineWidth();
    var halfWidth = lineWidth / 2;
    return {
      minX: x - halfWidth,
      minY: y - halfWidth,
      maxX: x + width + halfWidth,
      maxY: y + height + halfWidth
    };
  }
});
module.exports = Dom;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Ellipse = function Ellipse(cfg) {
  Ellipse.superclass.constructor.call(this, cfg);
};

Ellipse.ATTRS = {
  x: 0,
  y: 0,
  rx: 1,
  ry: 1,
  lineWidth: 1
};
Util.extend(Ellipse, Shape);
Util.augment(Ellipse, {
  canFill: true,
  canStroke: true,
  type: 'ellipse',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1
    };
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    var lineWidth = this.getHitLineWidth();
    var halfXWidth = rx + lineWidth / 2;
    var halfYWidth = ry + lineWidth / 2;
    return {
      minX: cx - halfXWidth,
      minY: cy - halfYWidth,
      maxX: cx + halfXWidth,
      maxY: cy + halfYWidth
    };
  },
  createPath: function createPath(context) {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context = context || self.get('context');
    var r = rx > ry ? rx : ry;
    var scaleX = rx > ry ? 1 : rx / ry;
    var scaleY = rx > ry ? ry / rx : 1;
    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    Util.mat3.scale(m, m, [scaleX, scaleY]);
    Util.mat3.translate(m, m, [cx, cy]);
    context.beginPath();
    context.save();
    context.transform(m[0], m[1], m[3], m[4], m[6], m[7]);
    context.arc(0, 0, r, 0, Math.PI * 2);
    context.restore();
    context.closePath();
  }
});
module.exports = Ellipse;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var ArcMath = __webpack_require__(47);

var Fan = function Fan(cfg) {
  Fan.superclass.constructor.call(this, cfg);
};

Fan.ATTRS = {
  x: 0,
  y: 0,
  rs: 0,
  re: 0,
  startAngle: 0,
  endAngle: 0,
  clockwise: false,
  lineWidth: 1
};
Util.extend(Fan, Shape);
Util.augment(Fan, {
  canFill: true,
  canStroke: true,
  type: 'fan',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      clockwise: false,
      lineWidth: 1,
      rs: 0,
      re: 0
    };
  },
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var rs = attrs.rs;
    var re = attrs.re;
    var startAngle = attrs.startAngle;
    var endAngle = attrs.endAngle;
    var clockwise = attrs.clockwise;
    var lineWidth = this.getHitLineWidth();
    var boxs = ArcMath.box(cx, cy, rs, startAngle, endAngle, clockwise);
    var boxe = ArcMath.box(cx, cy, re, startAngle, endAngle, clockwise);
    var minX = Math.min(boxs.minX, boxe.minX);
    var minY = Math.min(boxs.minY, boxe.minY);
    var maxX = Math.max(boxs.maxX, boxe.maxX);
    var maxY = Math.max(boxs.maxY, boxe.maxY);
    var halfWidth = lineWidth / 2;
    return {
      minX: minX - halfWidth,
      minY: minY - halfWidth,
      maxX: maxX + halfWidth,
      maxY: maxY + halfWidth
    };
  },
  createPath: function createPath(context) {
    var attrs = this._attrs;
    var cx = attrs.x;
    var cy = attrs.y;
    var rs = attrs.rs;
    var re = attrs.re;
    var startAngle = attrs.startAngle;
    var endAngle = attrs.endAngle;
    var clockwise = attrs.clockwise;
    var ssp = {
      x: Math.cos(startAngle) * rs + cx,
      y: Math.sin(startAngle) * rs + cy
    };
    var sep = {
      x: Math.cos(startAngle) * re + cx,
      y: Math.sin(startAngle) * re + cy
    };
    var esp = {
      x: Math.cos(endAngle) * rs + cx,
      y: Math.sin(endAngle) * rs + cy
    };
    context = context || self.get('context');
    context.beginPath();
    context.moveTo(ssp.x, ssp.y);
    context.lineTo(sep.x, sep.y);
    context.arc(cx, cy, re, startAngle, endAngle, clockwise);
    context.lineTo(esp.x, esp.y);
    context.arc(cx, cy, rs, endAngle, startAngle, !clockwise);
    context.closePath();
  }
});
module.exports = Fan;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var CImage = function CImage(cfg) {
  CImage.superclass.constructor.call(this, cfg);
};

CImage.ATTRS = {
  x: 0,
  y: 0,
  img: undefined,
  width: 0,
  height: 0,
  sx: null,
  sy: null,
  swidth: null,
  sheight: null
};
Util.extend(CImage, Shape);
Util.augment(CImage, {
  type: 'image',
  isHitBox: function isHitBox() {
    return false;
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;

    if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {
      this._setAttrImg();
    }

    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    return {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
  },
  _beforeSetLoading: function _beforeSetLoading(loading) {
    var canvas = this.get('canvas');

    if (loading === false && this.get('toDraw') === true) {
      this._cfg.loading = false;
      canvas.draw();
    }

    return loading;
  },
  _setAttrImg: function _setAttrImg() {
    var self = this;
    var attrs = self._attrs;
    var img = attrs.img;

    if (Util.isString(img)) {
      var image = new Image();

      image.onload = function () {
        if (self.get('destroyed')) return false;
        self.attr('imgSrc', img);
        self.attr('img', image);
        var callback = self.get('callback');

        if (callback) {
          callback.call(self);
        }

        self.set('loading', false);
      };

      image.src = img;
      image.crossOrigin = 'Anonymous';
      self.set('loading', true);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        self.attr('width', img.width);
      }

      if (!attrs.height) {
        self.attr('height', img.height);
      }

      return img;
    } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
      if (!attrs.width) {
        self.attr('width', Number(img.getAttribute('width')));
      }

      if (!attrs.height) {
        self.attr('height', Number(img.getAttribute('height')));
      }

      return img;
    } else if (img instanceof ImageData) {
      if (!attrs.width) {
        self.attr('width', img.width);
      }

      if (!attrs.height) {
        self.attr('height', img.height);
      }

      return img;
    } else {
      return null;
    }
  },
  drawInner: function drawInner(context) {
    if (this._cfg.hasUpdate) {
      this._setAttrImg();
    }

    if (this.get('loading')) {
      this.set('toDraw', true);
      return;
    }

    this._drawImage(context);

    this._cfg.hasUpdate = false;
  },
  _drawImage: function _drawImage(context) {
    var attrs = this._attrs;
    var x = attrs.x;
    var y = attrs.y;
    var image = attrs.img;
    var width = attrs.width;
    var height = attrs.height;
    var sx = attrs.sx;
    var sy = attrs.sy;
    var swidth = attrs.swidth;
    var sheight = attrs.sheight;
    this.set('toDraw', false);
    var img = image;

    if (img instanceof ImageData) {
      img = new Image();
      img.src = image;
    }

    if (img instanceof Image || img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
      if (Util.isNil(sx) || Util.isNil(sy) || Util.isNil(swidth) || Util.isNil(sheight)) {
        context.drawImage(img, x, y, width, height);
        return;
      }

      if (!Util.isNil(sx) && !Util.isNil(sy) && !Util.isNil(swidth) && !Util.isNil(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        return;
      }
    }

    return;
  }
});
module.exports = CImage;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Arrow = __webpack_require__(49);

var LineMath = __webpack_require__(48);

var Line = function Line(cfg) {
  Line.superclass.constructor.call(this, cfg);
};

Line.ATTRS = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  lineWidth: 1,
  startArrow: false,
  endArrow: false
};
Util.extend(Line, Shape);
Util.augment(Line, {
  canStroke: true,
  type: 'line',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1,
      startArrow: false,
      endArrow: false
    };
  },
  calculateBox: function calculateBox() {
    var attrs = this._attrs;
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2;
    var lineWidth = this.getHitLineWidth();
    return LineMath.box(x1, y1, x2, y2, lineWidth);
  },
  createPath: function createPath(context) {
    var attrs = this._attrs;
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2;
    context = context || self.get('context');
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
  },
  afterPath: function afterPath(context) {
    var attrs = this._attrs;
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2;
    context = context || this.get('context');

    if (attrs.startArrow) {
      Arrow.addStartArrow(context, attrs, x2, y2, x1, y1);
    }

    if (attrs.endArrow) {
      Arrow.addEndArrow(context, attrs, x1, y1, x2, y2);
    }
  },
  getPoint: function getPoint(t) {
    var attrs = this._attrs;
    return {
      x: LineMath.at(attrs.x1, attrs.x2, t),
      y: LineMath.at(attrs.y1, attrs.y2, t)
    };
  }
});
module.exports = Line;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

module.exports = {
  xAt: function xAt(psi, rx, ry, cx, t) {
    return rx * Math.cos(psi) * Math.cos(t) - ry * Math.sin(psi) * Math.sin(t) + cx;
  },
  yAt: function yAt(psi, rx, ry, cy, t) {
    return rx * Math.sin(psi) * Math.cos(t) + ry * Math.cos(psi) * Math.sin(t) + cy;
  },
  xExtrema: function xExtrema(psi, rx, ry) {
    return Math.atan(-ry / rx * Math.tan(psi));
  },
  yExtrema: function yExtrema(psi, rx, ry) {
    return Math.atan(ry / (rx * Math.tan(psi)));
  }
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var vec2 = Util.vec2;

function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}

function quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, out) {
  var t;
  var interval = 0.005;
  var d = Infinity;
  var d1;
  var v1;
  var v2;

  var _t;

  var d2;
  var i;
  var EPSILON = 0.0001;
  var v0 = [x, y];

  for (_t = 0; _t < 1; _t += 0.05) {
    v1 = [quadraticAt(x1, x2, x3, _t), quadraticAt(y1, y2, y3, _t)];
    d1 = vec2.squaredDistance(v0, v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity;

  for (i = 0; i < 32; i++) {
    if (interval < EPSILON) {
      break;
    }

    var prev = t - interval;
    var next = t + interval;
    v1 = [quadraticAt(x1, x2, x3, prev), quadraticAt(y1, y2, y3, prev)];
    d1 = vec2.squaredDistance(v0, v1);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      v2 = [quadraticAt(x1, x2, x3, next), quadraticAt(y1, y2, y3, next)];
      d2 = vec2.squaredDistance(v0, v2);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }

  if (out) {
    out.x = quadraticAt(x1, x2, x3, t);
    out.y = quadraticAt(y1, y2, y3, t);
  }

  return Math.sqrt(d);
}

function quadraticExtrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;

  if (Util.isNumberEqual(a, 0)) {
    return [0.5];
  }

  var rst = (p0 - p1) / a;

  if (rst <= 1 && rst >= 0) {
    return [rst];
  }

  return [];
}

module.exports = {
  at: quadraticAt,
  projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x, y) {
    var rst = {};
    quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, rst);
    return rst;
  },
  pointDistance: quadraticProjectPoint,
  extrema: quadraticExtrema
};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var PathSegment = __webpack_require__(50);

var Format = __webpack_require__(37);

var Arrow = __webpack_require__(49);

var PathUtil = __webpack_require__(77);

var CubicMath = __webpack_require__(75);

var Path = function Path(cfg) {
  Path.superclass.constructor.call(this, cfg);
};

Path.ATTRS = {
  path: null,
  lineWidth: 1,
  startArrow: false,
  endArrow: false
};
Util.extend(Path, Shape);
Util.augment(Path, {
  canFill: true,
  canStroke: true,
  type: 'path',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1,
      startArrow: false,
      endArrow: false
    };
  },
  _afterSetAttrPath: function _afterSetAttrPath(path) {
    var self = this;

    if (Util.isNil(path)) {
      self.setSilent('segments', null);
      self.setSilent('box', undefined);
      return;
    }

    var pathArray = Format.parsePath(path);
    var preSegment;
    var segments = [];

    if (!Util.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {
      return;
    }

    var count = pathArray.length;

    for (var i = 0; i < pathArray.length; i++) {
      var item = pathArray[i];
      preSegment = new PathSegment(item, preSegment, i === count - 1);
      segments.push(preSegment);
    }

    self.setSilent('segments', segments);
    self.setSilent('tCache', null);
    self.setSilent('box', null);
  },
  calculateBox: function calculateBox() {
    var self = this;
    var segments = self.get('segments');

    if (!segments) {
      return null;
    }

    var lineWidth = this.getHitLineWidth();
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    Util.each(segments, function (segment) {
      segment.getBBox(lineWidth);
      var box = segment.box;

      if (box) {
        if (box.minX < minX) {
          minX = box.minX;
        }

        if (box.maxX > maxX) {
          maxX = box.maxX;
        }

        if (box.minY < minY) {
          minY = box.minY;
        }

        if (box.maxY > maxY) {
          maxY = box.maxY;
        }
      }
    });

    if (minX === Infinity || minY === Infinity) {
      return {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
    }

    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  },
  _setTcache: function _setTcache() {
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l;
    var curve = this._cfg.curve;

    if (!curve) {
      return;
    }

    Util.each(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
      }
    });
    Util.each(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this._cfg.tCache = tCache;
  },
  _calculateCurve: function _calculateCurve() {
    var self = this;
    var attrs = self._attrs;
    var path = attrs.path;
    this._cfg.curve = PathUtil.pathTocurve(path);
  },
  getStartTangent: function getStartTangent() {
    var segments = this.get('segments');
    var startPoint, endPoint, tangent, result;

    if (segments.length > 1) {
      startPoint = segments[0].endPoint;
      endPoint = segments[1].endPoint;
      tangent = segments[1].startTangent;
      result = [];

      if (Util.isFunction(tangent)) {
        var v = tangent();
        result.push([startPoint.x - v[0], startPoint.y - v[1]]);
        result.push([startPoint.x, startPoint.y]);
      } else {
        result.push([endPoint.x, endPoint.y]);
        result.push([startPoint.x, startPoint.y]);
      }
    }

    return result;
  },
  getEndTangent: function getEndTangent() {
    var segments = this.get('segments');
    var segmentsLen = segments.length;
    var startPoint, endPoint, tangent, result;

    if (segmentsLen > 1) {
      startPoint = segments[segmentsLen - 2].endPoint;
      endPoint = segments[segmentsLen - 1].endPoint;
      tangent = segments[segmentsLen - 1].endTangent;
      result = [];

      if (Util.isFunction(tangent)) {
        var v = tangent();
        result.push([endPoint.x - v[0], endPoint.y - v[1]]);
        result.push([endPoint.x, endPoint.y]);
      } else {
        result.push([startPoint.x, startPoint.y]);
        result.push([endPoint.x, endPoint.y]);
      }
    }

    return result;
  },
  getPoint: function getPoint(t) {
    var tCache = this._cfg.tCache;
    var subt;
    var index;

    if (!tCache) {
      this._calculateCurve();

      this._setTcache();

      tCache = this._cfg.tCache;
    }

    var curve = this._cfg.curve;

    if (!tCache) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }

      return null;
    }

    Util.each(tCache, function (v, i) {
      if (t >= v[0] && t <= v[1]) {
        subt = (t - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var seg = curve[index];

    if (Util.isNil(seg) || Util.isNil(index)) {
      return null;
    }

    var l = seg.length;
    var nextSeg = curve[index + 1];
    return {
      x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),
      y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt)
    };
  },
  createPath: function createPath(context) {
    var self = this;
    var segments = self.get('segments');

    if (!Util.isArray(segments)) {
      return;
    }

    context = context || self.get('context');
    context.beginPath();
    var segmentsLen = segments.length;

    for (var i = 0; i < segmentsLen; i++) {
      segments[i].draw(context);
    }
  },
  afterPath: function afterPath(context) {
    var self = this;
    var attrs = self._attrs;
    var segments = self.get('segments');
    var path = attrs.path;
    context = context || self.get('context');

    if (!Util.isArray(segments)) {
      return;
    }

    if (segments.length === 1) {
      return;
    }

    if (!attrs.startArrow && !attrs.endArrow) {
      return;
    }

    if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {
      // 闂悎璺緞涓嶇粯鍒剁澶�
      return;
    }

    var startPoints = self.getStartTangent();
    Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);
    var endPoints = self.getEndTangent();
    Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);
  }
});
module.exports = Path;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Polygon = function Polygon(cfg) {
  Polygon.superclass.constructor.call(this, cfg);
};

Polygon.ATTRS = {
  points: null,
  lineWidth: 1
};
Util.extend(Polygon, Shape);
Util.augment(Polygon, {
  canFill: true,
  canStroke: true,
  type: 'polygon',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1
    };
  },
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var points = attrs.points;
    var lineWidth = this.getHitLineWidth();

    if (!points || points.length === 0) {
      return null;
    }

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    Util.each(points, function (point) {
      var x = point[0];
      var y = point[1];

      if (x < minX) {
        minX = x;
      }

      if (x > maxX) {
        maxX = x;
      }

      if (y < minY) {
        minY = y;
      }

      if (y > maxY) {
        maxY = y;
      }
    });
    var halfWidth = lineWidth / 2;
    return {
      minX: minX - halfWidth,
      minY: minY - halfWidth,
      maxX: maxX + halfWidth,
      maxY: maxY + halfWidth
    };
  },
  createPath: function createPath(context) {
    var self = this;
    var attrs = self._attrs;
    var points = attrs.points;

    if (points.length < 2) {
      return;
    }

    context = context || self.get('context');
    context.beginPath();
    Util.each(points, function (point, index) {
      if (index === 0) {
        context.moveTo(point[0], point[1]);
      } else {
        context.lineTo(point[0], point[1]);
      }
    });
    context.closePath();
  }
});
module.exports = Polygon;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var Arrow = __webpack_require__(49);

var LineMath = __webpack_require__(48);

var Polyline = function Polyline(cfg) {
  Polyline.superclass.constructor.call(this, cfg);
};

Polyline.ATTRS = {
  points: null,
  lineWidth: 1,
  startArrow: false,
  endArrow: false,
  tCache: null
};
Util.extend(Polyline, Shape);
Util.augment(Polyline, {
  canStroke: true,
  type: 'polyline',
  tCache: null,
  // 缂撳瓨鍚勭偣鐨則
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1,
      startArrow: false,
      endArrow: false
    };
  },
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var lineWidth = this.getHitLineWidth();
    var points = attrs.points;

    if (!points || points.length === 0) {
      return null;
    }

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    Util.each(points, function (point) {
      var x = point[0];
      var y = point[1];

      if (x < minX) {
        minX = x;
      }

      if (x > maxX) {
        maxX = x;
      }

      if (y < minY) {
        minY = y;
      }

      if (y > maxY) {
        maxY = y;
      }
    });
    var halfWidth = lineWidth / 2;
    return {
      minX: minX - halfWidth,
      minY: minY - halfWidth,
      maxX: maxX + halfWidth,
      maxY: maxY + halfWidth
    };
  },
  _setTcache: function _setTcache() {
    var self = this;
    var attrs = self._attrs;
    var points = attrs.points;
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;

    if (!points || points.length === 0) {
      return;
    }

    Util.each(points, function (p, i) {
      if (points[i + 1]) {
        totalLength += LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
      }
    });

    if (totalLength <= 0) {
      return;
    }

    Util.each(points, function (p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.tCache = tCache;
  },
  createPath: function createPath(context) {
    var self = this;
    var attrs = self._attrs;
    var points = attrs.points;
    var l;
    var i;

    if (points.length < 2) {
      return;
    }

    context = context || self.get('context');
    context.beginPath();
    context.moveTo(points[0][0], points[0][1]);

    for (i = 1, l = points.length - 1; i < l; i++) {
      context.lineTo(points[i][0], points[i][1]);
    }

    context.lineTo(points[l][0], points[l][1]);
  },
  getStartTangent: function getStartTangent() {
    var points = this.__attrs.points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  },
  getEndTangent: function getEndTangent() {
    var points = this.__attrs.points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  },
  afterPath: function afterPath(context) {
    var self = this;
    var attrs = self._attrs;
    var points = attrs.points;
    var l = points.length - 1;
    context = context || self.get('context');

    if (attrs.startArrow) {
      Arrow.addStartArrow(context, attrs, points[1][0], points[1][1], points[0][0], points[0][1]);
    }

    if (attrs.endArrow) {
      Arrow.addEndArrow(context, attrs, points[l - 1][0], points[l - 1][1], points[l][0], points[l][1]);
    }
  },
  getPoint: function getPoint(t) {
    var attrs = this._attrs;
    var points = attrs.points;
    var tCache = this.tCache;
    var subt;
    var index;

    if (!tCache) {
      this._setTcache();

      tCache = this.tCache;
    }

    Util.each(tCache, function (v, i) {
      if (t >= v[0] && t <= v[1]) {
        subt = (t - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return {
      x: LineMath.at(points[index][0], points[index + 1][0], subt),
      y: LineMath.at(points[index][1], points[index + 1][1], subt)
    };
  }
});
module.exports = Polyline;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var _require = __webpack_require__(37),
    parseRadius = _require.parseRadius;

var Shape = __webpack_require__(7);

var Rect = function Rect(cfg) {
  Rect.superclass.constructor.call(this, cfg);
};

Rect.ATTRS = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  radius: 0,
  lineWidth: 1
};
Util.extend(Rect, Shape);
Util.augment(Rect, {
  canFill: true,
  canStroke: true,
  type: 'rect',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1,
      radius: 0
    };
  },
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var lineWidth = this.getHitLineWidth();
    var halfWidth = lineWidth / 2;
    return {
      minX: x - halfWidth,
      minY: y - halfWidth,
      maxX: x + width + halfWidth,
      maxY: y + height + halfWidth
    };
  },
  createPath: function createPath(context) {
    var self = this;
    var attrs = self._attrs;
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context = context || self.get('context');
    context.beginPath();

    if (radius === 0) {
      // 鏀规垚鍘熺敓鐨剅ect鏂规硶
      context.rect(x, y, width, height);
    } else {
      var r = parseRadius(radius);
      context.moveTo(x + r.r1, y);
      context.lineTo(x + width - r.r2, y);
      r.r2 !== 0 && context.arc(x + width - r.r2, y + r.r2, r.r2, -Math.PI / 2, 0);
      context.lineTo(x + width, y + height - r.r3);
      r.r3 !== 0 && context.arc(x + width - r.r3, y + height - r.r3, r.r3, 0, Math.PI / 2);
      context.lineTo(x + r.r4, y + height);
      r.r4 !== 0 && context.arc(x + r.r4, y + height - r.r4, r.r4, Math.PI / 2, Math.PI);
      context.lineTo(x, y + r.r1);
      r.r1 !== 0 && context.arc(x + r.r1, y + r.r1, r.r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  }
});
module.exports = Rect;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Shape = __webpack_require__(7);

var CText = function CText(cfg) {
  CText.superclass.constructor.call(this, cfg);
};

CText.ATTRS = {
  x: 0,
  y: 0,
  text: null,
  fontSize: 12,
  fontFamily: 'sans-serif',
  fontStyle: 'normal',
  fontWeight: 'normal',
  fontVariant: 'normal',
  textAlign: 'start',
  textBaseline: 'bottom',
  lineHeight: null,
  textArr: null
};
Util.extend(CText, Shape);
Util.augment(CText, {
  canFill: true,
  canStroke: true,
  type: 'text',
  getDefaultAttrs: function getDefaultAttrs() {
    return {
      lineWidth: 1,
      lineCount: 1,
      fontSize: 12,
      fontFamily: 'sans-serif',
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontVariant: 'normal',
      textAlign: 'start',
      textBaseline: 'bottom'
    };
  },
  initTransform: function initTransform() {
    var fontSize = this._attrs.fontSize;

    if (fontSize && +fontSize < 12) {
      // 灏忎簬 12 鍍忕礌鐨勬枃鏈繘琛� scale 澶勭悊
      this.transform([['t', -1 * this._attrs.x, -1 * this._attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', this._attrs.x, this._attrs.y]]);
    }
  },
  _assembleFont: function _assembleFont() {
    // var self = this;
    var attrs = this._attrs;
    var fontSize = attrs.fontSize;
    var fontFamily = attrs.fontFamily;
    var fontWeight = attrs.fontWeight;
    var fontStyle = attrs.fontStyle; // self.attr('fontStyle');

    var fontVariant = attrs.fontVariant; // self.attr('fontVariant');
    // self.attr('font', [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' '));

    attrs.font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');
  },
  _setAttrText: function _setAttrText() {
    var attrs = this._attrs;
    var text = attrs.text;
    var textArr = null;

    if (Util.isString(text) && text.indexOf('\n') !== -1) {
      textArr = text.split('\n');
      var lineCount = textArr.length;
      attrs.lineCount = lineCount;
    }

    attrs.textArr = textArr;
  },
  _getTextHeight: function _getTextHeight() {
    var attrs = this._attrs;
    var lineCount = attrs.lineCount;
    var fontSize = attrs.fontSize * 1;

    if (lineCount > 1) {
      var spaceingY = this._getSpaceingY();

      return fontSize * lineCount + spaceingY * (lineCount - 1);
    }

    return fontSize;
  },
  isHitBox: function isHitBox() {
    return false;
  },
  calculateBox: function calculateBox() {
    var self = this;
    var attrs = self._attrs;
    var cfg = this._cfg;

    if (!cfg.attrs || cfg.hasUpdate) {
      this._assembleFont();

      this._setAttrText();
    }

    if (!attrs.textArr) {
      this._setAttrText();
    }

    var x = attrs.x;
    var y = attrs.y;
    var width = self.measureText(); // attrs.width

    if (!width) {
      // 濡傛灉width涓嶅瓨鍦紝鍥涚偣鍏卞叾瀹炵偣
      return {
        minX: x,
        minY: y,
        maxX: x,
        maxY: y
      };
    }

    var height = self._getTextHeight(); // attrs.height


    var textAlign = attrs.textAlign;
    var textBaseline = attrs.textBaseline;
    var lineWidth = self.getHitLineWidth();
    var point = {
      x: x,
      y: y - height
    };

    if (textAlign) {
      if (textAlign === 'end' || textAlign === 'right') {
        point.x -= width;
      } else if (textAlign === 'center') {
        point.x -= width / 2;
      }
    }

    if (textBaseline) {
      if (textBaseline === 'top') {
        point.y += height;
      } else if (textBaseline === 'middle') {
        point.y += height / 2;
      }
    }

    this.set('startPoint', point);
    var halfWidth = lineWidth / 2;
    return {
      minX: point.x - halfWidth,
      minY: point.y - halfWidth,
      maxX: point.x + width + halfWidth,
      maxY: point.y + height + halfWidth
    };
  },
  _getSpaceingY: function _getSpaceingY() {
    var attrs = this._attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  },
  drawInner: function drawInner(context) {
    var self = this;
    var attrs = self._attrs;
    var cfg = this._cfg;

    if (!cfg.attrs || cfg.hasUpdate) {
      this._assembleFont();

      this._setAttrText();
    }

    context.font = attrs.font;
    var text = attrs.text;

    if (!text) {
      return;
    }

    var textArr = attrs.textArr;
    var x = attrs.x;
    var y = attrs.y;
    context.beginPath();

    if (self.hasStroke()) {
      var strokeOpacity = attrs.strokeOpacity;

      if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
        context.globalAlpha = strokeOpacity;
      }

      if (textArr) {
        self._drawTextArr(context, false);
      } else {
        context.strokeText(text, x, y);
      }

      context.globalAlpha = 1;
    }

    if (self.hasFill()) {
      var fillOpacity = attrs.fillOpacity;

      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
      }

      if (textArr) {
        self._drawTextArr(context, true);
      } else {
        context.fillText(text, x, y);
      }
    }

    cfg.hasUpdate = false;
  },
  _drawTextArr: function _drawTextArr(context, fill) {
    var textArr = this._attrs.textArr;
    var textBaseline = this._attrs.textBaseline;
    var fontSize = this._attrs.fontSize * 1;

    var spaceingY = this._getSpaceingY();

    var x = this._attrs.x;
    var y = this._attrs.y;
    var box = this.getBBox();
    var height = box.maxY - box.minY;
    var subY;
    Util.each(textArr, function (subText, index) {
      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;

      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === 'top') subY += height - fontSize;

      if (fill) {
        context.fillText(subText, x, subY);
      } else {
        context.strokeText(subText, x, subY);
      }
    });
  },
  measureText: function measureText() {
    var self = this;
    var attrs = self._attrs;
    var text = attrs.text;
    var font = attrs.font;
    var textArr = attrs.textArr;
    var measureWidth;
    var width = 0;
    if (Util.isNil(text)) return undefined;
    var context = document.createElement('canvas').getContext('2d');
    context.save();
    context.font = font;

    if (textArr) {
      Util.each(textArr, function (subText) {
        measureWidth = context.measureText(subText).width;

        if (width < measureWidth) {
          width = measureWidth;
        }

        context.restore();
      });
    } else {
      width = context.measureText(text).width;
      context.restore();
    }

    return width;
  }
});
module.exports = CText;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  isFunction: __webpack_require__(14),
  isObject: __webpack_require__(39),
  isBoolean: __webpack_require__(191),
  isNil: __webpack_require__(6),
  isString: __webpack_require__(15),
  isArray: __webpack_require__(4),
  isNumber: __webpack_require__(11),
  isEmpty: __webpack_require__(167),
  // isBlank
  uniqueId: __webpack_require__(194),
  clone: __webpack_require__(80),
  deepMix: __webpack_require__(81),
  assign: __webpack_require__(10),
  // simpleMix
  merge: __webpack_require__(81),
  // mix
  upperFirst: __webpack_require__(189),
  // ucfirst
  each: __webpack_require__(2),
  isEqual: __webpack_require__(83),
  toArray: __webpack_require__(57),
  extend: __webpack_require__(162),
  augment: __webpack_require__(158),
  remove: __webpack_require__(156),
  isNumberEqual: __webpack_require__(55),
  toRadian: __webpack_require__(172),
  toDegree: __webpack_require__(170),
  mod: __webpack_require__(169),
  clamp: __webpack_require__(84),
  createDom: __webpack_require__(159),
  modifyCSS: __webpack_require__(160),
  requestAnimationFrame: __webpack_require__(161),
  getRatio: function getRatio() {
    return window.devicePixelRatio ? window.devicePixelRatio : 2;
  },
  mat3: __webpack_require__(85),
  vec2: __webpack_require__(174),
  vec3: __webpack_require__(175),
  transform: __webpack_require__(173)
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 璁＄畻鍒嗙被鐨勭殑鍧愭爣鐐�
 * @author dxq613@gmail.com
 */
var each = __webpack_require__(2);

var MAX_COUNT = 8;
var SUB_COUNT = 4; // 鎺у埗涓暟涓嶈兘杩囧皬

function getSimpleArray(data) {
  var arr = [];
  each(data, function (sub) {
    arr = arr.concat(sub);
  });
  return arr;
}

function getGreatestFactor(count, number) {
  var i;

  for (i = number; i > 0; i--) {
    if (count % i === 0) {
      break;
    }
  } // 濡傛灉鏄礌鏁帮紝娌℃湁鍙互鏁撮櫎鐨勬暟瀛�


  if (i === 1) {
    for (i = number; i > 0; i--) {
      if ((count - 1) % i === 0) {
        break;
      }
    }
  }

  return i;
}

module.exports = function (info) {
  var rst = {};
  var ticks = [];
  var isRounding = info.isRounding;
  var categories = getSimpleArray(info.data);
  var length = categories.length;
  var maxCount = info.maxCount || MAX_COUNT;
  var tickCount;

  if (isRounding) {
    // 鍙栨暣鎿嶄綔
    tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 濡傛灉璁＄畻鍑烘潵鍙湁涓や釜鍧愭爣鐐癸紝鍒欑洿鎺ヤ娇鐢ㄤ紶鍏ョ殑 maxCount

    if (tickCount === 2) {
      tickCount = maxCount;
    } else if (tickCount < maxCount - SUB_COUNT) {
      tickCount = maxCount - SUB_COUNT;
    }
  } else {
    tickCount = maxCount;
  }

  if (!isRounding && length <= tickCount + tickCount / 2) {
    ticks = [].concat(categories);
  } else {
    var step = parseInt(length / (tickCount - 1), 10);
    var groups = categories.map(function (e, i) {
      return i % step === 0 ? categories.slice(i, i + step) : null;
    }).filter(function (e) {
      return e;
    });

    for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {
      ticks.push(groups[i][0]);
    }

    if (categories.length) {
      ticks.unshift(categories[0]);
      var last = categories[length - 1];

      if (ticks.indexOf(last) === -1) {
        ticks.push(last);
      }
    }
  }

  rst.categories = categories;
  rst.ticks = ticks;
  return rst;
};

/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * @fileOverview 璁＄畻鏂规硶
 * @author dxq613@gmail.com
 */
// 濡傛灉灏忔暟鐐瑰悗闈㈣秴杩� 10 浣嶆诞鐐规暟鏃惰繘琛屼竴涓嬪鐞�
var DECIMAL_LENGTH = 12; // 鑾峰彇绯绘暟

function getFactor(v) {
  var factor = 1;

  if (v === Infinity || v === -Infinity) {
    throw new Error('Not support Infinity!');
  }

  if (v < 1) {
    var count = 0;

    while (v < 1) {
      factor = factor / 10;
      v = v * 10;
      count++;
    } // 娴偣鏁拌绠楀嚭鐜伴棶棰�


    if (factor.toString().length > DECIMAL_LENGTH) {
      factor = parseFloat(factor.toFixed(count));
    }
  } else {
    while (v > 10) {
      factor = factor * 10;
      v = v / 10;
    }
  }

  return factor;
} // 鍙栧皬浜庡綋鍓嶅€肩殑


function arrayFloor(values, value) {
  var length = values.length;

  if (length === 0) {
    return NaN;
  }

  var pre = values[0];

  if (value < values[0]) {
    return NaN;
  }

  if (value >= values[length - 1]) {
    return values[length - 1];
  }

  for (var i = 1; i < values.length; i++) {
    if (value < values[i]) {
      break;
    }

    pre = values[i];
  }

  return pre;
} // 澶т簬褰撳墠鍊肩殑绗竴涓�


function arrayCeiling(values, value) {
  var length = values.length;

  if (length === 0) {
    return NaN;
  } // var pre = values[0];


  var rst;

  if (value > values[length - 1]) {
    return NaN;
  }

  if (value < values[0]) {
    return values[0];
  }

  for (var i = 1; i < values.length; i++) {
    if (value <= values[i]) {
      rst = values[i];
      break;
    }
  }

  return rst;
}

var Util = {
  // 鑾峰彇閫艰繎鐨勬暟鍊�
  snapFactorTo: function snapFactorTo(v, arr, snapType) {
    // 鍋囪 v = -512,isFloor = true
    if (isNaN(v)) {
      return NaN;
    }

    var factor = 1; // 璁＄畻绯绘暟

    if (v !== 0) {
      if (v < 0) {
        factor = -1;
      }

      v = v * factor; // v = 512

      var tmpFactor = getFactor(v);
      factor = factor * tmpFactor; // factor = -100

      v = v / tmpFactor; // v = 5.12
    }

    if (snapType === 'floor') {
      v = Util.snapFloor(arr, v); // v = 5
    } else if (snapType === 'ceil') {
      v = Util.snapCeiling(arr, v); // v = 6
    } else {
      v = Util.snapTo(arr, v); // 鍥涜垗浜斿叆 5
    }

    var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 濡傛灉鍑虹幇娴偣鏁拌绠楅棶棰橈紝闇€瑕佸鐞嗕竴涓�
    // 濡傛灉鍑虹幇娴偣鏁拌绠楅棶棰橈紝闇€瑕佸鐞嗕竴涓�

    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {
      var decimalVal = parseInt(1 / factor);
      var symbol = factor > 0 ? 1 : -1;
      rst = v / decimalVal * symbol;
    }

    return rst;
  },
  // 鑾峰彇閫艰繎鐨勫€嶆暟
  snapMultiple: function snapMultiple(v, base, snapType) {
    var div;

    if (snapType === 'ceil') {
      div = Math.ceil(v / base);
    } else if (snapType === 'floor') {
      div = Math.floor(v / base);
    } else {
      div = Math.round(v / base);
    }

    return div * base;
  },

  /**
   * 鑾峰彇閫艰繎鐨勫€硷紝鐢ㄤ簬瀵归綈鏁版嵁
   * @param  {Array} values   鏁版嵁闆嗗悎
   * @param  {Number} value   鏁板€�
   * @return {Number} 閫艰繎鐨勫€�
   */
  snapTo: function snapTo(values, value) {
    // 杩欓噷鍋囧畾values鏄崌搴忔帓鍒�
    var floorVal = arrayFloor(values, value);
    var ceilingVal = arrayCeiling(values, value);

    if (isNaN(floorVal) || isNaN(ceilingVal)) {
      if (values[0] >= value) {
        return values[0];
      }

      var last = values[values.length - 1];

      if (last <= value) {
        return last;
      }
    }

    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {
      return floorVal;
    }

    return ceilingVal;
  },

  /**
   * 鑾峰彇閫艰繎鐨勬渶灏忓€硷紝鐢ㄤ簬瀵归綈鏁版嵁
   * @param  {Array} values   鏁版嵁闆嗗悎
   * @param  {Number} value   鏁板€�
   * @return {Number} 閫艰繎鐨勬渶灏忓€�
   */
  snapFloor: function snapFloor(values, value) {
    // 杩欓噷鍋囧畾values鏄崌搴忔帓鍒�
    return arrayFloor(values, value);
  },

  /**
   * 鑾峰彇閫艰繎鐨勬渶澶у€硷紝鐢ㄤ簬瀵归綈鏁版嵁
   * @param  {Array} values   鏁版嵁闆嗗悎
   * @param  {Number} value   鏁板€�
   * @return {Number} 閫艰繎鐨勬渶澶у€�
   */
  snapCeiling: function snapCeiling(values, value) {
    // 杩欓噷鍋囧畾values鏄崌搴忔帓鍒�
    return arrayCeiling(values, value);
  },
  fixedBase: function fixedBase(v, base) {
    var str = base.toString();
    var index = str.indexOf('.');
    var indexOfExp = str.indexOf('e-'); // 鍒ゆ柇鏄惁甯﹀皬鏁扮偣锛�1.000001 1.23e-9

    if (index < 0 && indexOfExp < 0) {
      // base涓烘暣鏁�
      return Math.round(v);
    }

    var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;

    if (length > 20) {
      length = 20;
    }

    return parseFloat(v.toFixed(length));
  }
};
module.exports = Util;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(26);

var catAuto = __webpack_require__(151);

var each = __webpack_require__(2);

var isNumber = __webpack_require__(11);

var isString = __webpack_require__(15);

var Category =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Category, _Base);

  function Category() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Category.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Base.prototype._initDefaultCfg.call(this);

    this.type = 'cat';
    /**
     * 鏄惁鍒嗙被搴﹂噺
     * @type {Boolean}
     */

    this.isCategory = true;
    this.isRounding = true; // 鏄惁杩涜鍙栨暣鎿嶄綔
  }
  /**
   * @override
   */
  ;

  _proto.init = function init() {
    var self = this;
    var values = self.values;
    var tickCount = self.tickCount;
    each(values, function (v, i) {
      values[i] = v.toString();
    });

    if (!self.ticks) {
      var ticks = values;

      if (tickCount) {
        var temp = catAuto({
          maxCount: tickCount,
          data: values,
          isRounding: self.isRounding
        });
        ticks = temp.ticks;
      }

      this.ticks = ticks;
    }
  }
  /**
   * @override
   */
  ;

  _proto.getText = function getText(value) {
    if (this.values.indexOf(value) === -1 && isNumber(value)) {
      value = this.values[Math.round(value)];
    }

    return _Base.prototype.getText.call(this, value);
  }
  /**
   * @override
   */
  ;

  _proto.translate = function translate(value) {
    var index = this.values.indexOf(value);

    if (index === -1 && isNumber(value)) {
      index = value;
    } else if (index === -1) {
      index = NaN;
    }

    return index;
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var percent;

    if (isString(value) || this.values.indexOf(value) !== -1) {
      value = this.translate(value);
    }

    if (this.values.length > 1) {
      percent = value / (this.values.length - 1);
    } else {
      percent = value;
    }

    return rangeMin + percent * (rangeMax - rangeMin);
  }
  /**
   * @override
   */
  ;

  _proto.invert = function invert(value) {
    if (isString(value)) {
      // 濡傛灉宸茬粡鏄瓧绗︿覆
      return value;
    }

    var min = this.rangeMin();
    var max = this.rangeMax(); // 褰掍竴鍒� 鑼冨洿鍐�

    if (value < min) {
      value = min;
    }

    if (value > max) {
      value = max;
    }

    var percent = (value - min) / (max - min);
    var index = Math.round(percent * (this.values.length - 1)) % this.values.length;
    index = index || 0;
    return this.values[index];
  };

  return Category;
}(Base);

Base.Cat = Category;
module.exports = Category;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Scale entry, used to reference all the scales
 * @author dxq613@gmail.com
 */
var lowerFirst = __webpack_require__(187);

var Base = __webpack_require__(26);

Base.Linear = __webpack_require__(51);
Base.Identity = __webpack_require__(353);
Base.Cat = __webpack_require__(153);
Base.Time = __webpack_require__(357);
Base.TimeCat = __webpack_require__(356);
Base.Log = __webpack_require__(354);
Base.Pow = __webpack_require__(355);

var _loop = function _loop(k) {
  if (Base.hasOwnProperty(k)) {
    var methodName = lowerFirst(k);

    Base[methodName] = function (cfg) {
      return new Base[k](cfg);
    };
  }
};

for (var k in Base) {
  _loop(k);
}

var CAT_ARR = ['cat', 'timeCat'];

Base.isCategory = function (type) {
  return CAT_ARR.indexOf(type) >= 0;
};

module.exports = Base;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);

var splice = Array.prototype.splice;

var pullAt = function pullAt(arr, indexes) {
  if (!isArrayLike(arr)) {
    return [];
  }
  var length = arr ? indexes.length : 0;
  var last = length - 1;

  while (length--) {
    var previous = void 0;
    var index = indexes[length];
    if (length === last || index !== previous) {
      previous = index;
      splice.call(arr, index, 1);
    }
  }
  return arr;
};

module.exports = pullAt;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;
var slice = arrPrototype.slice;

var pull = function pull(arr) {
  var values = slice.call(arguments, 1);
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var fromIndex = -1;
    while ((fromIndex = indexOf.call(arr, value)) > -1) {
      splice.call(arr, fromIndex, 1);
    }
  }
  return arr;
};

module.exports = pull;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var contains = __webpack_require__(53);

var uniq = function uniq(arr) {
  var resultArr = [];
  each(arr, function (item) {
    if (!contains(resultArr, item)) {
      resultArr.push(item);
    }
  });
  return resultArr;
};

module.exports = uniq;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(14);
var toArray = __webpack_require__(57);
var mix = __webpack_require__(10);

var augment = function augment(c) {
  var args = toArray(arguments);
  for (var i = 1; i < args.length; i++) {
    var obj = args[i];
    if (isFunction(obj)) {
      obj = obj.prototype;
    }
    mix(c.prototype, obj);
  }
};

module.exports = augment;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * 鍒涘缓DOM 鑺傜偣
 * @param  {String} str Dom 瀛楃涓�
 * @return {HTMLElement}  DOM 鑺傜偣
 */
var TABLE = document.createElement('table');
var TABLE_TR = document.createElement('tr');
var FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
var CONTAINERS = {
  tr: document.createElement('tbody'),
  tbody: TABLE,
  thead: TABLE,
  tfoot: TABLE,
  td: TABLE_TR,
  th: TABLE_TR,
  '*': document.createElement('div')
};

module.exports = function createDom(str) {
  var name = FRAGMENT_REG.test(str) && RegExp.$1;
  if (!(name in CONTAINERS)) {
    name = '*';
  }
  var container = CONTAINERS[name];
  str = str.replace(/(^\s*)|(\s*$)/g, '');
  container.innerHTML = '' + str;
  var dom = container.childNodes[0];
  container.removeChild(dom);
  return dom;
};

/***/ }),
/* 160 */
/***/ (function(module, exports) {


module.exports = function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
};

/***/ }),
/* 161 */
/***/ (function(module, exports) {


module.exports = function requestAnimationFrame(fn) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
    return setTimeout(fn, 16);
  };

  return method(fn);
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(14);
var mix = __webpack_require__(10);

var extend = function extend(subclass, superclass, overrides, staticOverrides) {
  // 濡傛灉鍙彁渚涚埗绫绘瀯閫犲嚱鏁帮紝鍒欒嚜鍔ㄧ敓鎴愬瓙绫绘瀯閫犲嚱鏁�
  if (!isFunction(superclass)) {
    overrides = superclass;
    superclass = subclass;
    subclass = function subclass() {};
  }

  var create = Object.create ? function (proto, c) {
    return Object.create(proto, {
      constructor: {
        value: c
      }
    });
  } : function (proto, c) {
    function Tmp() {}
    Tmp.prototype = proto;
    var o = new Tmp();
    o.constructor = c;
    return o;
  };

  var superObj = create(superclass.prototype, subclass); // new superclass(),//瀹炰緥鍖栫埗绫讳綔涓哄瓙绫荤殑prototype
  subclass.prototype = mix(superObj, subclass.prototype); // 鎸囧畾瀛愮被鐨刾rototype
  subclass.superclass = create(superclass.prototype, superclass);
  mix(superObj, overrides);
  mix(subclass, staticOverrides);
  return subclass;
};

module.exports = extend;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isArray = __webpack_require__(4);
var hasOwnProperty = Object.prototype.hasOwnProperty;
var groupBy = function groupBy(data, condition) {
  if (!condition || !isArray(data)) {
    return data;
  }
  var result = {};
  var key = null;
  each(data, function (item) {
    key = condition(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  });
  return result;
};

module.exports = groupBy;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(14);
var isArray = __webpack_require__(4);
var groupBy = __webpack_require__(163);

var groupToMap = function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!isFunction(condition)) {
    var paramsCondition = isArray(condition) ? condition : condition.replace(/\s+/g, '').split('*');
    condition = function condition(row) {
      var unique = '_'; // 閬垮厤鍑虹幇鏁板瓧浣滀负Key鐨勬儏鍐碉紝浼氳繘琛屾寜鐓ф暟瀛楃殑鎺掑簭
      for (var i = 0, l = paramsCondition.length; i < l; i++) {
        unique += row[paramsCondition[i]] && row[paramsCondition[i]].toString();
      }
      return unique;
    };
  }
  var groups = groupBy(data, condition);
  return groups;
};

module.exports = groupToMap;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var groupToMap = __webpack_require__(164);

var group = function group(data, condition) {
  if (!condition) {
    return [data];
  }
  var groups = groupToMap(data, condition);
  var array = [];
  for (var i in groups) {
    array.push(groups[i]);
  }
  return array;
};

module.exports = group;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {


var each = __webpack_require__(2);
var mix = __webpack_require__(10);

// collections
var DOMUtil = __webpack_require__(378);
var arrayUtil = __webpack_require__(364);
var eventUtil = __webpack_require__(380);
var formatUtil = __webpack_require__(382);
var mathUtil = __webpack_require__(390);
var matrixUtil = __webpack_require__(56);
var objectUtil = __webpack_require__(401);
var pathUtil = __webpack_require__(405);
var stringUtil = __webpack_require__(409);
var typeUtil = __webpack_require__(414);

var util = {
  // collections
  DOMUtil: DOMUtil,
  DomUtil: DOMUtil,
  MatrixUtil: matrixUtil,
  PathUtil: pathUtil,
  arrayUtil: arrayUtil,
  domUtil: DOMUtil,
  eventUtil: eventUtil,
  formatUtil: formatUtil,
  mathUtil: mathUtil,
  matrixUtil: matrixUtil,
  objectUtil: objectUtil,
  stringUtil: stringUtil,
  pathUtil: pathUtil,
  typeUtil: typeUtil,
  // others
  augment: __webpack_require__(158),
  clone: __webpack_require__(80),
  debounce: __webpack_require__(369),
  deepMix: __webpack_require__(81),
  each: each,
  extend: __webpack_require__(162),
  filter: __webpack_require__(82),
  group: __webpack_require__(165),
  groupBy: __webpack_require__(163),
  groupToMap: __webpack_require__(164),
  indexOf: __webpack_require__(386),
  isEmpty: __webpack_require__(167),
  isEqual: __webpack_require__(83),
  isEqualWith: __webpack_require__(387),
  map: __webpack_require__(388),
  mix: mix,
  pick: __webpack_require__(408),
  throttle: __webpack_require__(413),
  toArray: __webpack_require__(57),
  toString: __webpack_require__(38),
  uniqueId: __webpack_require__(194)
};

each([DOMUtil, arrayUtil, eventUtil, formatUtil, mathUtil, matrixUtil, objectUtil, pathUtil, stringUtil, typeUtil], function (collection) {
  mix(util, collection);
});

module.exports = util;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(6);
var isArrayLike = __webpack_require__(21);
var getType = __webpack_require__(190);
var isPrototype = __webpack_require__(193);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEmpty(value) {
  /**
   * isEmpty(null) => true
   * isEmpty() => true
   * isEmpty(true) => true
   * isEmpty(1) => true
   * isEmpty([1, 2, 3]) => false
   * isEmpty('abc') => false
   * isEmpty({ a: 1 }) => false
   */
  if (isNil(value)) {
    return true;
  }
  if (isArrayLike(value)) {
    return !value.length;
  }
  var type = getType(value);
  if (type === 'Map' || type === 'Set') {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var isFunction = __webpack_require__(14);
var each = __webpack_require__(2);
/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
var maxBy = function maxBy(arr, fn) {
  if (!isArray(arr)) {
    return undefined;
  }
  var max = arr[0];
  var maxData = void 0;
  if (isFunction(fn)) {
    maxData = fn(arr[0]);
  } else {
    maxData = arr[0][fn];
  }
  var data = void 0;
  each(arr, function (val) {
    if (isFunction(fn)) {
      data = fn(val);
    } else {
      data = val[fn];
    }
    if (data > maxData) {
      max = val;
      maxData = data;
    }
  });
  return max;
};

module.exports = maxBy;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

var mod = function mod(n, m) {
  return (n % m + m) % m;
};

module.exports = mod;

/***/ }),
/* 170 */
/***/ (function(module, exports) {

var DEGREE = 180 / Math.PI;

var toDegree = function toDegree(radian) {
  return DEGREE * radian;
};

module.exports = toDegree;

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = parseInt;

/***/ }),
/* 172 */
/***/ (function(module, exports) {

var RADIAN = Math.PI / 180;

var toRadian = function toRadian(degree) {
  return RADIAN * degree;
};

module.exports = toRadian;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var clone = __webpack_require__(80);
var each = __webpack_require__(2);
var mat3 = __webpack_require__(85);

module.exports = function transform(m, ts) {
  m = clone(m);
  each(ts, function (t) {
    switch (t[0]) {
      case 't':
        mat3.translate(m, m, [t[1], t[2]]);
        break;
      case 's':
        mat3.scale(m, m, [t[1], t[2]]);
        break;
      case 'r':
        mat3.rotate(m, m, t[1]);
        break;
      case 'm':
        mat3.multiply(m, m, t[1]);
        break;
      default:
        return false;
    }
  });
  return m;
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__(349);
var clamp = __webpack_require__(84);

vec2.angle = function (v1, v2) {
  var theta = vec2.dot(v1, v2) / (vec2.length(v1) * vec2.length(v2));
  return Math.acos(clamp(theta, -1, 1));
};
/**
 * 鍚戦噺 v1 鍒� 鍚戦噺 v2 澶硅鐨勬柟鍚�
 * @param  {Array} v1 鍚戦噺
 * @param  {Array} v2 鍚戦噺
 * @return {Boolean} >= 0 椤烘椂閽� < 0 閫嗘椂閽�
 */
vec2.direction = function (v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
};
vec2.angleTo = function (v1, v2, direct) {
  var angle = vec2.angle(v1, v2);
  var angleLargeThanPI = vec2.direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - angle;
    }

    return angle;
  }

  if (angleLargeThanPI) {
    return angle;
  }
  return Math.PI * 2 - angle;
};
vec2.vertical = function (out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }

  return out;
};

module.exports = vec2;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var vec3 = __webpack_require__(350);

module.exports = vec3;

/***/ }),
/* 176 */
/***/ (function(module, exports) {


module.exports = function (obj, key) {
  return obj.hasOwnProperty(key);
};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var keys = __webpack_require__(178);
var isNil = __webpack_require__(6);

function isMatch(obj, attrs) {
  var _keys = keys(attrs);
  var length = _keys.length;
  if (isNil(obj)) return !length;
  for (var i = 0; i < length; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}

module.exports = isMatch;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isFunction = __webpack_require__(14);

var keys = Object.keys ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var result = [];
  each(obj, function (value, key) {
    if (!(isFunction(obj) && key === 'prototype')) {
      result.push(key);
    }
  });
  return result;
};

module.exports = keys;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isFunction = __webpack_require__(14);

var values = Object.values ? function (obj) {
  return Object.values(obj);
} : function (obj) {
  var result = [];
  each(obj, function (value, key) {
    if (!(isFunction(obj) && key === 'prototype')) {
      result.push(value);
    }
  });
  return result;
};

module.exports = values;

/***/ }),
/* 180 */
/***/ (function(module, exports) {

// http://schepers.cc/getting-to-the-point
module.exports = function catmullRom2bezier(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [{
      x: +crp[i - 2],
      y: +crp[i - 1]
    }, {
      x: +crp[i],
      y: +crp[i + 1]
    }, {
      x: +crp[i + 2],
      y: +crp[i + 3]
    }, {
      x: +crp[i + 4],
      y: +crp[i + 5]
    }];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
  }

  return d;
};

/***/ }),
/* 181 */
/***/ (function(module, exports) {


var p2s = /,?([a-z]),?/gi;

module.exports = function parsePathArray(path) {
  return path.join(',').replace(p2s, '$1');
};

/***/ }),
/* 182 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var SPACES = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029';
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');

// Parses given path string into an array of arrays of path segments
module.exports = function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }

  if ((typeof pathString === 'undefined' ? 'undefined' : _typeof(pathString)) === _typeof([])) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];

  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });
    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }
    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
  });

  return data;
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var parsePathString = __webpack_require__(182);
var catmullRom2bezier = __webpack_require__(180);

function ellipsePath(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
  } else {
    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
  }
  return res;
}

module.exports = function pathToAbsolute(pathArray) {
  pathArray = parsePathString(pathArray);

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0 = void 0;
  var dots = void 0;
  if (pathArray[0][0] === 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';
  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case 'V':
          r[1] = +pa[1] + y;
          break;
        case 'H':
          r[1] = +pa[1] + x;
          break;
        case 'R':
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRom2bezier(dots, crz));
          break;
        case 'O':
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case 'U':
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ['U'].concat(res[res.length - 1].slice(-2));
          break;
        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break; // for lint
        default:
          for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {
            r[_j] = +pa[_j] + (_j % 2 ? x : y);
          }
      }
    } else if (pa0 === 'R') {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRom2bezier(dots, crz));
      r = ['R'].concat(pa.slice(-2));
    } else if (pa0 === 'O') {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === 'U') {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ['U'].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== 'O') {
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;
        case 'H':
          x = r[1];
          break;
        case 'V':
          y = r[1];
          break;
        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break; // for lint
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }

  return res;
};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var pathToAbsolute = __webpack_require__(183);

var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  if (rx === ry) {
    rx += 1;
  }

  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy = void 0;
  var f1 = void 0;
  var f2 = void 0;
  var cx = void 0;
  var cy = void 0;
  var rotate = function rotate(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      // 鑻ュ姬鐨勮捣濮嬬偣鍜岀粓鐐归噸鍙犲垯閿欏紑涓€鐐�
      x2 += 1;
      y2 += 1;
    }
    // const cos = Math.cos(Math.PI / 180 * angle);
    // const sin = Math.sin(Math.PI / 180 * angle);
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));

    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(',');
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
  }
  return newres;
};

var l2c = function l2c(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};

var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};

module.exports = function pathTocurve(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = []; // path commands of original path p
  var pcoms2 = []; // path commands of original path p2
  var pfirst = ''; // temporary holder for original path command
  var pcom = ''; // holder for previous path command of original path
  var ii = void 0;
  var processPath = function processPath(path, d, pcom) {
    var nx = void 0,
        ny = void 0;
    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }!(path[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;
      case 'A':
        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
        break;
      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In "S" case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous
          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }
        path = ['C', nx, ny].concat(path.slice(1));
        break;
      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In "T" case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar
          d.qy = d.y * 2 - d.qy; // to case "S".
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }
        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
        break;
      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
        break;
      case 'L':
        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
        break;
      case 'H':
        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
        break;
      case 'V':
        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
        break;
      case 'Z':
        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
      default:
        break;
    }
    return path;
  };
  var fixArc = function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];
      while (pi.length) {
        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved
        p2 && (pcoms2[i] = 'A'); // the same as above
        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
      }
      pp.splice(i, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function fixM(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
      path2.splice(i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {

    p[i] && (pfirst = p[i][0]); // save current path command

    if (pfirst !== 'C') {
      // C is not saved yet, because it may be result of conversion
      pcoms1[i] = pfirst; // Save current path command
      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
    }
    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

    if (p2) {
      // the same procedures is done to p2
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== 'C') {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);

      if (pcoms2[i] !== 'A' && pfirst === 'C') {
        pcoms2[i] = 'C';
      }

      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }

  return p2 ? [p, p2] : p;
};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var parsePathArray = __webpack_require__(181);

module.exports = function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }
  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
  res.parsePathArray = parsePathArray;
  return res;
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(38);

var lowerCase = function lowerCase(str) {
  return toString(str).toLowerCase();
};

module.exports = lowerCase;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(38);

var lowerFirst = function lowerFirst(value) {
  var str = toString(value);
  return str.charAt(0).toLowerCase() + str.substring(1);
};

module.exports = lowerFirst;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(38);

var upperCase = function upperCase(str) {
  return toString(str).toUpperCase();
};

module.exports = upperCase;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(38);

var upperFirst = function upperFirst(value) {
  var str = toString(value);
  return str.charAt(0).toUpperCase() + str.substring(1);
};

module.exports = upperFirst;

/***/ }),
/* 190 */
/***/ (function(module, exports) {

var toString = {}.toString;

var getType = function getType(value) {
  return toString.call(value).replace(/^\[object /, '').replace(/\]$/, '');
};

module.exports = getType;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 鏄惁鏄竷灏旂被鍨�
 *
 * @param {Object} value 娴嬭瘯鐨勫€�
 * @return {Boolean}
 */
var isType = __webpack_require__(17);

var isBoolean = function isBoolean(value) {
  return isType(value, 'Boolean');
};

module.exports = isBoolean;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(17);

var isDate = function isDate(value) {
  return isType(value, 'Date');
};

module.exports = isDate;

/***/ }),
/* 193 */
/***/ (function(module, exports) {

var objectProto = Object.prototype;
var isPrototype = function isPrototype(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;
  return value === proto;
};

module.exports = isPrototype;

/***/ }),
/* 194 */
/***/ (function(module, exports) {

var uniqueId = function () {
  var map = {};
  return function (prefix) {
    prefix = prefix || 'g';
    if (!map[prefix]) {
      map[prefix] = 1;
    } else {
      map[prefix] += 1;
    }
    return prefix + map[prefix];
  };
}();

module.exports = uniqueId;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  COORD_FUNC_PROPS: ['rotate', 'scale', 'reflect', 'transpose'],
  GEOM_FUNC_PROPS: ['position', 'color', 'size', 'shape', 'opacity', 'tooltip', 'style', 'animate', 'active', 'select', 'sets']
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _util = __webpack_require__(58);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * prop function
 */
var chartItemEvents = [{ prop: 'onPlotMove', event: 'plotmove' }, { prop: 'onPlotEnter', event: 'plotenter' }, { prop: 'onPlotLeave', event: 'plotleave' }, { prop: 'onPlotClick', event: 'plotclick' }, { prop: 'onPlotDblClick', event: 'plotdblclick' }, { prop: 'onItemSelected', event: 'itemselected' }, { prop: 'onItemUnselected', event: 'itemunselected' }, { prop: 'onItemSelectedChange', event: 'itemselectedchange' }, { prop: 'onTooltipChange', event: 'tooltip:change' }, { prop: 'onTooltipShow', event: 'tooltip:show' }, { prop: 'onTooltipHide', event: 'tooltip:hide' }];

var baseEventNames = ['mouseenter', 'mousemove', 'mouseleave', 'click', 'dblclick', 'mousedown', 'mouseup', 'touchstart', 'touchmove', 'touchend'];

var baseEventsPostfix = ['Mouseenter', 'Mousemove', 'Mouseleave', 'Click', 'Dblclick', 'Mousedown', 'Mouseup', 'Touchstart', 'Touchmove', 'Touchend'];

var shapes = ['point', 'area', 'line', 'path', 'interval', 'schema', 'polygon', 'edge', 'axis-title', 'axis-label', 'axis-ticks', 'axis-line', 'axis-grid', 'legend-title', 'legend-item', 'legend-marker', 'legend-text', 'guide-text', 'guide-region', 'guide-line', 'guide-image', 'label'];

var shapesEvtNamePrefix = ['onPoint', 'onArea', 'onLine', 'onPath', 'onInterval', 'onSchema', 'onPolygon', 'onEdge', 'onAxisTitle', 'onAxisLabel', 'onAxisTicks', 'onAxisLine', 'onAxisGrid', 'onLegendTitle', 'onLegendItem', 'onLegendMarker', 'onLegendText', 'onGuideText', 'onGuideRegion', 'onGuideLine', 'onGuideImage', 'onLabel'];

var shapeEvents = [];
for (var i = 0; i < shapes.length; i += 1) {
  for (var j = 0; j < baseEventNames.length; j += 1) {
    shapeEvents.push({
      prop: '' + shapesEvtNamePrefix[i] + baseEventsPostfix[j],
      event: shapes[i] + ':' + baseEventNames[j]
    });
  }
}

var chartEvents = chartItemEvents.concat(shapeEvents);

function genBaseEvents() {
  return [{ prop: 'onMouseEnter', event: 'mouseenter' }, { prop: 'onMouseMove', event: 'mousemove' }, { prop: 'onMouseLeave', event: 'mouseleave' }, { prop: 'onClick', event: 'click' }, { prop: 'onDblClick', event: 'dblclick' }, { prop: 'onMouseDown', event: 'mousedown' }, { prop: 'onMouseUp', event: 'mouseup' }, { prop: 'onTouchStart', event: 'touchstart' }, { prop: 'onTouchMove', event: 'touchmove' }, { prop: 'onTouchEnd', event: 'touchend' }];
}

function genItemBaseEvents(type) {
  var geomEvents = genBaseEvents();
  _util2.default.map(geomEvents, function (key) {
    var event = key.event;
    key.event = type + ':' + event;
    return key;
  });
  return geomEvents;
}

var baseEvents = genBaseEvents();

var baseEventObjectTypes = {
  onMouseEnter: _propTypes2.default.object,
  onMouseMove: _propTypes2.default.object,
  onMouseLeave: _propTypes2.default.object,
  onClick: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
  onDblClick: _propTypes2.default.object,
  onMouseDown: _propTypes2.default.object,
  onMouseUp: _propTypes2.default.object,
  onTouchStart: _propTypes2.default.object,
  onTouchMove: _propTypes2.default.object,
  onTouchEnd: _propTypes2.default.object
};

var baseEventFuncTypes = {
  onMouseEnter: _propTypes2.default.func,
  onMouseMove: _propTypes2.default.func,
  onMouseLeave: _propTypes2.default.func,
  onClick: _propTypes2.default.func,
  onDblClick: _propTypes2.default.func,
  onMouseDown: _propTypes2.default.func,
  onMouseUp: _propTypes2.default.func,
  onTouchStart: _propTypes2.default.func,
  onTouchMove: _propTypes2.default.func,
  onTouchEnd: _propTypes2.default.func
};

function bindEvents(chart) {
  var EVENTS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var props = arguments[2];

  _util2.default.each(EVENTS, function (key) {
    var prop = key.prop,
        event = key.event;

    var fns = props[prop];

    if (_util2.default.isFunction(fns)) {
      chart.on(event, fns);
    } else if (_util2.default.isObject(fns)) {
      for (var name in fns) {
        if (fns[name] !== undefined) {
          chart.on(name + ':' + event, fns[name]);
        }
      }
    }
  });
}

function bindBaseEvents(chart, props) {
  bindEvents(chart, baseEvents, props);
}

function updateEvents(chart) {
  var EVENTS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var props = arguments[2];
  var nextProps = arguments[3];

  _util2.default.each(EVENTS, function (key) {
    var prop = key.prop,
        event = key.event;

    var fns = props[prop];
    var nextFns = nextProps[prop];
    var name = void 0;

    if (!_util2.default.shallowEqual(fns, nextFns)) {
      if (_util2.default.isFunction(fns) && _util2.default.isFunction(nextFns)) {
        chart.off(event, fns);
        chart.on(event, nextFns);
      } else if (_util2.default.isObject(fns) && _util2.default.isObject(nextFns)) {
        for (name in fns) {
          if (Object.prototype.hasOwnProperty.call(fns, name)) {
            chart.off(name + ':' + event, fns[name]);
          }
        }
        for (name in nextFns) {
          if (Object.prototype.hasOwnProperty.call(nextFns, name)) {
            chart.on(name + ':' + event, nextFns[name]);
          }
        }
      }
    }
  });
}

function updateBaseEvents(chart, props, nextProps) {
  updateEvents(chart, baseEvents, props, nextProps);
}

function unbindEvents(chart) {
  var EVENTS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var props = arguments[2];

  _util2.default.each(EVENTS, function (key) {
    var prop = key.prop,
        event = key.event;

    var fns = props[prop];

    if (_util2.default.isFunction(fns)) {
      chart.off(event, fns);
    } else if (_util2.default.isObject(fns)) {
      for (var name in fns) {
        if (Object.prototype.hasOwnProperty.call(fns, name)) {
          chart.off(name + ':' + event, fns[name]);
        }
      }
    }
  });
}

function unbindBaseEvents(chart, props) {
  unbindEvents(chart, baseEvents, props);
}

exports.default = {
  baseEventObjectTypes: baseEventObjectTypes,
  baseEventFuncTypes: baseEventFuncTypes,
  genBaseEvents: genBaseEvents,
  genItemBaseEvents: genItemBaseEvents,
  bindEvents: bindEvents,
  bindBaseEvents: bindBaseEvents,
  updateEvents: updateEvents,
  updateBaseEvents: updateBaseEvents,
  unbindEvents: unbindEvents,
  unbindBaseEvents: unbindBaseEvents,
  chartEvents: chartEvents
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _core = __webpack_require__(45);

var G2 = _interopRequireWildcard(_core);

var _shared = __webpack_require__(88);

var _common = __webpack_require__(195);

var _common2 = _interopRequireDefault(_common);

var _event = __webpack_require__(196);

var _event2 = _interopRequireDefault(_event);

var _configMerge = __webpack_require__(87);

var _configMerge2 = _interopRequireDefault(_configMerge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var COORD_FUNC_PROPS = _common2.default.COORD_FUNC_PROPS;
var GEOM_FUNC_PROPS = _common2.default.GEOM_FUNC_PROPS;

exports.default = {
  createChart: function createChart(config) {
    var chartConfig = config.chart;
    var shouldForceFit = chartConfig.props.forceFit;
    chartConfig.props.forceFit = false;
    var chart = new G2.Chart(chartConfig.props);
    if (chartConfig.props.afterChartInitialized) {
      chartConfig.props.afterChartInitialized(chart);
    }
    // 淇濊瘉绗竴娆℃覆鏌撴槸姝ｇ‘鐨�
    if (shouldForceFit) {
      chart.forceFit();
    }
    chartConfig.g2Instance = chart;
    return chart;
  },
  executeChartConfig: function executeChartConfig(chart, config) {
    var chartConfig = config.chart;
    var props = chartConfig.props;
    chart.coord('rect', {});
    chart.source(props.data, props.scale);
    if (!config.facet && !props.axis || !config.facet || props.axis === false) {
      chart.axis(false);
    }
    chart.legend(false);
    chart.tooltip(false);
    if (props.filter) {
      props.filter.forEach(function (filterArg) {
        chart.filter(filterArg[0], filterArg[1]);
      });
    }
    _event2.default.bindEvents(chart, _event2.default.chartEvents, props);
    _event2.default.bindBaseEvents(chart, props);
  },
  coord: function coord(chart, config) {
    var coordConfig = config.coord;
    if (!coordConfig || coordConfig.g2Instance) {
      return;
    }

    var _coordConfig$props = coordConfig.props,
        type = _coordConfig$props.type,
        others = _objectWithoutProperties(_coordConfig$props, ['type']);

    var coordIns = chart.coord(type || 'rect', _shared.Util.without(others, COORD_FUNC_PROPS));
    _shared.Prop.init(COORD_FUNC_PROPS, others, function (value, key) {
      if (key === 'reflect') {
        _shared.Util.each(value, function (v) {
          return coordIns[key](v);
        });
      } else if (key === 'transpose') {
        if (value[0] === true) coordIns[key].apply(coordIns, _toConsumableArray(value));
      } else {
        coordIns[key].apply(coordIns, _toConsumableArray(value));
      }
    });
    coordConfig.g2Instance = coordIns;
  },
  createLabel: function createLabel(geom, labelConfig) {
    if (!labelConfig || labelConfig.g2Instance) {
      return;
    }

    var _labelConfig$props = labelConfig.props,
        content = _labelConfig$props.content,
        labelOthers = _objectWithoutProperties(_labelConfig$props, ['content']);

    if (content) {
      if (_shared.Util.isArray(content)) {
        labelConfig.g2Instance = geom.label(content[0], content[1], labelOthers);
      } else {
        labelConfig.g2Instance = geom.label(content, labelOthers);
      }
    }
  },
  createGeom: function createGeom(chart, geomConfig) {
    if (geomConfig.g2Instance) {
      if (geomConfig.label) {
        this.createLabel(geomConfig.g2Instance, geomConfig.label);
      }
      return;
    }

    var props = geomConfig.props;
    var geom = chart[props.type || 'interval']();

    if (props.adjust) {
      geom.adjust(props.adjust);
    }

    _shared.Prop.init(GEOM_FUNC_PROPS, props, function (value, key) {
      geom[key].apply(geom, _toConsumableArray(value));
    });

    geomConfig.g2Instance = geom;

    // create label
    this.createLabel(geom, geomConfig.label);
  },
  geoms: function geoms(chart, config) {
    var geoms = config.geoms;

    if (!geoms) {
      return;
    }
    for (var id in geoms) {
      if (Object.prototype.hasOwnProperty.call(geoms, id)) {
        this.createGeom(chart, geoms[id]);
      }
    }
  },
  legends: function legends(chart, config) {
    var legends = config.legends;

    for (var id in legends) {
      if (legends[id]) {
        var legendConfig = legends[id];
        if (legendConfig.g2Instance) {
          return;
        }

        var _legendConfig$props = legendConfig.props,
            name = _legendConfig$props.name,
            visible = _legendConfig$props.visible,
            cfg = _objectWithoutProperties(_legendConfig$props, ['name', 'visible']);

        var relVisible = visible;
        if (!Object.prototype.hasOwnProperty.call(legendConfig.props, 'visible')) {
          relVisible = true;
        }
        var arg = !relVisible ? relVisible : cfg;
        legendConfig.g2Instance = chart.legend.apply(chart, _toConsumableArray(name ? [name, arg] : [arg]));
      }
    }
  },
  tooltip: function tooltip(chart, config) {
    var tooltipConfig = config.tooltip;

    if (!tooltipConfig || tooltipConfig.g2Instance) {
      return;
    }
    tooltipConfig.g2Instance = chart.tooltip(_extends({}, tooltipConfig.props));
  },
  createAxis: function createAxis(chart, axisConfig) {
    if (axisConfig.g2Instance) {
      return;
    }

    var _axisConfig$props = axisConfig.props,
        name = _axisConfig$props.name,
        visible = _axisConfig$props.visible,
        others = _objectWithoutProperties(_axisConfig$props, ['name', 'visible']);

    if (visible || !Object.prototype.hasOwnProperty.call(axisConfig.props, 'visible')) {
      axisConfig.g2Instance = chart.axis(name, others);
    } else {
      axisConfig.g2Instance = chart.axis(name, false);
    }
  },
  axises: function axises(chart, config) {
    var axises = config.axises;

    for (var id in axises) {
      if (axises[id]) {
        this.createAxis(chart, axises[id]);
      }
    }
  },
  views: function views(chart, config) {
    var views = config.views;

    for (var id in views) {
      if (views[id]) {
        this.createView(chart, views[id]);
      }
    }
  },
  createView: function createView(chart, viewConfig) {
    if (viewConfig.parentInfo.name === 'Facet') {
      return;
    }
    if (viewConfig.g2Instance) {
      if (viewConfig.filter) {
        viewConfig.filter.forEach(function (filterArg) {
          viewConfig.g2Instance.filter(filterArg[0], filterArg[1]);
        });
      }
      this.coord(viewConfig.g2Instance, viewConfig);
      this.axises(viewConfig.g2Instance, viewConfig);
      this.geoms(viewConfig.g2Instance, viewConfig);
      this.guide(viewConfig.g2Instance, viewConfig.guide);
      return;
    }
    /*
       Others object must exclude geoms property.
       Because geoms property will cover the g2 view' inner geoms property.
    */
    /* eslint-disable  no-unused-vars */

    var _viewConfig$props = viewConfig.props,
        scale = _viewConfig$props.scale,
        data = _viewConfig$props.data,
        instance = _viewConfig$props.instance,
        axis = _viewConfig$props.axis,
        filter = _viewConfig$props.filter,
        geoms = _viewConfig$props.geoms,
        others = _objectWithoutProperties(_viewConfig$props, ['scale', 'data', 'instance', 'axis', 'filter', 'geoms']);
    /* eslint-enable */


    var view = void 0;
    if (instance) {
      view = instance;
    } else {
      view = chart.view(_extends({}, others));
    }

    if (data) {
      view.source(data, scale);
    }

    if (scale) {
      view.scale(scale);
    }

    if (filter) {
      filter.forEach(function (filterArg) {
        view.filter(filterArg[0], filterArg[1]);
      });
    }

    if (!(axis === true || instance)) {
      view.axis(false);
    }

    viewConfig.g2Instance = view;

    this.coord(view, viewConfig);
    this.axises(view, viewConfig);
    this.geoms(view, viewConfig);
    this.guide(view, viewConfig.guide);
  },
  facetView: function facetView(view, viewConfig) {
    /* eslint-disable  no-unused-vars */
    var _viewConfig$props2 = viewConfig.props,
        scale = _viewConfig$props2.scale,
        data = _viewConfig$props2.data,
        axis = _viewConfig$props2.axis,
        geoms = _viewConfig$props2.geoms,
        others = _objectWithoutProperties(_viewConfig$props2, ['scale', 'data', 'axis', 'geoms']);
    /* eslint-enable */


    if (data) {
      view.source(data, scale);
    }

    if (scale) {
      view.scale(scale);
    }

    if (axis === false) {
      view.axis(false);
    }

    this.coord(view, viewConfig);
    this.axises(view, viewConfig);
    this.geoms(view, viewConfig);
    this.guide(view, viewConfig.guide);
    _configMerge2.default.mergeView(viewConfig, true);
  },
  guide: function guide(chart, _guide) {
    if (!_guide) {
      return;
    }

    var guides = _guide.elements;

    for (var id in guides) {
      if (guides[id]) {
        var guideConfig = guides[id];
        if (!guideConfig.g2Instance) {
          /* eslint-disable  no-unused-vars */
          var _guideConfig$props = guideConfig.props,
              type = _guideConfig$props.type,
              others = _objectWithoutProperties(_guideConfig$props, ['type']);
          /* eslint-enable */


          guideConfig.g2Instance = chart.guide()[guideConfig.type](others);
        }
      }
    }
  },
  facet: function facet(chart, config) {
    var _this = this;

    var facetConfig = config.facet;

    if (!facetConfig || facetConfig.g2Instance) {
      return;
    }

    var _facetConfig$props = facetConfig.props,
        children = _facetConfig$props.children,
        type = _facetConfig$props.type,
        others = _objectWithoutProperties(_facetConfig$props, ['children', 'type']);

    if (!children) {
      chart.facet(type, others);
      return;
    }
    var views = config.views;
    var facetView = null;
    for (var id in views) {
      if (views[id] && views[id].parentInfo.name === 'Facet' && views[id].parentInfo.id === facetConfig.id) {
        // facet view
        facetView = views[id];
        break;
      }
    }
    if (facetView) {
      _configMerge2.default.mergeView(facetView, true);
      others.eachView = function (view) {
        _this.facetView(view, facetView);
      };
      chart.facet(type, others);
    }
  },
  synchronizeG2Add: function synchronizeG2Add(chart, config) {
    this.coord(chart, config);
    this.axises(chart, config);
    this.legends(chart, config);
    this.tooltip(chart, config);
    this.geoms(chart, config);
    this.facet(chart, config);
    this.views(chart, config);
    // this.synchronizeG2Views(chart, config);
    this.guide(chart, config.guide);
  },
  synchronizeG2Views: function synchronizeG2Views(chart, config) {
    var views = config.views;

    for (var id in views) {
      if (views[id]) {
        this.synchronizeG2View(views[id].g2Instance, views[id]);
      }
    }
  },
  synchronizeG2View: function synchronizeG2View(view, viewConfig) {
    /*
       Others object must exclude geoms property.
       Because geoms property will cover the g2 view' inner geoms property.
    */
    view.clear();
    this.clearViewG2Instance(viewConfig);
    /* eslint-disable  no-unused-vars */

    var _viewConfig$props3 = viewConfig.props,
        scale = _viewConfig$props3.scale,
        data = _viewConfig$props3.data,
        instance = _viewConfig$props3.instance,
        axis = _viewConfig$props3.axis,
        geoms = _viewConfig$props3.geoms,
        others = _objectWithoutProperties(_viewConfig$props3, ['scale', 'data', 'instance', 'axis', 'geoms']);
    /* eslint-enable */


    if (data) {
      view.source(data, scale);
    }

    if (scale) {
      view.scale(scale);
    }

    if (!(axis === true || instance)) {
      view.axis(false);
    }
    this.coord(view, viewConfig);
    this.axises(view, viewConfig);
    this.geoms(view, viewConfig);
    this.guide(view, viewConfig.guide);
  },
  clearViewG2Instance: function clearViewG2Instance(viewConfig) {
    if (viewConfig.coord) {
      delete viewConfig.coord.g2Instance;
    }
    if (viewConfig.axises) {
      Object.keys(viewConfig.axises).forEach(function (id) {
        delete viewConfig.axises[id].g2Instance;
      });
    }
    if (viewConfig.geoms) {
      Object.keys(viewConfig.geoms).forEach(function (id) {
        delete viewConfig.geoms[id].g2Instance;
        if (viewConfig.geoms[id].label) {
          delete viewConfig.geoms[id].label.g2Instance;
        }
      });
    }
    if (viewConfig.guide && viewConfig.guide.elements) {
      Object.keys(viewConfig.guide.elements).forEach(function (id) {
        delete viewConfig.guide.elements[id].g2Instance;
      });
    }
  }
};

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linear_js__ = __webpack_require__(449);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return __WEBPACK_IMPORTED_MODULE_0__linear_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__quad_js__ = __webpack_require__(451);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return __WEBPACK_IMPORTED_MODULE_1__quad_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return __WEBPACK_IMPORTED_MODULE_1__quad_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return __WEBPACK_IMPORTED_MODULE_1__quad_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return __WEBPACK_IMPORTED_MODULE_1__quad_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cubic_js__ = __webpack_require__(446);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return __WEBPACK_IMPORTED_MODULE_2__cubic_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__poly_js__ = __webpack_require__(450);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return __WEBPACK_IMPORTED_MODULE_3__poly_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return __WEBPACK_IMPORTED_MODULE_3__poly_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return __WEBPACK_IMPORTED_MODULE_3__poly_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return __WEBPACK_IMPORTED_MODULE_3__poly_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sin_js__ = __webpack_require__(452);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return __WEBPACK_IMPORTED_MODULE_4__sin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return __WEBPACK_IMPORTED_MODULE_4__sin_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return __WEBPACK_IMPORTED_MODULE_4__sin_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return __WEBPACK_IMPORTED_MODULE_4__sin_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__exp_js__ = __webpack_require__(448);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return __WEBPACK_IMPORTED_MODULE_5__exp_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return __WEBPACK_IMPORTED_MODULE_5__exp_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return __WEBPACK_IMPORTED_MODULE_5__exp_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return __WEBPACK_IMPORTED_MODULE_5__exp_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__circle_js__ = __webpack_require__(445);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return __WEBPACK_IMPORTED_MODULE_6__circle_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return __WEBPACK_IMPORTED_MODULE_6__circle_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return __WEBPACK_IMPORTED_MODULE_6__circle_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return __WEBPACK_IMPORTED_MODULE_6__circle_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bounce_js__ = __webpack_require__(444);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return __WEBPACK_IMPORTED_MODULE_7__bounce_js__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__back_js__ = __webpack_require__(443);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return __WEBPACK_IMPORTED_MODULE_8__back_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return __WEBPACK_IMPORTED_MODULE_8__back_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return __WEBPACK_IMPORTED_MODULE_8__back_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return __WEBPACK_IMPORTED_MODULE_8__back_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__elastic_js__ = __webpack_require__(447);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return __WEBPACK_IMPORTED_MODULE_9__elastic_js__["c"]; });





















/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(92);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
});


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(91);


/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__basis__["b" /* basis */])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
});


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(92);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return rgbBasisClosed; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basisClosed__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color__ = __webpack_require__(41);





/* harmony default export */ __webpack_exports__["a"] = ((function rgbGamma(y) {
  var color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__color__["c" /* gamma */])(y);

  function rgb(start, end) {
    var r = color((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(start)).r, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis__["a" /* default */]);
var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed__["a" /* default */]);


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(59);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = genericArray;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__numberArray_js__ = __webpack_require__(95);



/* unused harmony default export */ var _unused_webpack_default_export = (function(a, b) {
  return (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__numberArray_js__["a" /* isNumberArray */])(b) ? __WEBPACK_IMPORTED_MODULE_1__numberArray_js__["b" /* default */] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__value_js__["a" /* default */])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis_js__ = __webpack_require__(93);


/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__basis_js__["b" /* basis */])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value_js__ = __webpack_require__(96);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__value_js__["a" /* default */])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export rgbBasis */
/* unused harmony export rgbBasisClosed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basisClosed_js__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color_js__ = __webpack_require__(32);





/* harmony default export */ __webpack_exports__["a"] = ((function rgbGamma(y) {
  var color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__color_js__["c" /* gamma */])(y);

  function rgb(start, end) {
    var r = color((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(start)).r, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__color_js__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* rgb */])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis_js__["a" /* default */]);
var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed_js__["a" /* default */]);


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number_js__ = __webpack_require__(60);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(18);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["b" /* Selection */]([[document.querySelector(selector)]], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["b" /* Selection */]([[selector]], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = EnterNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(18);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["b" /* Selection */](this._enter || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(update) {
  return new Array(update.length);
});


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = styleValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(102);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__ = __webpack_require__(13);


/* harmony default export */ __webpack_exports__["a"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["a" /* STARTING */] && schedule.state < __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["b" /* ENDING */];
    schedule.state = __WEBPACK_IMPORTED_MODULE_0__transition_schedule_js__["c" /* ENDED */];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(94);



/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["b" /* interpolateNumber */]
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */] ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c" /* interpolateRgb */]
      : (c = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["c" /* interpolateRgb */])
      : __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["d" /* interpolateString */])(a, b);
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function (main) {
  'use strict';

  /**
   * Parse or format dates
   * @class fecha
   */
  var fecha = {};
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var literal = /\[([^]*?)\]/gm;
  var noop = function () {
  };

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function(dateObj) {
      return dateObj.getDate();
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return dateObj.getDay();
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return dateObj.getHours();
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    D: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    YY: [twoDigits, function (d, v) {
      var da = new Date(), cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    YYYY: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    d: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/([\+\-]\d\d:?\d\d|Z)/, function (d, v) {
      if (v === 'Z') v = '+00:00';
      var parts = (v + '').match(/([\+\-]|\d\d)/gi), minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;


  // Some common format strings
  fecha.masks = {
    default: 'ddd MMM DD YYYY HH:mm:ss',
    shortDate: 'M/D/YY',
    mediumDate: 'MMM D, YYYY',
    longDate: 'MMMM D, YYYY',
    fullDate: 'dddd, MMMM D, YYYY',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    var literals = [];

    // Make literals inactive by replacing them with ??
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return '??';
    });
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/\?\?/g, function() {
      return literals.shift();
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return false;
    }

    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }

      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });

    if (!isValid) {
      return false;
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return fecha;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    main.fecha = fecha;
  }
})(this);


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require('./cjs/react-is.production.min.js');
} else {
  module.exports = __webpack_require__(542);
}


/***/ }),
/* 225 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Adjust = __webpack_require__(33);

var each = __webpack_require__(2);

var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;

var Dodge =
/*#__PURE__*/
function (_Adjust) {
  _inheritsLoose(Dodge, _Adjust);

  function Dodge() {
    return _Adjust.apply(this, arguments) || this;
  }

  var _proto = Dodge.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    /**
     * 璋冩暣杩囩▼涓�,2涓暟鎹殑闂磋窛
     * @type {Number}
     */
    this.marginRatio = MARGIN_RATIO;
    /**
     * 璋冩暣鍗犲崟浣嶅搴︾殑姣斾緥,渚嬪锛氬崰2涓垎绫婚棿璺濈殑 1/2
     * @type {Number}
     */

    this.dodgeRatio = DODGE_RATIO;
    this.adjustNames = ['x', 'y']; // 璋冩暣鐨勭淮搴︼紝榛樿,x,y閮藉仛璋冩暣
  };

  _proto.getDodgeOffset = function getDodgeOffset(range, index, count) {
    var self = this;
    var pre = range.pre;
    var next = range.next;
    var tickLength = next - pre;
    var width = tickLength * self.dodgeRatio / count;
    var margin = self.marginRatio * width;
    var offset = 1 / 2 * (tickLength - count * width - (count - 1) * margin) + ((index + 1) * width + index * margin) - 1 / 2 * width - 1 / 2 * tickLength;
    return (pre + next) / 2 + offset;
  };

  _proto.processAdjust = function processAdjust(dataArray) {
    var self = this;
    var count = dataArray.length;
    var xField = self.xField;
    each(dataArray, function (data, index) {
      for (var i = 0, len = data.length; i < len; i++) {
        var obj = data[i];
        var value = obj[xField];
        var range = {
          pre: len === 1 ? value - 1 : value - 0.5,
          next: len === 1 ? value + 1 : value + 0.5
        };
        var dodgeValue = self.getDodgeOffset(range, index, count);
        obj[xField] = dodgeValue;
      }
    });
  };

  return Dodge;
}(Adjust);

Adjust.Dodge = Dodge;
module.exports = Dodge;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// 瀹屾暣鐗堜笅浣跨敤鏀寔鎸夌収鏌愪釜瀛楁杩涜鍒嗙粍鐨� dodge
var mix = __webpack_require__(10);

var Adjust = __webpack_require__(33);

var Dodge = __webpack_require__(226);

var Stack = __webpack_require__(231);

var AdjustMixin = __webpack_require__(106);

var DodgeMixin = __webpack_require__(229);

var StackMixin = __webpack_require__(230);

mix(Adjust.prototype, AdjustMixin);
mix(Dodge.prototype, AdjustMixin, DodgeMixin);
mix(Stack.prototype, StackMixin);
Adjust.Jitter = __webpack_require__(228);
Adjust.Symmetric = __webpack_require__(232);
Adjust.Dodge = Dodge;
Adjust.Stack = Stack;
module.exports = Adjust;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var each = __webpack_require__(2);

var mix = __webpack_require__(10);

var ArrayUtil = {
  merge: __webpack_require__(54)
};

var Adjust = __webpack_require__(33);

var AdjustMixin = __webpack_require__(106);

var Jitter =
/*#__PURE__*/
function (_Adjust) {
  _inheritsLoose(Jitter, _Adjust);

  function Jitter() {
    return _Adjust.apply(this, arguments) || this;
  }

  var _proto = Jitter.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    this.xField = null; // 璋冩暣瀵瑰簲鐨� x 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.yField = null; // 璋冩暣瀵瑰簲鐨� y 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.adjustNames = ['x', 'y']; // 鎸噚,y

    this.groupFields = null; // 鍙備笌鍒嗙粍鐨勬暟鎹淮搴�
  };

  _proto.processAdjust = function processAdjust(dataArray) {
    var self = this;
    var mergeData = ArrayUtil.merge(dataArray);
    self.adjDataArray = dataArray;
    self.mergeData = mergeData;
    self.adjustData(dataArray, mergeData);
    self.adjFrames = null;
    self.mergeData = null;
  };

  _proto.getAdjustOffset = function getAdjustOffset(pre, next) {
    var r = Math.random(); // 闅忔満浣嶇疆锛屽潎鍖€鍒嗗竷

    var avg = next - pre; // * length

    var append = avg * 0.05;
    return pre + append + avg * 0.9 * r;
  }; // adjust group data


  _proto._adjustGroup = function _adjustGroup(group, dim, key, values) {
    var self = this;
    var range = self.getAdjustRange(dim, key, values);
    each(group, function (record) {
      record[dim] = self.getAdjustOffset(range.pre, range.next); // 鑾峰彇璋冩暣鐨勪綅缃�
    });
  };

  _proto.adjustDim = function adjustDim(dim, values, data) {
    var self = this;
    var groupData = self.groupData(data, dim);
    each(groupData, function (group, key) {
      key = parseFloat(key);

      self._adjustGroup(group, dim, key, values);
    });
  };

  return Jitter;
}(Adjust);

mix(Jitter.prototype, AdjustMixin);
Adjust.Jitter = Jitter;
module.exports = Jitter;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var ArrayUtil = {
  merge: __webpack_require__(54),
  values: __webpack_require__(79)
};

var group = __webpack_require__(165);

var each = __webpack_require__(2);

module.exports = {
  /**
   * @protected
   * @override
   */
  processAdjust: function processAdjust(dataArray) {
    var self = this;
    var mergeData = ArrayUtil.merge(dataArray);
    var dodgeDim = self.dodgeBy;
    var adjDataArray = dataArray;

    if (dodgeDim) {
      // 濡傛灉鎸囧畾浜嗗垎缁刣im鐨勫瓧娈�
      adjDataArray = group(mergeData, dodgeDim);
    }

    self.cacheMap = {};
    self.adjDataArray = adjDataArray;
    self.mergeData = mergeData;
    self.adjustData(adjDataArray, mergeData);
    self.adjDataArray = null;
    self.mergeData = null;
  },
  getDistribution: function getDistribution(dim) {
    var self = this;
    var dataArray = self.adjDataArray;
    var cacheMap = self.cacheMap;
    var map = cacheMap[dim];

    if (!map) {
      map = {};
      each(dataArray, function (data, index) {
        var values = ArrayUtil.values(data, dim);

        if (!values.length) {
          values.push(0);
        }

        each(values, function (val) {
          if (!map[val]) {
            map[val] = [];
          }

          map[val].push(index);
        });
      });
      cacheMap[dim] = map;
    }

    return map;
  },
  adjustDim: function adjustDim(dim, values, data, frameCount, frameIndex) {
    var self = this;
    var map = self.getDistribution(dim);
    var groupData = self.groupData(data, dim); // 鏍规嵁鍊煎垎缁�

    each(groupData, function (group, key) {
      key = parseFloat(key);
      var range;

      if (values.length === 1) {
        range = {
          pre: values[0] - 1,
          next: values[0] + 1
        };
      } else {
        range = self.getAdjustRange(dim, key, values);
      }

      each(group, function (record) {
        var value = record[dim];
        var valueArr = map[value];
        var valIndex = valueArr.indexOf(frameIndex);
        record[dim] = self.getDodgeOffset(range, valIndex, valueArr.length);
      });
    });
  }
};

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = {
  _initDefaultCfg: function _initDefaultCfg() {
    this.xField = null; // 璋冩暣瀵瑰簲鐨� x 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.yField = null; // 璋冩暣瀵瑰簲鐨� y 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.height = null; // 浠呮湁涓€涓淮搴﹁皟鏁存椂锛屾€荤殑楂樺害

    this.size = 10; // 鍗曚釜鐐圭殑澶у皬

    this.reverseOrder = false; // 鏄惁鍙嶅簭杩涜灞傚彔

    this.adjustNames = ['y']; // Only support stack y
  },
  processOneDimStack: function processOneDimStack(dataArray) {
    var self = this;
    var xField = self.xField;
    var yField = self.yField || 'y';
    var height = self.height;
    var stackY = {}; // 濡傛灉灞傚彔鐨勯『搴忕炕杞�

    if (self.reverseOrder) {
      dataArray = dataArray.slice(0).reverse();
    }

    for (var i = 0, len = dataArray.length; i < len; i++) {
      var data = dataArray[i]; // cates

      for (var j = 0, dataLen = data.length; j < dataLen; j++) {
        var item = data[j];
        var size = item.size || self.size;
        var stackHeight = size * 2 / height;
        var x = item[xField];

        if (!stackY[x]) {
          stackY[x] = stackHeight / 2;
        }

        item[yField] = stackY[x];
        stackY[x] += stackHeight;
      }
    }
  },
  processAdjust: function processAdjust(dataArray) {
    if (this.yField) {
      this.processStack(dataArray);
    } else {
      this.processOneDimStack(dataArray);
    }
  }
};

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var isArray = __webpack_require__(4);

var isNil = __webpack_require__(6);

var Adjust = __webpack_require__(33);

var Stack =
/*#__PURE__*/
function (_Adjust) {
  _inheritsLoose(Stack, _Adjust);

  function Stack() {
    return _Adjust.apply(this, arguments) || this;
  }

  var _proto = Stack.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    this.xField = null; // 璋冩暣瀵瑰簲鐨� x 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.yField = null; // 璋冩暣瀵瑰簲鐨� y 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�
  };

  _proto.processAdjust = function processAdjust(dataArray) {
    this.processStack(dataArray);
  };

  _proto.processStack = function processStack(dataArray) {
    var self = this;
    var xField = self.xField;
    var yField = self.yField;
    var count = dataArray.length;
    var stackCache = {
      positive: {},
      negative: {}
    }; // 灞傚彔椤哄簭缈昏浆

    if (self.reverseOrder) {
      dataArray = dataArray.slice(0).reverse();
    }

    for (var i = 0; i < count; i++) {
      var data = dataArray[i];

      for (var j = 0, len = data.length; j < len; j++) {
        var item = data[j];
        var x = item[xField] || 0;
        var y = item[yField];
        var xkey = x.toString();
        y = isArray(y) ? y[1] : y;

        if (!isNil(y)) {
          var direction = y >= 0 ? 'positive' : 'negative';

          if (!stackCache[direction][xkey]) {
            stackCache[direction][xkey] = 0;
          }

          item[yField] = [stackCache[direction][xkey], y + stackCache[direction][xkey]];
          stackCache[direction][xkey] += y;
        }
      }
    }
  };

  return Stack;
}(Adjust);

Adjust.Stack = Stack;
module.exports = Stack;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var each = __webpack_require__(2);

var maxBy = __webpack_require__(168);

var isArray = __webpack_require__(4);

var ArrayUtil = {
  merge: __webpack_require__(54)
};

var Adjust = __webpack_require__(33);

var Symmetric =
/*#__PURE__*/
function (_Adjust) {
  _inheritsLoose(Symmetric, _Adjust);

  function Symmetric() {
    return _Adjust.apply(this, arguments) || this;
  }

  var _proto = Symmetric.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    this.xField = null; // 璋冩暣瀵瑰簲鐨� x 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.yField = null; // 璋冩暣瀵瑰簲鐨� y 鏂瑰悜瀵瑰簲鐨勫瓧娈靛悕绉�

    this.cacheMax = null; // 缂撳瓨鐨勬渶澶у€�

    this.adjustNames = ['y']; // Only support stack y

    this.groupFields = null; // 鍙備笌鍒嗙粍鐨勬暟鎹淮搴�
  }; // 鑾峰彇鏈€澶х殑y鍊�


  _proto._getMax = function _getMax(dim) {
    var self = this;
    var mergeData = self.mergeData;
    var maxRecord = maxBy(mergeData, function (obj) {
      var value = obj[dim];

      if (isArray(value)) {
        return Math.max.apply(null, value);
      }

      return value;
    });
    var maxValue = maxRecord[dim];
    var max = isArray(maxValue) ? Math.max.apply(null, maxValue) : maxValue;
    return max;
  }; // 鑾峰彇姣忎釜瀛楁鏈€澶х殑鍊�


  _proto._getXValuesMax = function _getXValuesMax() {
    var self = this;
    var yField = self.yField;
    var xField = self.xField;
    var cache = {};
    var mergeData = self.mergeData;
    each(mergeData, function (obj) {
      var xValue = obj[xField];
      var yValue = obj[yField];
      var max = isArray(yValue) ? Math.max.apply(null, yValue) : yValue;
      cache[xValue] = cache[xValue] || 0;

      if (cache[xValue] < max) {
        cache[xValue] = max;
      }
    });
    return cache;
  }; // 鍏ュ彛鍑芥暟


  _proto.processAdjust = function processAdjust(dataArray) {
    var self = this;
    var mergeData = ArrayUtil.merge(dataArray);
    self.mergeData = mergeData;

    self._processSymmetric(dataArray);

    self.mergeData = null;
  }; // 澶勭悊瀵圭О


  _proto._processSymmetric = function _processSymmetric(dataArray) {
    var self = this;
    var xField = self.xField;
    var yField = self.yField;

    var max = self._getMax(yField);

    var first = dataArray[0][0];
    var cache;

    if (first && isArray(first[yField])) {
      cache = self._getXValuesMax();
    }

    each(dataArray, function (data) {
      each(data, function (obj) {
        var value = obj[yField];
        var offset;

        if (isArray(value)) {
          var xValue = obj[xField];
          var valueMax = cache[xValue];
          offset = (max - valueMax) / 2;
          var tmp = [];
          /* eslint-disable no-loop-func */

          each(value, function (subVal) {
            // 澶氫釜瀛楁
            tmp.push(offset + subVal);
          });
          /* eslint-enable no-loop-func */

          obj[yField] = tmp;
        } else {
          offset = (max - value) / 2;
          obj[yField] = [offset, value + offset];
        }
      });
    });
  };

  return Symmetric;
}(Adjust);

Adjust.Symmetric = Symmetric;
module.exports = Symmetric;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var isString = __webpack_require__(15);

var ColorUtil = __webpack_require__(107);

var Base = __webpack_require__(34);

var Color =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Color, _Base);

  function Color(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.names = ['color'];
    _this.type = 'color';
    _this.gradient = null;

    if (isString(_this.values)) {
      _this.linear = true;
    }

    return _this;
  }
  /**
   * @override
   */


  var _proto = Color.prototype;

  _proto.getLinearValue = function getLinearValue(percent) {
    var gradient = this.gradient;

    if (!gradient) {
      var values = this.values;
      gradient = ColorUtil.gradient(values);
      this.gradient = gradient;
    }

    return gradient(percent);
  };

  return Color;
}(Base);

module.exports = Color;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(34);

var Opacity =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Opacity, _Base);

  function Opacity(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.names = ['opacity'];
    _this.type = 'opacity';
    _this.gradient = null;
    return _this;
  }

  return Opacity;
}(Base);

module.exports = Opacity;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var isNil = __webpack_require__(6);

var isArray = __webpack_require__(4);

var each = __webpack_require__(2);

var Base = __webpack_require__(34);

var Position =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Position, _Base);

  function Position(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.names = ['x', 'y'];
    _this.type = 'position';
    return _this;
  }

  var _proto = Position.prototype;

  _proto.mapping = function mapping(x, y) {
    var scales = this.scales;
    var coord = this.coord;
    var scaleX = scales[0];
    var scaleY = scales[1];
    var rstX;
    var rstY;
    var obj;

    if (isNil(x) || isNil(y)) {
      return [];
    }

    if (isArray(y) && isArray(x)) {
      rstX = [];
      rstY = [];

      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i++, j++) {
        obj = coord.convertPoint({
          x: scaleX.scale(x[i]),
          y: scaleY.scale(y[j])
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (isArray(y)) {
      x = scaleX.scale(x);
      rstY = [];
      each(y, function (yVal) {
        yVal = scaleY.scale(yVal);
        obj = coord.convertPoint({
          x: x,
          y: yVal
        });

        if (rstX && rstX !== obj.x) {
          if (!isArray(rstX)) {
            rstX = [rstX];
          }

          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }

        rstY.push(obj.y);
      });
    } else if (isArray(x)) {
      y = scaleY.scale(y);
      rstX = [];
      each(x, function (xVal) {
        xVal = scaleX.scale(xVal);
        obj = coord.convertPoint({
          x: xVal,
          y: y
        });

        if (rstY && rstY !== obj.y) {
          if (!isArray(rstY)) {
            rstY = [rstY];
          }

          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }

        rstX.push(obj.x);
      });
    } else {
      x = scaleX.scale(x);
      y = scaleY.scale(y);
      var point = coord.convertPoint({
        x: x,
        y: y
      });
      rstX = point.x;
      rstY = point.y;
    }

    return [rstX, rstY];
  };

  return Position;
}(Base);

module.exports = Position;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(34);

var Shape =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Shape, _Base);

  function Shape(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.names = ['shape'];
    _this.type = 'shape';
    _this.gradient = null;
    return _this;
  }
  /**
   * @override
   */


  var _proto = Shape.prototype;

  _proto.getLinearValue = function getLinearValue(percent) {
    var values = this.values;
    var index = Math.round((values.length - 1) * percent);
    return values[index];
  };

  return Shape;
}(Base);

module.exports = Shape;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(34);

var Size =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Size, _Base);

  function Size(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;
    _this.names = ['size'];
    _this.type = 'size';
    _this.gradient = null;
    return _this;
  }

  return Size;
}(Base);

module.exports = Size;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Base = __webpack_require__(35);

var vec2 = Util.MatrixUtil.vec2;

var Circle =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Circle, _Base);

  function Circle() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Circle.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 鍧愭爣杞寸殑绫诲瀷
       * @type {String}
       */
      type: 'circle',

      /**
       * 鎸囧畾鍒诲害涔嬮棿鐨勯棿璺�
       * @type {Number}
       */
      tickInterval: null,

      /**
       * 寮€濮嬪姬搴�
       * @type {Number}
       */
      startAngle: -Math.PI / 2,

      /**
       * 缁撴潫寮у害
       * @type {Number}
       */
      endAngle: Math.PI * 3 / 2,
      line: {
        // @type {Attrs} 鍧愭爣杞寸嚎鐨勫浘褰㈠睘鎬�,濡傛灉璁剧疆鎴恘ull锛屽垯涓嶆樉绀鸿酱绾�
        lineWidth: 1,
        stroke: '#C0D0E0'
      },
      tickLine: {
        // @type {Attrs} 鏍囨敞鍧愭爣绾跨殑鍥惧舰灞炴€�
        lineWidth: 1,
        stroke: '#C0D0E0',
        length: 5
      },

      /**
       * 榛樿鏂囨湰璺濈杞寸嚎鐨勮窛绂�
       * @type {Number}
       */
      _labelOffset: 5
    });
  };

  _proto.parseTick = function parseTick(tick, index, length) {
    return {
      text: tick,
      value: index / length
    };
  };

  _proto._getCirclePoint = function _getCirclePoint(angle, radius) {
    var self = this;
    var center = self.get('center');
    radius = radius || self.get('radius');
    return {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius
    };
  };

  _proto.getTickPoint = function getTickPoint(value) {
    var self = this;
    var startAngle = self.get('startAngle');
    var endAngle = self.get('endAngle');
    var angle = startAngle + (endAngle - startAngle) * value;
    return self._getCirclePoint(angle);
  };

  _proto.getSideVector = function getSideVector(offset, point) {
    var self = this;
    var center = self.get('center');
    var vector = [point.x - center.x, point.y - center.y];

    if (!Util.isNil(offset)) {
      var vecLen = vec2.length(vector);
      vec2.scale(vector, vector, offset / vecLen);
    }

    return vector;
  };

  _proto.getSidePoint = function getSidePoint(point, offset) {
    var self = this;
    var vector = self.getSideVector(offset, point);
    return {
      x: point.x + vector[0],
      y: point.y + vector[1]
    };
  };

  _proto.getTickEnd = function getTickEnd(start, length) {
    var self = this;
    var tickLine = self.get('tickLine');
    length = length ? length : tickLine.length;
    return self.getSidePoint(start, length);
  };

  _proto.getTextAnchor = function getTextAnchor(vector) {
    var align;

    if (Util.snapEqual(vector[0], 0)) {
      align = 'center';
    } else if (vector[0] > 0) {
      align = 'left';
    } else if (vector[0] < 0) {
      align = 'right';
    }

    return align;
  };

  _proto.getLinePath = function getLinePath() {
    var self = this;
    var center = self.get('center');
    var x = center.x;
    var y = center.y;
    var rx = self.get('radius');
    var ry = rx;
    var startAngle = self.get('startAngle');
    var endAngle = self.get('endAngle');
    var inner = self.get('inner');
    var path = [];

    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
      path = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
    } else {
      var startPoint = self._getCirclePoint(startAngle);

      var endPoint = self._getCirclePoint(endAngle);

      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;

      if (!inner) {
        path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];
      } else {
        var innerStartVector = self.getSideVector(inner * rx, startPoint);
        var innerEndVector = self.getSideVector(inner * rx, endPoint);
        var innerStartPoint = {
          x: innerStartVector[0] + x,
          y: innerStartVector[1] + y
        };
        var innerEndPoint = {
          x: innerEndVector[0] + x,
          y: innerEndVector[1] + y
        };
        path = [['M', innerStartPoint.x, innerStartPoint.y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', innerEndPoint.x, innerEndPoint.y], ['A', rx * inner, ry * inner, 0, large, Math.abs(sweep - 1), innerStartPoint.x, innerStartPoint.y]];
      }
    }

    return path;
  };

  _proto.addLabel = function addLabel(tick, point, index) {
    var self = this;
    var offset = self.get('label').offset || self.get('_labelOffset') || 0.001;
    point = self.getSidePoint(point, offset);

    _Base.prototype.addLabel.call(this, tick, point, index);
  };

  _proto.autoRotateLabels = function autoRotateLabels() {
    var self = this;
    var ticks = self.get('ticks');
    var labelRenderer = self.get('labelRenderer');

    if (labelRenderer && ticks.length > 12) {
      // 灏忎簬12涓枃鏈椂鏂囨湰涓嶆棆杞�
      var radius = self.get('radius');
      var startAngle = self.get('startAngle');
      var endAngle = self.get('endAngle');
      var totalAngle = endAngle - startAngle;
      var avgAngle = totalAngle / (ticks.length - 1);
      var avgWidth = Math.sin(avgAngle / 2) * radius * 2;
      var maxLength = self.getMaxLabelWidth(labelRenderer);
      Util.each(labelRenderer.get('group').get('children'), function (label, index) {
        var tick = ticks[index];
        var angle = tick.value * totalAngle + startAngle;
        var mode = angle % (Math.PI * 2);

        if (maxLength < avgWidth) {
          // 鏂囨湰鐨勬渶澶у搴﹀ぇ浜�
          if (mode <= 0) {
            angle = angle + Math.PI;
          }

          if (mode > Math.PI) {
            angle = angle - Math.PI;
          }

          angle = angle - Math.PI / 2;
          label.attr('textAlign', 'center');
        } else {
          if (mode > Math.PI / 2) {
            angle = angle - Math.PI;
          } else if (mode < Math.PI / 2 * -1) {
            angle = angle + Math.PI;
          }
        }

        label.rotateAtStart(angle);
      });
    }
  };

  return Circle;
}(Base);

module.exports = Circle;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Base = __webpack_require__(35);

var MatrixUtil = Util.MatrixUtil,
    PathUtil = Util.PathUtil;
var vec2 = MatrixUtil.vec2;

var Helix =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Helix, _Base);

  function Helix() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Helix.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      inner: 0,
      type: 'helix',
      line: {
        // @type {Attrs} 鍧愭爣杞寸嚎鐨勫浘褰㈠睘鎬�,濡傛灉璁剧疆鎴恘ull锛屽垯涓嶆樉绀鸿酱绾�
        lineWidth: 1,
        stroke: '#C0D0E0'
      },
      tickLine: {
        // @type {Attrs} 鏍囨敞鍧愭爣绾跨殑鍥惧舰灞炴€�
        lineWidth: 1,
        stroke: '#C0D0E0',
        length: 5
      },
      startAngle: 1.25 * Math.PI,
      endAngle: 7.25 * Math.PI,
      // 铻烘棆绯绘暟
      a: 0,
      // 鐢诲竷涓績鍧愭爣
      center: null,
      // 鍧愭爣杞寸粯鍒惰捣鐐�
      axisStart: null,
      // 鍧愭爣杞寸殑n涓潗鏍囩偣
      crp: []
    });
  };

  _proto.getLinePath = function getLinePath() {
    var self = this;
    var crp = self.get('crp');
    var axisStart = self.get('axisStart');
    var path = PathUtil.catmullRomToBezier(crp);
    path.unshift(['M', axisStart.x, axisStart.y]);
    return path;
  };

  _proto.getTickPoint = function getTickPoint(value) {
    var self = this;
    var startAngle = self.get('startAngle');
    var endAngle = self.get('endAngle');
    var angle = startAngle + (endAngle - startAngle) * value;
    return self._getHelixPoint(angle);
  };

  _proto._getHelixPoint = function _getHelixPoint(angle) {
    var self = this;
    var center = self.get('center');
    var a = self.get('a'); // 铻虹嚎绯绘暟

    var radius = a * angle + self.get('inner'); // 铻虹嚎鏂圭▼

    return {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius
    };
  };

  _proto.getSideVector = function getSideVector(offset, point) {
    var self = this;
    var center = self.get('center');
    var vector = [point.x - center.x, point.y - center.y];

    if (offset) {
      var vecLen = vec2.length(vector);
      vec2.scale(vector, vector, offset / vecLen);
    }

    return vector;
  };

  _proto.getSidePoint = function getSidePoint(point, offset) {
    var self = this;
    var vector = self.getSideVector(offset, point);
    return {
      x: point.x + vector[0],
      y: point.y + vector[1]
    };
  };

  _proto.getTickEnd = function getTickEnd(start, length) {
    var self = this;
    var tickLine = self.get('tickLine');
    length = length ? length : tickLine.length;
    return self.getSidePoint(start, length);
  };

  return Helix;
}(Base);

module.exports = Helix;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var Axis = __webpack_require__(35);

Axis.Base = Axis;
Axis.Circle = __webpack_require__(238);
Axis.Grid = __webpack_require__(108);
Axis.Helix = __webpack_require__(239);
Axis.Line = __webpack_require__(241);
Axis.Polyline = __webpack_require__(242);
module.exports = Axis;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(35);

var Util = __webpack_require__(3);

var MatrixUtil = Util.MatrixUtil;
var vec2 = MatrixUtil.vec2;

var Line =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Line, _Base);

  function Line() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Line.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      x: null,
      // @type {Number} 璺濈鍒濆浣嶇疆鐨剎杞村亸绉婚噺,浠呭浜庡乏渚с€佸彸渚х殑绾靛悜鍧愭爣鏈夋晥
      y: null,
      // @type {Number} 璺濈鍒濆浣嶇疆鐨剏杞村亸绉婚噺锛屼粎瀵归《閮ㄣ€佸簳閮ㄧ殑妯悜鍧愭爣杞存湁鏁�
      line: {
        // @type {Attrs} 鍧愭爣杞寸嚎鐨勫浘褰㈠睘鎬�,濡傛灉璁剧疆鎴恘ull锛屽垯涓嶆樉绀鸿酱绾�
        lineWidth: 1,
        stroke: '#C0D0E0'
      },
      tickLine: {
        // @type {Attrs} 鏍囨敞鍧愭爣绾跨殑鍥惧舰灞炴€�
        lineWidth: 1,
        stroke: '#C0D0E0',
        length: 5
      },
      isVertical: false,
      start: null,
      // @type {Object} 璧风偣
      end: null // @type {Object} 缁堢偣

    });
  };

  _proto._getAvgLabelLength = function _getAvgLabelLength(labelRenderer) {
    var labels = labelRenderer.get('group').get('children');
    return labels[1].attr('x') - labels[0].attr('x');
  };

  _proto._getAvgLabelHeightSpace = function _getAvgLabelHeightSpace(labelRenderer) {
    var labels = labelRenderer.get('group').get('children');
    return labels[1].attr('y') - labels[0].attr('y');
  }
  /**
   * 鑾峰彇璺濈鍧愭爣杞寸殑鍚戦噺
   * @override
   * @param  {Number} offset 鍋忕Щ鍊�
   * @return {Array}        杩斿洖浜岀淮鍚戦噺
   */
  ;

  _proto.getSideVector = function getSideVector(offset) {
    var self = this;
    var isVertical = self.get('isVertical');
    var factor = self.get('factor'); // if (Util.isArray(offset)) {
    //   return offset.map(value => value * factor);
    // }

    if (!Util.isNumber(offset)) {
      return [0, 0];
    }

    var start = self.get('start');
    var end = self.get('end');
    var axisVector = self.getAxisVector();
    var normal = vec2.normalize([], axisVector);
    var direction = false;

    if (isVertical && start.y < end.y || !isVertical && start.x > end.x) {
      direction = true;
    }

    var verticalVector = vec2.vertical([], normal, direction);
    return vec2.scale([], verticalVector, offset * factor);
  };

  _proto.getAxisVector = function getAxisVector() {
    var start = this.get('start');
    var end = this.get('end');
    return [end.x - start.x, end.y - start.y];
  };

  _proto.getLinePath = function getLinePath() {
    var self = this;
    var start = self.get('start');
    var end = self.get('end');
    var path = [];
    path.push(['M', start.x, start.y]);
    path.push(['L', end.x, end.y]);
    return path;
  };

  _proto.getTickEnd = function getTickEnd(start, value) {
    var self = this;
    var offsetVector = self.getSideVector(value);
    return {
      x: start.x + offsetVector[0],
      y: start.y + offsetVector[1]
    };
  };

  _proto.getTickPoint = function getTickPoint(tickValue) {
    var self = this;
    var start = self.get('start');
    var end = self.get('end');
    var rangeX = end.x - start.x;
    var rangeY = end.y - start.y;
    return {
      x: start.x + rangeX * tickValue,
      y: start.y + rangeY * tickValue
    };
  };

  _proto.renderTitle = function renderTitle() {
    var self = this;
    var title = self.get('title');
    var offsetPoint = self.getTickPoint(0.5);
    var titleOffset = title.offset;

    if (Util.isNil(titleOffset)) {
      // 娌℃湁鎸囧畾 offset 鍒欒嚜鍔ㄨ绠�
      titleOffset = 20;
      var labelsGroup = self.get('labelsGroup');

      if (labelsGroup) {
        var labelLength = self.getMaxLabelWidth(labelsGroup);
        var labelOffset = self.get('label').offset || self.get('_labelOffset');
        titleOffset += labelLength + labelOffset;
      }
    }

    var textStyle = title.textStyle;
    var cfg = Util.mix({}, textStyle);

    if (title.text) {
      var vector = self.getAxisVector(); // 鍧愭爣杞存柟鍚戠殑鍚戦噺

      if (title.autoRotate && Util.isNil(textStyle.rotate)) {
        // 鑷姩鏃嬭浆骞朵笖鐢ㄦ埛娌℃湁鎸囧畾鏍囬鐨勬棆杞搴�
        var angle = 0;

        if (!Util.snapEqual(vector[1], 0)) {
          // 鎵€鏈夋按骞冲潗鏍囪酱锛屾枃鏈笉杞疆
          var v1 = [1, 0];
          var v2 = [vector[0], vector[1]];
          angle = vec2.angleTo(v2, v1, true);
        }

        cfg.rotate = angle * (180 / Math.PI);
      } else if (!Util.isNil(textStyle.rotate)) {
        // 鐢ㄦ埛璁剧疆浜嗘棆杞搴﹀氨浠ョ敤鎴疯缃殑涓哄噯
        cfg.rotate = textStyle.rotate / 180 * Math.PI; // 灏嗚搴﹁浆鎹负寮у害
      }

      var sideVector = self.getSideVector(titleOffset);
      var point;
      var position = title.position;

      if (position === 'start') {
        point = {
          x: this.get('start').x + sideVector[0],
          y: this.get('start').y + sideVector[1]
        };
      } else if (position === 'end') {
        point = {
          x: this.get('end').x + sideVector[0],
          y: this.get('end').y + sideVector[1]
        };
      } else {
        point = {
          x: offsetPoint.x + sideVector[0],
          y: offsetPoint.y + sideVector[1]
        };
      }

      cfg.x = point.x;
      cfg.y = point.y;
      cfg.text = title.text;
      var group = self.get('group');
      var titleShape = group.addShape('Text', {
        zIndex: 2,
        attrs: cfg
      });
      titleShape.name = 'axis-title';
      self.get('appendInfo') && titleShape.setSilent('appendInfo', self.get('appendInfo'));
    }
  };

  _proto.autoRotateLabels = function autoRotateLabels() {
    var self = this;
    var labelRenderer = self.get('labelRenderer');
    var title = self.get('title');

    if (labelRenderer) {
      var labelGroup = labelRenderer.get('group');
      var labels = labelGroup.get('children');
      var offset = self.get('label').offset;
      var append = 12;
      var titleOffset = title ? title.offset : 48;

      if (titleOffset < 0) {
        // 濡傛灉鏄礋鐨勭殑璇濆氨涓嶆棆杞�
        return;
      }

      var vector = self.getAxisVector(); // 鍧愭爣杞寸殑鍚戦噺锛屼粎澶勭悊姘村钩鎴栬€呭瀭鐩寸殑鍦烘櫙

      var angle;
      var maxWidth;

      if (Util.snapEqual(vector[0], 0) && title && title.text) {
        // 鍧愭爣杞村瀭鐩达紝鐢变簬涓嶇煡閬撹竟璺濓紝鍙兘闃叉璺焧itle閲嶅悎锛屽鏋渢itle涓嶅瓨鍦紝鍒欎笉鑷姩鏃嬭浆
        maxWidth = self.getMaxLabelWidth(labelRenderer);

        if (maxWidth > titleOffset - offset - append) {
          angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;
        }
      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {
        // 鍧愭爣杞存按骞筹紝涓嶈€冭檻杈硅窛锛屾牴鎹渶闀跨殑鍜屽钩鍧囧€艰繘琛岀炕杞�
        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));
        maxWidth = self.getMaxLabelWidth(labelRenderer);

        if (maxWidth > avgWidth) {
          angle = Math.asin((titleOffset - offset - append) * 1.25 / maxWidth);
        }
      }

      if (angle) {
        var factor = self.get('factor');
        Util.each(labels, function (label) {
          label.rotateAtStart(angle);

          if (Util.snapEqual(vector[1], 0)) {
            if (factor > 0) {
              label.attr('textAlign', 'left');
            } else {
              label.attr('textAlign', 'right');
            }
          }
        });
      }
    }
  };

  _proto.autoHideLabels = function autoHideLabels() {
    var self = this;
    var labelRenderer = self.get('labelRenderer');
    var labelSpace;
    var tickStep;
    var append = 8;

    if (labelRenderer) {
      var labelGroup = labelRenderer.get('group');
      var labels = labelGroup.get('children');
      var vector = self.getAxisVector(); // 鍧愭爣杞寸殑鍚戦噺锛屼粎澶勭悊姘村钩鎴栬€呭瀭鐩寸殑鍦烘櫙

      if (labels.length < 2) {
        return;
      }

      if (Util.snapEqual(vector[0], 0)) {
        // 鍧愭爣杞村瀭鐩�
        var maxHeight = self.getMaxLabelHeight(labelRenderer) + append;
        var avgHeight = Math.abs(self._getAvgLabelHeightSpace(labelRenderer));

        if (maxHeight > avgHeight) {
          labelSpace = maxHeight;
          tickStep = avgHeight;
        }
      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {
        // 鍧愭爣杞存按骞�
        var maxWidth = self.getMaxLabelWidth(labelRenderer) + append;
        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));

        if (maxWidth > avgWidth) {
          labelSpace = maxWidth;
          tickStep = avgWidth;
        }
      }

      if (labelSpace && tickStep) {
        var ratio = Math.ceil(labelSpace / tickStep);
        Util.each(labels, function (label, i) {
          if (i % ratio !== 0) {
            label.attr('text', '');
          }
        });
      }
    }
  };

  return Line;
}(Base);

module.exports = Line;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Base = __webpack_require__(35);

var MatrixUtil = Util.MatrixUtil,
    PathUtil = Util.PathUtil;
var vec2 = MatrixUtil.vec2;

var Polyline =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Polyline, _Base);

  function Polyline() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Polyline.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      type: 'polyline'
    });
  };

  _proto.getLinePath = function getLinePath() {
    var self = this;
    var tickPoints = self.get('tickPoints');
    var start = self.get('start');
    var end = self.get('end');
    var points = [];
    points.push(start.x);
    points.push(start.y);
    Util.each(tickPoints, function (tick) {
      points.push(tick.x);
      points.push(tick.y);
    });
    points.push(end.x);
    points.push(end.y);
    var path = PathUtil.catmullRomToBezier(points);
    path.unshift(['M', start.x, start.y]);
    return path;
  };

  _proto.getTickPoint = function getTickPoint(value, index) {
    var tickPoints = this.get('tickPoints');
    return tickPoints[index];
  };

  _proto.getTickEnd = function getTickEnd(start, value, index) {
    var self = this;
    var lineAttrs = self.get('tickLine');
    var tickLength = value ? value : lineAttrs.length;
    var offsetVector = self.getSideVector(tickLength, start, index);
    return {
      x: start.x + offsetVector[0],
      y: start.y + offsetVector[1]
    };
  };

  _proto.getSideVector = function getSideVector(offset, point, index) {
    var self = this;
    var preTickPoint;

    if (index === 0) {
      preTickPoint = self.get('start');

      if (preTickPoint.x === point.x && preTickPoint.y === point.y) {
        return [0, 0];
      }
    } else {
      var tickPoints = self.get('tickPoints');
      preTickPoint = tickPoints[index - 1];
    }

    var vector = [point.x - preTickPoint.x, point.y - preTickPoint.y];
    var normal = vec2.normalize([], vector);
    var verticalVector = vec2.vertical([], normal, false);
    return vec2.scale([], verticalVector, offset);
  };

  return Polyline;
}(Base);

module.exports = Polyline;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var PI = Math.PI;
var atan = Math.atan;

function calculateAngle(point, center) {
  var x = point.x - center.x;
  var y = point.y - center.y;
  var deg;

  if (y === 0) {
    if (x < 0) {
      deg = PI / 2;
    } else {
      deg = 270 * PI / 180;
    }
  } else if (x >= 0 && y > 0) {
    deg = PI * 2 - atan(x / y);
  } else if (x <= 0 && y < 0) {
    deg = PI - atan(x / y);
  } else if (x > 0 && y < 0) {
    deg = PI + atan(-x / y);
  } else if (x < 0 && y > 0) {
    deg = atan(x / -y);
  }

  return deg;
}

var Arc =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Arc, _Guide);

  function Arc() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Arc.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 杈呭姪鍏冪礌绫诲瀷
       * @type {String}
       */
      name: 'arc',

      /**
       * 杈呭姪寮х嚎鐨勮捣濮嬬偣
       * @type {Object | Function | Array}
       */
      start: null,

      /**
       * 杈呭姪寮х嚎鐨勭粓姝㈢偣
       * @type {Object | Function | Array}
       */
      end: null,

      /**
       * 杈呭姪鏂囨湰鐨勬牱寮忛厤缃�
       * @type {Object}
       */
      style: {
        stroke: '#999',
        lineWidth: 1
      }
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var start = self.parsePoint(coord, self.get('start'));
    var end = self.parsePoint(coord, self.get('end')); // 鍙鏈変竴涓偣鏃犳剰涔夛紝鍒欎笉缁樺埗

    if (!start || !end) {
      return;
    }

    var coordCenter = coord.getCenter();
    var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));
    var path; // 澶勭悊鏁村渾鐨勬儏鍐�

    var startAngle = calculateAngle(start, coordCenter);
    var endAngle = calculateAngle(end, coordCenter);

    if (endAngle < startAngle) {
      endAngle += PI * 2;
    }

    if (Util.isNumberEqual(start.x, end.x) && Util.isNumberEqual(start.y, end.y) && (self.get('start')[0] !== self.get('end')[0] || self.get('start')[1] !== self.get('end')[1])) {
      path = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, 2 * coordCenter.x - start.x, 2 * coordCenter.y - start.y], ['A', radius, radius, 0, 1, 1, start.x, start.y]];
    } else {
      var dAngle = (endAngle - startAngle) % (PI * 2);
      var largeArc = dAngle > PI ? 1 : 0;
      path = [['M', start.x, start.y], ['A', radius, radius, 0, largeArc, 1, end.x, end.y]];
    }

    var arcShape = group.addShape('path', {
      zIndex: self.get('zIndex'),
      attrs: Util.mix({
        path: path
      }, self.get('style'))
    });
    arcShape.name = 'guide-arc';
    self.get('appendInfo') && arcShape.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', arcShape);
  };

  return Arc;
}(Guide);

module.exports = Arc;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var DataMarker =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(DataMarker, _Guide);

  function DataMarker() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = DataMarker.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'dataMarker',
      zIndex: 1,
      top: true,
      position: null,
      style: {
        point: {
          r: 3,
          fill: '#FFFFFF',
          stroke: '#1890FF',
          lineWidth: 2
        },
        line: {
          stroke: '#A3B1BF',
          lineWidth: 1
        },
        text: {
          fill: '#000000',
          opacity: 0.65,
          fontSize: 12,
          textAlign: 'start'
        }
      },
      // end of style
      display: {
        point: true,
        line: true,
        text: true
      },
      lineLength: 20,
      direction: 'upward',
      autoAdjust: true
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var point = self.parsePoint(coord, self.get('position'));

    if (!point) {
      return;
    } // container


    var markerGroup = group.addGroup();
    markerGroup.name = 'guide-data-marker'; // markerGroup.translate(point.x, point.y);

    var positions = self._getElementPosition(point);

    var display = self.get('display');
    var lineShape;
    var textShape; // add line

    if (display.line) {
      var lineData = positions.line;
      lineShape = self._drawLine(lineData, markerGroup);
    } // add text


    if (display.text && self.get('content')) {
      var textPosition = positions.text;
      textShape = self._drawText(textPosition, markerGroup);
    } // add circle


    if (display.point) {
      var pointPoisition = positions.point;

      self._drawPoint(pointPoisition, markerGroup);
    }

    if (self.get('autoAdjust')) {
      var bbox = markerGroup.getBBox();
      var minX = bbox.minX,
          minY = bbox.minY,
          maxX = bbox.maxX,
          maxY = bbox.maxY;
      var start = coord.start,
          end = coord.end;

      if (textShape) {
        if (minX <= start.x) {
          // 宸︿晶瓒呭嚭
          textShape.attr('textAlign', 'start');
        }

        if (maxX >= end.x) {
          // 鍙充晶瓒呭嚭
          textShape.attr('textAlign', 'end');
        }

        var direction = self.get('direction');

        if (direction === 'upward' && minY <= end.y || direction !== 'upward' && maxY >= start.y) {
          // 涓婃柟鎴栬€呬笅鏂硅秴鍑�
          var textBaseline;
          var dir;

          if (direction === 'upward' && minY <= end.y) {
            textBaseline = 'top';
            dir = 1;
          } else {
            textBaseline = 'bottom';
            dir = -1;
          }

          textShape.attr('textBaseline', textBaseline);
          var lineLength = 0;

          if (self.get('display').line) {
            lineLength = self.get('lineLength');
            var linePath = [['M', point.x, point.y], ['L', point.x, point.y + lineLength * dir]];
            lineShape.attr('path', linePath);
          }

          var newY = point.y + (lineLength + 2) * dir;
          textShape.attr('y', newY);
        }
      }
    }

    self.get('appendInfo') && markerGroup.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', markerGroup);
  };

  _proto._getElementPosition = function _getElementPosition(position) {
    var self = this;
    var x = position.x,
        y = position.y;
    var lineLength = self.get('display').line ? self.get('lineLength') : 0;
    var direction = self.get('direction');
    var textStyle = self.get('style').text;
    textStyle.textBaseline = direction === 'upward' ? 'bottom' : 'top';
    var dir = direction === 'upward' ? -1 : 1;
    var pointPoisition = {
      x: x,
      y: y
    };
    var lineStart = {
      x: x,
      y: y
    };
    var lineEnd = {
      x: x,
      y: lineLength * dir + y
    };
    var textPosition = {
      x: x,
      y: (lineLength + 2) * dir + y
    };
    return {
      point: pointPoisition,
      line: [lineStart, lineEnd],
      text: textPosition
    };
  };

  _proto._drawLine = function _drawLine(lineData, g) {
    var self = this;
    var lineStyle = self.get('style').line;
    var linePath = [['M', lineData[0].x, lineData[0].y], ['L', lineData[1].x, lineData[1].y]];
    var lineShape = g.addShape('path', {
      attrs: Util.mix({
        path: linePath
      }, lineStyle)
    });
    return lineShape;
  };

  _proto._drawText = function _drawText(position, g) {
    var self = this;
    var textStyle = this.get('style').text;
    var textShape = g.addShape('text', {
      attrs: Util.mix({
        text: self.get('content')
      }, textStyle, position)
    });
    return textShape;
  };

  _proto._drawPoint = function _drawPoint(position, g) {
    var self = this;
    var pointStyle = self.get('style').point;
    var pointShape = g.addShape('circle', {
      attrs: Util.mix({}, pointStyle, position)
    });
    return pointShape;
  };

  return DataMarker;
}(Guide);

module.exports = DataMarker;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Helper = __webpack_require__(109);

var Guide = __webpack_require__(20);

var DataRegion =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(DataRegion, _Guide);

  function DataRegion() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = DataRegion.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'dataRegion',
      start: null,
      // 鍙敮鎸佹暟鍊�
      end: null,
      // 鍙敮鎸佹暟鍊�
      content: '',
      // 鏂囨湰鍐呭
      style: {
        region: {
          lineWidth: 0,
          fill: '#000000',
          opacity: 0.04
        },
        text: {
          textAlign: 'center',
          textBaseline: 'bottom',
          fontSize: 12,
          fill: 'rgba(0, 0, 0, .65)'
        }
      }
    });
  };

  _proto.render = function render(coord, group, data) {
    var self = this; // draw region

    var lineLength = self.get('lineLength') || 0; // TODO: 濡備綍鍛藉悕

    var regionData = self._getRegionData(coord, data);

    if (!regionData.length) return;

    var regionBBox = self._getBBox(regionData);

    var path = [];
    path.push(['M', regionData[0].x, regionBBox.yMin - lineLength]);

    for (var i = 0, len = regionData.length; i < len; i++) {
      var p = ['L', regionData[i].x, regionData[i].y];
      path.push(p);
    }

    path.push(['L', regionData[regionData.length - 1].x, regionBBox.yMin - lineLength]); // draw

    var style = self.get('style');
    var regionStyle = style.region; // 鍏煎涔嬪墠鐨勫啓娉�

    var textStyle = style.text;
    var regionGroup = group.addGroup();
    regionGroup.name = 'guide-data-region';
    regionGroup.addShape('path', {
      attrs: Util.mix({
        path: path
      }, regionStyle)
    });
    var content = self.get('content');

    if (content) {
      regionGroup.addShape('Text', {
        attrs: Util.mix({
          x: (regionBBox.xMin + regionBBox.xMax) / 2,
          y: regionBBox.yMin - lineLength,
          text: content
        }, textStyle)
      });
    }

    self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', regionGroup);
  };

  _proto._getRegionData = function _getRegionData(coord, data) {
    var self = this;
    var start = self.get('start');
    var end = self.get('end');
    var xField = Helper.getFirstScale(self.get('xScales')).field;
    var yField = Helper.getFirstScale(self.get('yScales')).field;
    var startXValue = Util.isArray(start) ? start[0] : start[xField];
    var endXValue = Util.isArray(end) ? end[0] : end[xField];
    var startIndex;
    var arr = [];

    for (var i = 0, len = data.length; i < len; i++) {
      var item = data[i];

      if (item[xField] === startXValue) {
        startIndex = i;
      }

      if (i >= startIndex) {
        var point = self.parsePoint(coord, [item[xField], item[yField]]); // 鍒ゆ柇鏄惁鏄湁鏁堢偣

        point && arr.push(point);
      }

      if (item[xField] === endXValue) {
        break;
      }
    }

    return arr;
  };

  _proto._getBBox = function _getBBox(data) {
    var xs = [];
    var ys = [];

    for (var i = 0; i < data.length; i++) {
      xs.push(data[i].x);
      ys.push(data[i].y);
    }

    var xRange = Util.arrayUtil.getRange(xs);
    var yRange = Util.arrayUtil.getRange(ys);
    return {
      xMin: xRange.min,
      xMax: xRange.max,
      yMin: yRange.min,
      yMax: yRange.max
    };
  };

  return DataRegion;
}(Guide);

module.exports = DataRegion;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var DomUtil = Util.DomUtil;

var Guide = __webpack_require__(20);

var Html =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Html, _Guide);

  function Html() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Html.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'html',
      zIndex: 7,
      position: null,

      /**
       * Horizontal alignment, can be 'left'銆�'middle'銆�'right'
       * @type {String}
       */
      alignX: 'middle',

      /**
       * vertical alignment, can be 'top'銆�'middle'銆�'bottom'
       * @type {String}
       */
      alignY: 'middle',

      /**
       * Horizontal offset
       * @type {Number}
       */
      offsetX: null,

      /**
       * Vertical offset
       * @type {Number}
       */
      offsetY: null,

      /**
      * html content
      *@type {String | Function}
      */
      html: null
    });
  }
  /**
   * render Html Guide
   * @override
   * @param {Coordinate} coord the instance of Coordinate class
   * @param {Container} container the container which contain the guide component
   */
  ;

  _proto.render = function render(coord, container) {
    var self = this;
    var position = self.parsePoint(coord, self.get('position'));

    if (!position) {
      return;
    }

    var parentNode = container.get('canvas').get('el').parentNode;
    var wrapperNode = DomUtil.createDom('<div class="g-guide"></div>');
    parentNode.appendChild(wrapperNode);
    var html = self.get('htmlContent') || self.get('html');

    if (Util.isFunction(html)) {
      var xScales = self.get('xScales');
      var yScales = self.get('yScales');
      html = html(xScales, yScales);
    }

    var htmlNode = DomUtil.createDom(html);
    wrapperNode.appendChild(htmlNode);
    DomUtil.modifyCSS(wrapperNode, {
      position: 'absolute' // to fix dom in the document stream to get the true width

    });

    self._setDomPosition(wrapperNode, htmlNode, position);

    self.set('el', wrapperNode);
  };

  _proto._setDomPosition = function _setDomPosition(parentDom, childDom, point) {
    var self = this;
    var alignX = self.get('alignX');
    var alignY = self.get('alignY');
    var domWidth = DomUtil.getOuterWidth(childDom);
    var domHeight = DomUtil.getOuterHeight(childDom);
    var position = {
      x: point.x,
      y: point.y
    };

    if (alignX === 'middle' && alignY === 'top') {
      position.x -= Math.round(domWidth / 2);
    } else if (alignX === 'middle' && alignY === 'bottom') {
      position.x -= Math.round(domWidth / 2);
      position.y -= Math.round(domHeight);
    } else if (alignX === 'left' && alignY === 'bottom') {
      position.y -= Math.round(domHeight);
    } else if (alignX === 'left' && alignY === 'middle') {
      position.y -= Math.round(domHeight / 2);
    } else if (alignX === 'left' && alignY === 'top') {
      position.x = point.x;
      position.y = point.y;
    } else if (alignX === 'right' && alignY === 'bottom') {
      position.x -= Math.round(domWidth);
      position.y -= Math.round(domHeight);
    } else if (alignX === 'right' && alignY === 'middle') {
      position.x -= Math.round(domWidth);
      position.y -= Math.round(domHeight / 2);
    } else if (alignX === 'right' && alignY === 'top') {
      position.x -= Math.round(domWidth);
    } else {
      // 榛樿浣嶄簬涓績鐐�
      position.x -= Math.round(domWidth / 2);
      position.y -= Math.round(domHeight / 2);
    }

    var offsetX = self.get('offsetX');

    if (offsetX) {
      position.x += offsetX;
    }

    var offsetY = self.get('offsetY');

    if (offsetY) {
      position.y += offsetY;
    }

    DomUtil.modifyCSS(parentDom, {
      top: Math.round(position.y) + 'px',
      left: Math.round(position.x) + 'px',
      visibility: 'visible',
      zIndex: self.get('zIndex')
    });
  }
  /**
   * clear html guide
   * @override
   */
  ;

  _proto.clear = function clear() {
    var self = this;
    var el = self.get('el');
    el && el.parentNode && el.parentNode.removeChild(el);
  };

  return Html;
}(Guide);

module.exports = Html;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var Image =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Image, _Guide);

  function Image() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Image.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      type: 'image',

      /**
       * the start of image
       * @type {Object | Function | Array}
       */
      start: null,

      /**
       * the end of image
       * @type {Object | Function | Array}
       */
      end: null,

      /**
       * image url
       * @type {String}
       */
      src: null,

      /**
       * Horizontal offset
       * @type {Number}
       */
      offsetX: null,

      /**
       * Vertical offset
       * @type {Number}
       */
      offsetY: null
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var start = self.parsePoint(coord, self.get('start'));

    if (!start) {
      return;
    }

    var cfg = {
      x: start.x,
      y: start.y
    };
    cfg.img = self.get('src');

    if (!self.get('end')) {
      // 濡傛灉鍜╂湁鎸囧畾缁撴潫鐐癸紝鍒� start 涓哄浘鐗囩殑宸︿笂瑙掑潗鏍�
      cfg.width = self.get('width') || 32;
      cfg.height = self.get('height') || 32;
    } else {
      var end = self.parsePoint(coord, self.get('end'));

      if (!end) {
        return;
      } // cfg.width = Math.abs(end.x - start.x);
      // cfg.height = Math.abs(end.y - start.y);


      cfg.width = end.x - start.x;
      cfg.height = end.y - start.y;
    }

    if (self.get('offsetX')) {
      cfg.x += self.get('offsetX');
    }

    if (self.get('offsetY')) {
      cfg.y += self.get('offsetY');
    }

    var imgGuide = group.addShape('Image', {
      zIndex: 1,
      attrs: cfg
    });
    imgGuide.name = 'guide-image';
    self.get('appendInfo') && imgGuide.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', imgGuide);
  };

  return Image;
}(Guide);

module.exports = Image;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  Guide: __webpack_require__(20),
  Arc: __webpack_require__(243),
  DataMarker: __webpack_require__(244),
  DataRegion: __webpack_require__(245),
  Html: __webpack_require__(246),
  Image: __webpack_require__(247),
  Line: __webpack_require__(249),
  Region: __webpack_require__(250),
  Text: __webpack_require__(251)
};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var vec2 = Util.MatrixUtil.vec2;

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var Line =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Line, _Guide);

  function Line() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Line.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 杈呭姪鍏冪礌绫诲瀷
       * @type {String}
       */
      name: 'line',

      /**
       * 杈呭姪绾跨殑璧风偣浣嶇疆
       * @type {Object | Function | Array}
       */
      start: null,

      /**
       * 杈呭姪绾跨殑缁堢偣浣嶇疆
       * @type {Object | Function | Array}
       */
      end: null,

      /**
       * 杈呭姪绾跨殑鍥惧舰鏍峰紡
       * @type {Object}
       */
      lineStyle: {
        stroke: '#000',
        lineWidth: 1
      },

      /**
       * 杈呭姪鏂囨湰閰嶇疆
       * @type {Object}
       */
      text: {
        position: 'end',
        // 鏂囨湰鐨勬樉绀轰綅缃細 start / center / end / 鐧惧垎姣�
        autoRotate: true,
        // 鏂囨湰鏄惁娌跨潃杈呭姪绾跨殑鏂瑰悜鑷姩鏃嬭浆
        style: {
          fill: '#999',
          fontSize: 12,
          fontWeight: 500,
          fontFamily: FONT_FAMILY
        },
        // 杈呭姪鏂囨湰鐨勬牱寮�
        content: null // 杈呭姪鏂囨湰鐨勬枃瀛�

      }
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var start = self.parsePoint(coord, self.get('start'));
    var end = self.parsePoint(coord, self.get('end'));

    if (!start || !end) {
      return;
    }

    var guideLineGroup = group.addGroup({
      viewId: group.get('viewId')
    });

    self._drawLines(start, end, guideLineGroup);

    var text = self.get('text');

    if (text && text.content) {
      self._drawText(start, end, guideLineGroup);
    }

    self.set('el', guideLineGroup);
  };

  _proto._drawLines = function _drawLines(start, end, group) {
    var path = [['M', start.x, start.y], ['L', end.x, end.y]];
    var guideLine = group.addShape('Path', {
      attrs: Util.mix({
        path: path
      }, this.get('lineStyle'))
    });
    guideLine.name = 'guide-line';
    this.get('appendInfo') && guideLine.setSilent('appendInfo', this.get('appendInfo'));
  };

  _proto._drawText = function _drawText(start, end, group) {
    var textCfg = this.get('text');
    var position = textCfg.position;
    var textStyle = textCfg.style || {};
    var percent;

    if (position === 'start') {
      percent = 0;
    } else if (position === 'center') {
      percent = 0.5;
    } else if (Util.isString(position) && position.indexOf('%') !== -1) {
      percent = parseInt(position, 10) / 100;
    } else if (Util.isNumber(position)) {
      percent = position;
    } else {
      percent = 1;
    }

    if (percent > 1 || percent < 0) {
      percent = 1;
    }

    var cfg = {
      x: start.x + (end.x - start.x) * percent,
      y: start.y + (end.y - start.y) * percent
    };

    if (textCfg.offsetX) {
      // 璁剧疆浜嗗亸绉婚噺
      cfg.x += textCfg.offsetX;
    }

    if (textCfg.offsetY) {
      // 璁剧疆浜嗗亸绉婚噺
      cfg.y += textCfg.offsetY;
    }

    cfg.text = textCfg.content;
    cfg = Util.mix({}, cfg, textStyle);

    if (textCfg.autoRotate && Util.isNil(textStyle.rotate)) {
      // 鑷姩鏃嬭浆涓旂敤鎴锋病鏈夎缃棆杞搴�
      var angle = vec2.angleTo([end.x - start.x, end.y - start.y], [1, 0], 1);
      cfg.rotate = angle;
    } else if (!Util.isNil(textStyle.rotate)) {
      // 鐢ㄦ埛璁剧疆浜嗘棆杞搴�
      cfg.rotate = textStyle.rotate * Math.PI / 180;
    }

    var shape = group.addShape('Text', {
      attrs: cfg
    });
    shape.name = 'guide-line-text';
    this.get('appendInfo') && shape.setSilent('appendInfo', this.get('appendInfo'));
  };

  return Line;
}(Guide);

module.exports = Line;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var Region =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Region, _Guide);

  function Region() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Region.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'region',
      zIndex: 1,
      start: null,
      end: null,
      style: {
        lineWidth: 0,
        fill: '#CCD7EB',
        opacity: 0.4
      }
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var rectStyle = self.get('style');

    var path = self._getPath(coord);

    if (!path.length) {
      // path 涓虹┖鏃朵笉缁樺埗
      return;
    }

    var regionGroup = group.addShape('path', {
      zIndex: self.get('zIndex'),
      attrs: Util.mix({
        path: path
      }, rectStyle)
    });
    regionGroup.name = 'guide-region';
    self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', regionGroup);
  };

  _proto._getPath = function _getPath(coord) {
    var self = this;
    var start = self.parsePoint(coord, self.get('start'));
    var end = self.parsePoint(coord, self.get('end'));

    if (!start || !end) {
      return [];
    }

    var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];
    return path;
  };

  return Region;
}(Guide);

module.exports = Region;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var Guide = __webpack_require__(20);

var Text =
/*#__PURE__*/
function (_Guide) {
  _inheritsLoose(Text, _Guide);

  function Text() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = Text.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 杈呭姪鍏冪礌绫诲瀷
       * @type {String}
       */
      name: 'text',

      /**
       * 杈呭姪鏂囨湰鐨勪綅缃�
       * @type {Object | Function | Array}
       */
      position: null,

      /**
       * 杈呭姪鏂囨湰鐨勬樉绀烘枃瀛�
       * @type {String}
       */
      content: null,

      /**
       * 杈呭姪鏂囨湰鐨勬牱寮忛厤缃�
       * @type {Object}
       */
      style: {
        fill: '#999',
        fontSize: 12,
        fontWeight: 500,
        textAlign: 'center'
      },

      /**
       * x 鏂瑰悜鐨勫亸绉婚噺
       * @type {Number}
       */
      offsetX: null,

      /**
       * y 鏂瑰悜鐨勫亸绉婚噺
       * @type {Number}
       */
      offsetY: null,
      top: true
    });
  };

  _proto.render = function render(coord, group) {
    var self = this;
    var point = self.parsePoint(coord, self.get('position'));

    if (!point) {
      return;
    }

    var textStyle = Util.mix({}, self.get('style'));
    var offsetX = self.get('offsetX');
    var offsetY = self.get('offsetY');

    if (offsetX) {
      point.x += offsetX;
    }

    if (offsetY) {
      point.y += offsetY;
    }

    if (textStyle.rotate) {
      textStyle.rotate = textStyle.rotate * Math.PI / 180; // 灏嗚搴﹁浆鎹负寮у害
    }

    var guideText = group.addShape('Text', {
      zIndex: self.get('zIndex'),
      attrs: Util.mix({
        text: self.get('content')
      }, textStyle, point)
    });
    guideText.name = 'guide-text';
    self.get('appendInfo') && guideText.setSilent('appendInfo', self.get('appendInfo'));
    self.set('el', guideText);
  };

  return Text;
}(Guide);

module.exports = Text;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var Label = __webpack_require__(110);

module.exports = Label;

/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = function bboxAdjust(labels, shapes) {
  var labelBBox, shapeBBox;
  var toBeRemoved = [];

  for (var i = 0; i < labels.length; i++) {
    labelBBox = labels[i].getBBox();
    shapeBBox = shapes[i].getBBox();

    if (labelBBox.width > shapeBBox.width || labelBBox.height > shapeBBox.height) {
      toBeRemoved.push(labels[i]);
    } else if (labelBBox.width * labelBBox.height > shapeBBox.width * shapeBBox.height) {
      toBeRemoved.push(labels[i]);
    }
  }

  for (var _i = 0; _i < toBeRemoved.length; _i++) {
    toBeRemoved[_i].remove();
  }
};

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var Greedy = __webpack_require__(111);
/*
   *  鏍规嵁濡備笅瑙勫垯灏濊瘯鏀剧疆label
   *                5
   *        ------------------
   *        |    1   |   0   |
   *    8   鈥斺€斺€斺€斺€斺€斺€斺€斺€�4鈥斺€斺€斺€斺€斺€斺€斺€�   7
   *        |    2   |   3   |
   *        鈥斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€斺€�
   *                 6
   */


function adjustLabelPosition(label, x, y, index) {
  var bbox = label.getBBox();
  var width = bbox.width;
  var height = bbox.height;
  var attrs = {
    x: x,
    y: y,
    textAlign: 'center'
  };

  switch (index) {
    case 0:
      attrs.y -= height / 2;
      attrs.textAlign = 'left';
      break;

    case 1:
      attrs.y -= height / 2;
      attrs.textAlign = 'right';
      break;

    case 2:
      attrs.y += height / 2;
      attrs.textAlign = 'right';
      break;

    case 3:
      attrs.y += height / 2;
      attrs.textAlign = 'left';
      break;

    case 5:
      attrs.y -= height / 2;
      break;

    case 6:
      attrs.y += height / 2;
      break;

    case 7:
      attrs.x += width / 2;
      attrs.textAlign = 'left';
      break;

    case 8:
      attrs.x -= width / 2;
      attrs.textAlign = 'right';
      break;

    default:
      break;
  }

  label.attr(attrs);
  return label.getBBox();
}

module.exports = function (labels) {
  var greedy = new Greedy();
  var toBeRemoved = [];
  var bbox, label, x, y, canFill;

  for (var i = 0; i < labels.length; i++) {
    label = labels[i];
    x = label.attr('x');
    y = label.attr('y');
    canFill = false;

    for (var _i = 0; _i < 8; _i++) {
      bbox = adjustLabelPosition(label, x, y, _i);

      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }

    if (!canFill) {
      toBeRemoved.push(label);
    }
  }

  for (var _i2 = 0; _i2 < toBeRemoved.length; _i2++) {
    toBeRemoved[_i2].remove();
  }

  return canFill;
};

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var Greedy = __webpack_require__(111);

var MAX_TIMES = 20;

function spiralFill(label, greedy) {
  var dt = -1;
  var x = label.attr('x'),
      y = label.attr('y');
  var bbox = label.getBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy,
      t = -dt,
      dx = 0,
      dy = 0;

  var f = function f(t) {
    return [(t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };

  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }

  var canFill = false,
      times = 0;

  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < MAX_TIMES) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    label.attr({
      x: x + dx,
      y: y + dy
    });
    times++;

    if (greedy.hasGap(label.getBBox())) {
      greedy.fillGap(bbox);
      canFill = true;
      break;
    }
  }

  return canFill;
}

module.exports = function (labels) {
  var label;
  var greedy = new Greedy();
  var toBeRemoved = [];

  for (var i = 0; i < labels.length; i++) {
    label = labels[i];

    if (!spiralFill(label, greedy)) {
      toBeRemoved.push(label);
    }
  }

  for (var _i = 0; _i < toBeRemoved.length; _i++) {
    toBeRemoved[_i].remove();
  }
};

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var CatHtml = __webpack_require__(113);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var DomUtil = Util.DomUtil;
var LIST_CLASS = 'g2-legend-list';
var SLIP_CLASS = 'g2-slip';
var CARET_UP_CLASS = 'g2-caret-up';
var CARET_DOWN_CLASS = 'g2-caret-down';
var ENABLED_CARET_COLOR = 'rgba(0,0,0,0.65)';
var DISABLED_CARET_COLOR = 'rgba(0,0,0,0.25)';

function findNodeByClass(node, className) {
  return node.getElementsByClassName(className)[0];
}

var CatPageHtml =
/*#__PURE__*/
function (_CatHtml) {
  _inheritsLoose(CatPageHtml, _CatHtml);

  function CatPageHtml() {
    return _CatHtml.apply(this, arguments) || this;
  }

  var _proto = CatPageHtml.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _CatHtml.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * type鏍囪瘑
       * @type {String}
       */
      type: 'category-page-legend',

      /**
       * html 瀹瑰櫒
       * @type {DOM}
       */
      container: null,

      /**
       * 鍚戜笂 / 涓嬬炕椤靛浘鏍囩殑鏍峰紡
       * @type {ATTRS}
       */
      caretStyle: {
        fill: 'rgba(0,0,0,0.65)'
      },

      /**
       * 椤电爜鏂囧瓧鐨勬牱寮�
       * @type {ATTRS}
       */
      pageNumStyle: {
        display: 'inline-block',
        fontSize: '12px',
        fontFamily: FONT_FAMILY,
        cursor: 'default'
      },

      /**
       * 缈婚〉鍧� DOM 鐨勬牱寮�
       * @type {ATTRS}
       */
      slipDomStyle: {
        width: 'auto',
        height: 'auto',
        position: 'absolute'
      },

      /**
       * 缈婚〉鍧� DOM
       * @type {String}
       */
      slipTpl: '<div class="' + SLIP_CLASS + '" >' + '<svg viewBox="64 64 896 896" class="g2-caret-up" data-icon="left" style = "display:inline-block;vertical-align:middle;" width="1em" height="1em" aria-hidden="true">' + '<path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path>' + '</svg>' + '<p class="cur-pagenum" style = "display:inline-block;vertical-align:middle;">1</p>' + '<p class="next-pagenum" style = "display:inline-block;vertical-align:middle;"">/2</p>' + '<svg viewBox="64 64 896 896" class="g2-caret-down" data-icon="right" style = "display:inline-block;vertical-align:middle;" width="1em" height="1em" aria-hidden="true">' + '<path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path>' + '</svg>' + '</div>',

      /**
       * 缈婚〉鍧楃殑瀹藉害锛岀敤浜庤缃炕椤靛潡鐩稿浜� legend 鐨勪綅缃�
       * @type {Number}
       */
      slipWidth: 65,

      /**
       * legend 鍐呭瓒呭嚭瀹瑰櫒鐨勫鐞嗘柟寮�
       * @type {String}
       */
      legendOverflow: 'unset'
    });
  };

  _proto.render = function render() {
    _CatHtml.prototype._renderHTML.call(this);

    this._renderFlipPage();
  };

  _proto._renderFlipPage = function _renderFlipPage() {
    var legendWrapper = this.get('legendWrapper'); // ul

    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);
    var position = this.get('position');
    var layout = this.get('layout');
    var isVertical = position === 'right' || position === 'left' || layout === 'vertical';
    var itemDisplay = isVertical ? 'block' : 'inline-block';
    var legengWrapperHeight = legendWrapper.offsetHeight; // 缈婚〉

    if (legendWrapper.scrollHeight > legengWrapperHeight) {
      // append a slip div
      var slipTpl = this.get('slipTpl');
      var slipDom = DomUtil.createDom(slipTpl);
      var caretUpDom = findNodeByClass(slipDom, CARET_UP_CLASS);
      var caretDownDom = findNodeByClass(slipDom, CARET_DOWN_CLASS);
      DomUtil.modifyCSS(caretUpDom, this.get('caretStyle'));
      DomUtil.modifyCSS(caretUpDom, {
        fill: 'rgba(0,0,0,0.25)'
      });
      DomUtil.modifyCSS(caretDownDom, this.get('caretStyle'));
      var curPageNumDom = findNodeByClass(slipDom, 'cur-pagenum');
      var totalPageNumDom = findNodeByClass(slipDom, 'next-pagenum');
      var pageNumStyle = this.get('pageNumStyle');
      DomUtil.modifyCSS(curPageNumDom, Util.mix({}, pageNumStyle, {
        paddingLeft: '10px'
      }));
      DomUtil.modifyCSS(totalPageNumDom, Util.mix({}, pageNumStyle, {
        opacity: 0.3,
        paddingRight: '10px'
      })); // layout at the center-bottom of the legendWrapper

      DomUtil.modifyCSS(slipDom, Util.mix({}, this.get('slipDomStyle'), isVertical ? {
        top: legengWrapperHeight + 'px'
      } : {
        right: 0,
        top: '50%',
        // 妯悜甯冨眬鐨勬椂鍊欙紝鍒嗛〉鍦ㄥ彸渚у眳涓榻�
        transform: 'translate(0, -50%)'
      }));
      legendWrapper.style.overflow = this.get('legendOverflow');
      legendWrapper.appendChild(slipDom);

      if (!isVertical) {
        var legendListMaxWidth = Math.max(legendWrapper.offsetWidth - 10 - slipDom.offsetWidth, 0); // 妯悜甯冨眬鐨勬椂鍊欐洿鏂發ist鐨勫搴�

        DomUtil.modifyCSS(itemListDom, {
          maxWidth: legendListMaxWidth + "px"
        });
      }

      var li = itemListDom.childNodes;
      var curHeight = 0; // find the total page number

      var pages = 1;
      var blockLi = [];

      for (var i = 0; i < li.length; i++) {
        li[i].style.display = itemDisplay;
        curHeight = li[i].offsetTop + li[i].offsetHeight;

        if (curHeight > legengWrapperHeight) {
          pages++;
          blockLi.forEach(function (bl) {
            bl.style.display = 'none';
          });
          blockLi = [];
        }

        blockLi.push(li[i]);
      }

      totalPageNumDom.innerText = '/' + pages; // initialize the page

      li.forEach(function (l) {
        l.style.display = itemDisplay;
        curHeight = l.offsetTop + l.offsetHeight;

        if (curHeight > legengWrapperHeight) {
          l.style.display = 'none';
        }
      }); // 涓婄炕浜嬩欢

      caretUpDom.addEventListener('click', function () {
        // it is the 1st page
        if (li[0].style.display === itemDisplay) return; // otherwise

        var firstDisplayItemIdx = -1;
        li.forEach(function (l, i) {
          if (l.style.display === itemDisplay) {
            firstDisplayItemIdx = firstDisplayItemIdx === -1 ? i : firstDisplayItemIdx;
            l.style.display = 'none';
          }
        });

        for (var _i = firstDisplayItemIdx - 1; _i >= 0; _i--) {
          li[_i].style.display = itemDisplay;
          curHeight = li[firstDisplayItemIdx - 1].offsetTop + li[firstDisplayItemIdx - 1].offsetHeight;
          li[_i].style.display = 'none';

          if (curHeight <= legengWrapperHeight) {
            li[_i].style.display = itemDisplay;
          } else break;
        } // change the page number


        var currentPage = Number.parseInt(curPageNumDom.innerText, 10) - 1;

        if (currentPage === 1) {
          caretUpDom.style.fill = DISABLED_CARET_COLOR;
        } else {
          caretUpDom.style.fill = ENABLED_CARET_COLOR;
        }

        caretDownDom.style.fill = ENABLED_CARET_COLOR;
        curPageNumDom.innerText = currentPage;
      }); // 涓嬬炕浜嬩欢

      caretDownDom.addEventListener('click', function () {
        // it is the last page
        if (li[li.length - 1].style.display === itemDisplay) return; // otherwise

        var lastDisplayItemIdx = -1;
        li.forEach(function (l, i) {
          if (l.style.display === itemDisplay) {
            lastDisplayItemIdx = i;
            l.style.display = 'none';
          }
        });

        for (var _i2 = lastDisplayItemIdx + 1; _i2 < li.length; _i2++) {
          li[_i2].style.display = itemDisplay;
          curHeight = li[_i2].offsetTop + li[_i2].offsetHeight;
          li[_i2].style.display = 'none';
          if (curHeight <= legengWrapperHeight) li[_i2].style.display = itemDisplay;else break;
        } // change the page number


        var currentPage = Number.parseInt(curPageNumDom.innerText, 10) + 1;

        if (currentPage === pages) {
          caretDownDom.style.fill = DISABLED_CARET_COLOR;
        } else {
          caretDownDom.style.fill = ENABLED_CARET_COLOR;
        }

        caretUpDom.style.fill = ENABLED_CARET_COLOR;
        curPageNumDom.innerText = currentPage;
      });
      this.set('slipDom', slipDom);
    }
  };

  _proto.destroy = function destroy() {
    var slipDom = this.get('slipDom');

    if (slipDom && slipDom.parentNode) {
      slipDom.parentNode.removeChild(slipDom);
    }

    _CatHtml.prototype.destroy.call(this);
  };

  return CatPageHtml;
}(CatHtml);

module.exports = CatPageHtml;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The class of the gradient color legend
 * @author sima.zhang
 */
var _require = __webpack_require__(65),
    ColorUtil = _require.ColorUtil; // TODO锛欳olorUtil 鍖呴渶瑕佷粠 attr 鍖呬腑鎶界


var Util = __webpack_require__(3);

var Continuous = __webpack_require__(67);

var Color =
/*#__PURE__*/
function (_Continuous) {
  _inheritsLoose(Color, _Continuous);

  function Color() {
    return _Continuous.apply(this, arguments) || this;
  }

  var _proto = Color.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Continuous.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'color-legend',

      /**
       * 甯冨眬鏂瑰紡
       * horizontal 姘村钩
       * vertical 鍨傜洿
       * @type {String}
       */
      layout: 'vertical',

      /**
       * 涓ゅご婊戝潡鐨勬牱寮�
       * @type {object}
       */
      triggerAttr: {
        fill: '#fff',
        shadowOffsetX: -2,
        shadowOffsetY: 2,
        shadowBlur: 10,
        shadowColor: '#ccc',
        radius: 3
      },

      /**
       * 鍚屼竴鍒嗘鏄惁浣跨敤鐩稿悓棰滆壊鑰屼笉浣跨敤娓愬彉鑹诧紝鍦� slidable = false 鏃剁敓鏁�
       * @type {boolean}
       */
      isSegment: false
    });
  };

  _proto._setPercentage = function _setPercentage() {
    var items = this.get('items');
    if (items[0].percentage) return;
    var min = items[0].value;
    var max = items[items.length - 1].value;
    Util.each(items, function (it) {
      it.percentage = (it.value - min) / (max - min);
    });
    return;
  } // render the slider while slidable === true
  ;

  _proto._renderSliderShape = function _renderSliderShape() {
    this._setPercentage();

    var slider = this.get('slider');
    var backgroundElement = slider.get('backgroundElement');
    var width = this.get('width');
    var height = this.get('height');
    var layout = this.get('layout');
    var items = this.get('items');
    var fill = '';
    var rgbColor; // gradient color distributed according to the percentage

    if (layout === 'vertical') {
      fill += 'l (90) ';
      Util.each(items, function (v) {
        rgbColor = ColorUtil.toRGB(v.color);
        fill += 1 - v.percentage + ':' + rgbColor + ' ';
      });
    } else {
      fill += 'l (0) ';
      Util.each(items, function (v) {
        rgbColor = ColorUtil.toRGB(v.color);
        fill += v.percentage + ':' + rgbColor + ' ';
      });
    }

    return this._addMiddleBar(backgroundElement, 'Rect', {
      x: 0,
      y: 0,
      width: width,
      height: height,
      fill: fill,
      strokeOpacity: 0
    });
  } // render the silder while slidable === false
  ;

  _proto._renderUnslidable = function _renderUnslidable() {
    this._setPercentage();

    var titleShape = this.get('titleShape');
    var titleGap = this.get('titleGap');
    titleGap = titleShape ? titleShape.getBBox().height + titleGap : titleGap;
    var width = this.get('width');
    var height = this.get('height');
    var layout = this.get('layout');
    var items = this.get('items');
    var fill = '';
    var rgbColor;
    var path = [];
    var group = this.get('group');
    var bgGroup = group.addGroup();
    var isize = items.length; // gradient color distributed according to the percentage

    if (layout === 'vertical') {
      fill += 'l (90) ';

      for (var i = 0; i < isize; i += 1) {
        if (i !== 0 && i !== isize - 1) {
          path.push(['M', 0, height - items[i].percentage * height]);
          path.push(['L', width, height - items[i].percentage * height]);
        }

        rgbColor = ColorUtil.toRGB(items[i].color);
        fill += 1 - items[i].percentage + ':' + rgbColor + ' ';

        if (this.get('isSegment') && i > 0) {
          // one color instead of gradient color for a block while isSegment === true
          var preRgbColor = ColorUtil.toRGB(items[i - 1].color);
          fill += 1 - items[i].percentage + ':' + preRgbColor + ' ';
        }

        bgGroup.addShape('text', {
          attrs: Util.mix({}, {
            x: width + this.get('textOffset') / 2,
            y: height - items[i].percentage * height,
            text: this._formatItemValue(items[i].value) + '' // 浠ュ瓧绗︿覆鏍煎紡灞曠ず

          }, this.get('textStyle'), {
            textAlign: 'start'
          })
        });
      }
    } else {
      // horizontal
      fill += 'l (0) ';

      for (var _i = 0; _i < isize; _i += 1) {
        if (_i !== 0 && _i !== isize - 1) {
          path.push(['M', items[_i].percentage * width, 0]);
          path.push(['L', items[_i].percentage * width, height]);
        }

        rgbColor = ColorUtil.toRGB(items[_i].color);

        if (this.get('isSegment') && _i > 0) {
          var _preRgbColor = ColorUtil.toRGB(items[_i - 1].color);

          fill += items[_i].percentage + ':' + _preRgbColor + ' ';
        }

        fill += items[_i].percentage + ':' + rgbColor + ' ';
        bgGroup.addShape('text', {
          attrs: Util.mix({}, {
            x: items[_i].percentage * width,
            y: height + 5 + this.get('textOffset'),
            text: this._formatItemValue(items[_i].value) + '' // 浠ュ瓧绗︿覆鏍煎紡灞曠ず

          }, this.get('textStyle'))
        });
      }
    }

    bgGroup.addShape('rect', {
      attrs: {
        x: 0,
        y: 0,
        width: width,
        height: height,
        fill: fill,
        strokeOpacity: 0
      }
    }); // the white line segment to seperate color blocks

    bgGroup.addShape('path', {
      attrs: Util.mix({
        path: path
      }, this.get('lineStyle'))
    });
    bgGroup.move(0, titleGap);
  };

  return Color;
}(Continuous);

module.exports = Color;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The entry of legend
 * @author sima.zhang
 */
module.exports = {
  Category: __webpack_require__(114),
  // 鍒嗙被鍥句緥
  CatHtml: __webpack_require__(113),
  // 鍒嗙被鍥句緥
  CatPageHtml: __webpack_require__(256),
  // 鍒嗙被鍥句緥
  // Tail: require('./tail'), // 灏鹃儴璺熼殢鍥句緥
  Color: __webpack_require__(257),
  // 棰滆壊鍥句緥
  Size: __webpack_require__(260),
  // 澶у皬鍥句緥锛堥€傜敤浜庨櫎鏄犲皠鐐瑰ぇ灏忎互澶栫殑鍏朵粬澶у皬锛�
  CircleSize: __webpack_require__(259) // 鐐瑰ぇ灏忓浘渚�

};

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The class of the size legend
 * @author sima.zhang
 * @author ye liu
 */
var Util = __webpack_require__(3); // const Global = require('../../global');


var Continuous = __webpack_require__(67);

var SLIDER_HEIGHT = 2;
var CIRCLE_GAP = 16;
var MAX_SIZE = 16;
var MIN_SIZE = 5;

var CircleSize =
/*#__PURE__*/
function (_Continuous) {
  _inheritsLoose(CircleSize, _Continuous);

  function CircleSize() {
    return _Continuous.apply(this, arguments) || this;
  }

  var _proto = CircleSize.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Continuous.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'size-circle-legend',
      width: 100,
      height: 200,

      /**
       * 涓嶈兘婊戝姩鏃跺湀鐨勬牱寮�
       * @type {ATTRS}
       */
      _unslidableCircleStyle: {
        stroke: 'rgb(99, 161, 248)',
        fill: 'rgb(99, 161, 248)',
        fillOpacity: 0.3,
        lineWidth: 1.5
      },

      /**
       * 婊戝潡鐨勬牱寮�
       * @type {ATTRS}
       */
      triggerAttr: {
        fill: 'white',
        shadowOffsetX: -2,
        shadowOffsetY: 2,
        shadowBlur: 10,
        shadowColor: '#ccc'
      },

      /**
       * 涓棿 bar 鐨勫墠鏅鑹�
       * @type {ATTRS}
       */
      frontMiddleBarStyle: {
        fill: 'rgb(64, 141, 251)'
      }
    });
  } // render the slider shape
  ;

  _proto._renderSliderShape = function _renderSliderShape() {
    var minRadius = MIN_SIZE;
    var slider = this.get('slider');
    var backgroundElement = slider.get('backgroundElement');
    var layout = this.get('layout');
    var width = layout === 'vertical' ? SLIDER_HEIGHT : this.get('width');
    var height = layout === 'vertical' ? this.get('height') : SLIDER_HEIGHT;
    var x = minRadius;
    var y = this.get('height') / 2;
    var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar

    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [0, height]] : [[0, y + height], [0, y - height], [x + width - 4, y - height], [x + width - 4, y + height]];
    return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({
      points: points
    }, frontMiddleBarStyle));
  } // triggers while layout === horizontal
  ;

  _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr, radius) {
    var slider = this.get('slider');
    var trigger = slider.get(type + 'HandleElement');
    var y = -this.get('height') / 2;
    var button = trigger.addShape('circle', {
      attrs: Util.mix({
        x: 0,
        y: y,
        r: radius
      }, blockAttr)
    });
    var text = trigger.addShape('text', {
      attrs: Util.mix(textAttr, {
        x: 0,
        y: y + radius + 10,
        textAlign: 'center',
        textBaseline: 'middle'
      })
    });
    var layout = this.get('layout');
    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
    button.attr('cursor', trigerCursor);
    text.attr('cursor', trigerCursor);
    this.set(type + 'ButtonElement', button);
    this.set(type + 'TextElement', text);
  } // triggers while layout === vertical
  ;

  _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr, radius) {
    var slider = this.get('slider');
    var trigger = slider.get(type + 'HandleElement');
    var button = trigger.addShape('circle', {
      attrs: Util.mix({
        x: 0,
        y: 0,
        r: radius
      }, blockAttr)
    });
    var text = trigger.addShape('text', {
      attrs: Util.mix(textAttr, {
        x: radius + 10,
        y: 0,
        textAlign: 'start',
        textBaseline: 'middle'
      })
    });
    var layout = this.get('layout');
    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
    button.attr('cursor', trigerCursor);
    text.attr('cursor', trigerCursor);
    this.set(type + 'ButtonElement', button);
    this.set(type + 'TextElement', text);
  } // render the triggers
  ;

  _proto._renderTrigger = function _renderTrigger() {
    var min = this.get('firstItem');
    var max = this.get('lastItem');
    var layout = this.get('layout');
    var textStyle = this.get('textStyle');
    var triggerAttr = this.get('triggerAttr');
    var minBlockAttr = Util.mix({}, triggerAttr);
    var maxBlockAttr = Util.mix({}, triggerAttr);
    var minRadius = MIN_SIZE;
    var maxRadius = MAX_SIZE;
    var minTextAttr = Util.mix({
      text: this._formatItemValue(min.value) + ''
    }, textStyle);
    var maxTextAttr = Util.mix({
      text: this._formatItemValue(max.value) + ''
    }, textStyle);

    if (layout === 'vertical') {
      this._addVerticalTrigger('min', minBlockAttr, minTextAttr, minRadius);

      this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);
    } else {
      this._addHorizontalTrigger('min', minBlockAttr, minTextAttr, minRadius);

      this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);
    }
  } // user interactions
  ;

  _proto._bindEvents = function _bindEvents() {
    var _this = this;

    if (this.get('slidable')) {
      var slider = this.get('slider');
      slider.on('sliderchange', function (ev) {
        var range = ev.range;

        var firstItemValue = _this.get('firstItem').value;

        var lastItemValue = _this.get('lastItem').value;

        var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);
        var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);
        var minRadius = MIN_SIZE + range[0] / 100 * (MAX_SIZE - MIN_SIZE);
        var maxRadius = MIN_SIZE + range[1] / 100 * (MAX_SIZE - MIN_SIZE);

        _this._updateElement(minValue, maxValue, minRadius, maxRadius);

        var itemFiltered = new Event('itemfilter', ev, true, true);
        itemFiltered.range = [minValue, maxValue];

        _this.emit('itemfilter', itemFiltered);
      });
    }
  } // update the triggers
  ;

  _proto._updateElement = function _updateElement(min, max, minR, maxR) {
    // update the text of the triggers
    _Continuous.prototype._updateElement.call(this, min, max);

    var minTextElement = this.get('minTextElement');
    var maxTextElement = this.get('maxTextElement');
    var minCircleElement = this.get('minButtonElement');
    var maxCircleElement = this.get('maxButtonElement'); // update the radius of the triggers

    minCircleElement.attr('r', minR);
    maxCircleElement.attr('r', maxR); // update the text position of the triggers

    var layout = this.get('layout');

    if (layout === 'vertical') {
      minTextElement.attr('x', minR + 10);
      maxTextElement.attr('x', maxR + 10);
    } else {
      var y = -this.get('height') / 2;
      minTextElement.attr('y', y + minR + 10);
      maxTextElement.attr('y', y + maxR + 10);
    }
  } // add a circle for slidable === false
  ;

  _proto._addCircle = function _addCircle(x, y, r, text, maxWidth) {
    var group = this.get('group');
    var circleGroup = group.addGroup();
    var circleStyle = this.get('_unslidableCircleStyle');
    var textStyle = this.get('textStyle');
    var titleShape = this.get('titleShape');
    var titleGap = this.get('titleGap');

    if (titleShape) {
      titleGap += titleShape.getBBox().height;
    }

    circleGroup.addShape('circle', {
      attrs: Util.mix({
        x: x,
        y: y + titleGap,
        r: r === 0 ? 1 : r
      }, circleStyle)
    });

    if (this.get('layout') === 'vertical') {
      circleGroup.addShape('text', {
        attrs: Util.mix({
          x: maxWidth + 20 + this.get('textOffset'),
          y: y + titleGap,
          text: text === 0 ? '0' : text
        }, textStyle)
      });
    } else {
      circleGroup.addShape('text', {
        attrs: Util.mix({
          x: x,
          y: y + titleGap + maxWidth + 13 + this.get('textOffset'),
          text: text === 0 ? '0' : text
        }, textStyle)
      });
    }
  } // the circles while slidable === false
  ;

  _proto._renderUnslidable = function _renderUnslidable() {
    var firstItemValue = this.get('firstItem').value;
    var lastItemValue = this.get('lastItem').value;

    if (firstItemValue > lastItemValue) {
      var tmp = lastItemValue;
      lastItemValue = firstItemValue;
      firstItemValue = tmp;
    }

    var minText = this._formatItemValue(firstItemValue);

    var maxText = this._formatItemValue(lastItemValue);

    var minRadius = firstItemValue < MIN_SIZE ? MIN_SIZE : firstItemValue;
    var maxRadius = lastItemValue > MAX_SIZE ? MAX_SIZE : lastItemValue;

    if (minRadius > maxRadius) {
      minRadius = MIN_SIZE;
      maxRadius = MAX_SIZE;
    }

    if (this.get('layout') === 'vertical') {
      this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min


      this._addCircle(maxRadius, maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxText, 2 * maxRadius); // max

    } else {
      this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min


      this._addCircle(maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxRadius, maxText, 2 * maxRadius); // max

    }
  };

  _proto.activate = function activate(value) {
    if (!this.get('slidable')) {
      return;
    }

    _Continuous.prototype.activate.call(this, value);
  };

  return CircleSize;
}(Continuous);

module.exports = CircleSize;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The class of the gradient color legend
 * @author sima.zhang
 */
var Util = __webpack_require__(3);

var Continuous = __webpack_require__(67);

var Size =
/*#__PURE__*/
function (_Continuous) {
  _inheritsLoose(Size, _Continuous);

  function Size() {
    return _Continuous.apply(this, arguments) || this;
  }

  var _proto = Size.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Continuous.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'size-legend',
      width: 100,
      height: 200,

      /**
       * 涓嶈兘婊戝姩鏃跺湀鐨勬牱寮�
       * @type {ATTRS}
       */
      _unslidableElementStyle: {
        fill: '#4E7CCC',
        fillOpacity: 1
      },

      /**
       * 涓棿 bar 鐨勫墠鏅鑹�
       * @type {ATTRS}
       */
      frontMiddleBarStyle: {
        fill: 'rgb(64, 141, 251)'
      }
    });
  } // render the slider shape
  ;

  _proto._renderSliderShape = function _renderSliderShape() {
    var slider = this.get('slider');
    var backgroundElement = slider.get('backgroundElement');
    var layout = this.get('layout');
    var width = this.get('width');
    var height = this.get('height'); // const x = minRadius;

    var y = this.get('height') / 2;
    var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar

    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, y + height / 2], [0, y + height / 2 - 4], [width, y - height / 2], [width, y + height / 2]];
    return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({
      points: points
    }, frontMiddleBarStyle));
  } // render the middle bar while slidable === false,
  // there are no triggers for this situation
  ;

  _proto._renderUnslidable = function _renderUnslidable() {
    var layout = this.get('layout');
    var width = this.get('width');
    var height = this.get('height');
    var frontMiddleBarStyle = this.get('frontMiddleBarStyle');
    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, height], [0, height - 4], [width, 0], [width, height]];
    var group = this.get('group');
    var bgGroup = group.addGroup();
    bgGroup.addShape('Polygon', {
      attrs: Util.mix({
        points: points
      }, frontMiddleBarStyle)
    });

    var minText = this._formatItemValue(this.get('firstItem').value);

    var maxText = this._formatItemValue(this.get('lastItem').value);

    if (this.get('layout') === 'vertical') {
      this._addText(width + 10, height - 3, minText); // min


      this._addText(width + 10, 3, maxText); // max

    } else {
      this._addText(0, height, minText); // min


      this._addText(width, height, maxText); // max

    }
  } // add min and max text while slidable === false
  ;

  _proto._addText = function _addText(x, y, text) {
    var group = this.get('group');
    var textGroup = group.addGroup();
    var textStyle = this.get('textStyle');
    var titleShape = this.get('titleShape');
    var titleGap = this.get('titleGap');

    if (titleShape) {
      titleGap += titleShape.getBBox().height;
    }

    if (this.get('layout') === 'vertical') {
      textGroup.addShape('text', {
        attrs: Util.mix({
          x: x + this.get('textOffset'),
          y: y,
          text: text === 0 ? '0' : text
        }, textStyle)
      });
    } else {
      y += titleGap + this.get('textOffset') - 20;
      if (!titleShape) y += 10;
      textGroup.addShape('text', {
        attrs: Util.mix({
          x: x,
          y: y,
          text: text === 0 ? '0' : text
        }, textStyle)
      });
    }
  };

  return Size;
}(Continuous);

module.exports = Size;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The class of slider
 * @author sima.zhang
 */
var Util = __webpack_require__(3);

var DomUtil = Util.DomUtil;
var Group = Util.Group;

var Slider =
/*#__PURE__*/
function (_Group) {
  _inheritsLoose(Slider, _Group);

  function Slider() {
    return _Group.apply(this, arguments) || this;
  }

  var _proto = Slider.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      /**
       * 鑼冨洿
       * @type {Array}
       */
      range: null,

      /**
       * 涓粦鍧楀睘鎬�
       * 閫忔槑鐨勶紝鐢ㄤ簬鐢ㄦ埛浜や簰
       * @type {ATTRS}
       */
      middleAttr: {
        fill: '#fff',
        fillOpacity: 0
      },

      /**
       * 鑳屾櫙
       * @type {G-Element}
       */
      backgroundElement: null,

      /**
       * 涓嬫粦鍧�
       * @type {G-Element}
       */
      minHandleElement: null,

      /**
       * 涓婃粦鍧�
       * @type {G-Element}
       */
      maxHandleElement: null,

      /**
       * 涓潡锛�
       * 閫忔槑鐨勶紝鐢ㄤ簬鐢ㄦ埛浜や簰
       * @type {G-Element}
       */
      middleHandleElement: null,

      /**
       * 褰撳墠鐨勬縺娲荤殑鍏冪礌
       * @type {G-Element}
       */
      currentTarget: null,

      /**
       * 甯冨眬鏂瑰紡锛� horizontal锛寁ertical
       * @type {String}
       */
      layout: 'vertical',

      /**
       * 瀹�
       * @type {Number}
       */
      width: null,

      /**
       * 楂�
       * @type {Number}
       */
      height: null,

      /**
       * 褰撳墠鐨凱ageX
       * @type {Number}
       */
      pageX: null,

      /**
       * 褰撳墠鐨凱ageY
       * @type {Number}
       */
      pageY: null
    };
  } // arrange the zindex and cursors of each element
  ;

  _proto._beforeRenderUI = function _beforeRenderUI() {
    var layout = this.get('layout');
    var backgroundElement = this.get('backgroundElement');
    var minHandleElement = this.get('minHandleElement');
    var maxHandleElement = this.get('maxHandleElement');
    var middleHandleElement = this.addShape('rect', {
      attrs: this.get('middleAttr')
    });
    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';
    this.add([backgroundElement, minHandleElement, maxHandleElement]);
    this.set('middleHandleElement', middleHandleElement);
    backgroundElement.set('zIndex', 0);
    middleHandleElement.set('zIndex', 1);
    minHandleElement.set('zIndex', 2);
    maxHandleElement.set('zIndex', 2);
    middleHandleElement.attr('cursor', 'move');
    minHandleElement.attr('cursor', trigerCursor);
    maxHandleElement.attr('cursor', trigerCursor);
    this.sort();
  } // rendering
  ;

  _proto._renderUI = function _renderUI() {
    if (this.get('layout') === 'horizontal') {
      this._renderHorizontal();
    } else {
      this._renderVertical();
    }
  };

  _proto._transform = function _transform(layout) {
    var range = this.get('range');
    var minRatio = range[0] / 100;
    var maxRatio = range[1] / 100;
    var width = this.get('width');
    var height = this.get('height');
    var minHandleElement = this.get('minHandleElement');
    var maxHandleElement = this.get('maxHandleElement');
    var middleHandleElement = this.get('middleHandleElement');
    minHandleElement.resetMatrix();
    maxHandleElement.resetMatrix();

    if (layout === 'horizontal') {
      middleHandleElement.attr({
        x: width * minRatio,
        y: 0,
        width: (maxRatio - minRatio) * width,
        height: height
      });
      minHandleElement.translate(minRatio * width, height);
      maxHandleElement.translate(maxRatio * width, height);
    } else {
      middleHandleElement.attr({
        x: 0,
        y: height * (1 - maxRatio),
        width: width,
        height: (maxRatio - minRatio) * height
      });
      minHandleElement.translate(1, (1 - minRatio) * height);
      maxHandleElement.translate(1, (1 - maxRatio) * height);
    }
  };

  _proto._renderHorizontal = function _renderHorizontal() {
    this._transform('horizontal');
  };

  _proto._renderVertical = function _renderVertical() {
    this._transform('vertical');
  };

  _proto._bindUI = function _bindUI() {
    this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));
  } // if the target matches name
  ;

  _proto._isElement = function _isElement(target, name) {
    var element = this.get(name);

    if (target === element) {
      return true;
    }

    if (element.isGroup) {
      var elementChildren = element.get('children');
      return elementChildren.indexOf(target) > -1;
    }

    return false;
  } // get the result range after adding diff to range
  // insure that the result out of the interval [0, 100]
  ;

  _proto._getRange = function _getRange(diff, range) {
    var rst = diff + range;
    rst = rst > 100 ? 100 : rst;
    rst = rst < 0 ? 0 : rst;
    return rst;
  };

  _proto._updateStatus = function _updateStatus(dim, ev) {
    var totalLength = dim === 'x' ? this.get('width') : this.get('height');
    dim = Util.upperFirst(dim);
    var range = this.get('range');
    var page = this.get('page' + dim);
    var currentTarget = this.get('currentTarget');
    var rangeStash = this.get('rangeStash');
    var layout = this.get('layout');
    var sign = layout === 'vertical' ? -1 : 1;
    var currentPage = ev['page' + dim]; // the distance of the mouse dragging

    var diffPage = currentPage - page;
    var diffRange = diffPage / totalLength * 100 * sign;
    var diffStashRange; // the min and max trigger overlap, range[0] and range[1] change together

    if (range[1] <= range[0]) {
      if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {
        range[0] = this._getRange(diffRange, range[0]);
        range[1] = this._getRange(diffRange, range[0]);
      }
    } else {
      // user drags the min trigger
      if (this._isElement(currentTarget, 'minHandleElement')) {
        range[0] = this._getRange(diffRange, range[0]);
      } // user drags the max trigger


      if (this._isElement(currentTarget, 'maxHandleElement')) {
        range[1] = this._getRange(diffRange, range[1]);
      }
    } // the user drags the middle bar


    if (this._isElement(currentTarget, 'middleHandleElement')) {
      // the diffrence between min and max trigger while mouse down
      diffStashRange = rangeStash[1] - rangeStash[0];
      range[0] = this._getRange(diffRange, range[0]); // keep the diffStashRange

      range[1] = range[0] + diffStashRange;

      if (range[1] > 100) {
        range[1] = 100;
        range[0] = range[1] - diffStashRange;
      }
    }

    this.emit('sliderchange', {
      range: range
    });
    this.set('page' + dim, currentPage);

    this._renderUI();

    this.get('canvas').draw(); // need delete

    return;
  } // the listener of mouse down
  ;

  _proto._onMouseDown = function _onMouseDown(ev) {
    var currentTarget = ev.currentTarget;
    var originEvent = ev.event;
    var range = this.get('range');
    originEvent.stopPropagation();
    originEvent.preventDefault();
    this.set('pageX', originEvent.pageX);
    this.set('pageY', originEvent.pageY);
    this.set('currentTarget', currentTarget); // stash the range

    this.set('rangeStash', [range[0], range[1]]);

    this._bindCanvasEvents();
  };

  _proto._bindCanvasEvents = function _bindCanvasEvents() {
    var containerDOM = this.get('canvas').get('containerDOM'); // this.on('mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));

    this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));
    this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp'));
    this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));
  } // listener of mouse click and move = drag
  ;

  _proto._onCanvasMouseMove = function _onCanvasMouseMove(ev) {
    if (!this._mouseOutArea(ev)) {
      var layout = this.get('layout');

      if (layout === 'horizontal') {
        this._updateStatus('x', ev);
      } else {
        this._updateStatus('y', ev);
      }
    }
  } // listener of mouse up
  ;

  _proto._onCanvasMouseUp = function _onCanvasMouseUp() {
    this._removeDocumentEvents();
  } // remove listeners
  ;

  _proto._removeDocumentEvents = function _removeDocumentEvents() {
    this.onMouseMoveListener.remove();
    this.onMouseUpListener.remove();
  } // if the mouse is out of the area
  ;

  _proto._mouseOutArea = function _mouseOutArea(ev) {
    var el = this.get('canvas').get('el');
    var el_bbox = el.getBoundingClientRect();
    var parent = this.get('parent');
    var bbox = parent.getBBox();
    var left = parent.attr('matrix')[6];
    var top = parent.attr('matrix')[7];
    var right = left + bbox.width;
    var bottom = top + bbox.height;
    var mouseX = ev.clientX - el_bbox.x;
    var mouseY = ev.clientY - el_bbox.y;

    if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {
      return true;
    }

    return false;
  };

  return Slider;
}(Group);

module.exports = Slider;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var G = __webpack_require__(31);

var Tooltip = __webpack_require__(68);

var Util = __webpack_require__(3);

var DomUtil = Util.DomUtil;

var TooltipTheme = __webpack_require__(265);

var Crosshair = __webpack_require__(116);

var PositionMixin = __webpack_require__(118);

var MarkerGroupMixin = __webpack_require__(117);

var CONTAINER_CLASS = 'g2-tooltip';
var TITLE_CLASS = 'g2-tooltip-title';
var LIST_CLASS = 'g2-tooltip-list';
var MARKER_CLASS = 'g2-tooltip-marker';
var VALUE_CLASS = 'g2-tooltip-value';
var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
var MARKER_SIZE = 5;
var Marker = G.Marker;

function find(dom, cls) {
  return dom.getElementsByClassName(cls)[0];
}

function mergeStyles(styles, cfg) {
  Object.keys(styles).forEach(function (k) {
    if (cfg[k]) {
      styles[k] = Util.mix(styles[k], cfg[k]);
    }
  });
  return styles;
}

var HtmlTooltip =
/*#__PURE__*/
function (_Tooltip) {
  _inheritsLoose(HtmlTooltip, _Tooltip);

  var _proto = HtmlTooltip.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Tooltip.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
         * tooltip 瀹瑰櫒妯℃澘
         * @type {String}
      */
      containerTpl: ' <div class="' + CONTAINER_CLASS + '"> ' + '<div class="' + TITLE_CLASS + '"></div>' + '<ul class="' + LIST_CLASS + '"></ul>' + '</div>',

      /**
       * tooltip 鍒楄〃椤规ā鏉�
       * @type {String}
       */
      itemTpl: "<li data-index={index}>\n      <svg viewBox=\"0 0 " + MARKER_SIZE + " " + MARKER_SIZE + "\" class=\"" + MARKER_CLASS + "\"></svg>\n      {name}<span class=\"" + VALUE_CLASS + "\">{value}</span></li>",

      /**
       * tooltip html鍐呭
       * @type {String}
       */
      htmlContent: null,

      /**
       * tooltip 鍐呭璺熼殢榧犳爣绉诲姩
       * @type {Boolean}
       */
      follow: true,

      /**
       * 鏄惁鍏佽榧犳爣鍋滅暀鍦� tooltip 涓婏紝榛樿涓嶅厑璁�
       * @type {Boolean}
       */
      enterable: false
    });
  };

  function HtmlTooltip(cfg) {
    var _this;

    _this = _Tooltip.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), PositionMixin);
    Util.assign(_assertThisInitialized(_this), MarkerGroupMixin);
    var style = TooltipTheme;
    _this.style = mergeStyles(style, cfg);

    _this._init_();

    if (_this.get('items')) {
      _this.render();
    } // crosshair


    var crosshair = _this.get('crosshairs');

    if (crosshair) {
      var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');
      var crosshairGroup = new Crosshair(Util.mix({
        plot: plot,
        plotRange: _this.get('plotRange'),
        canvas: _this.get('canvas')
      }, _this.get('crosshairs')));
      crosshairGroup.hide();

      _this.set('crosshairGroup', crosshairGroup);
    }

    return _this;
  }

  _proto._init_ = function _init_() {
    var self = this;
    var containerTpl = self.get('containerTpl');
    var outterNode = self.get('canvas').get('el').parentNode;
    var container;

    if (!this.get('htmlContent')) {
      if (/^\#/.test(containerTpl)) {
        // 濡傛灉浼犲叆 dom 鑺傜偣鐨� id
        var id = containerTpl.replace('#', '');
        container = document.getElementById(id);
      } else {
        container = DomUtil.createDom(containerTpl);
        DomUtil.modifyCSS(container, self.style[CONTAINER_CLASS]);
        outterNode.appendChild(container);
        outterNode.style.position = 'relative';
      }

      self.set('container', container);
    }
  };

  _proto.render = function render() {
    var self = this;
    self.clear();

    if (self.get('htmlContent')) {
      var outterNode = self.get('canvas').get('el').parentNode;

      var container = self._getHtmlContent();

      outterNode.appendChild(container);
      self.set('container', container);
    } else {
      self._renderTpl();
    }
  };

  _proto._renderTpl = function _renderTpl() {
    var self = this;
    var showTitle = self.get('showTitle');
    var titleContent = self.get('titleContent');
    var container = self.get('container');
    var titleDom = find(container, TITLE_CLASS);
    var listDom = find(container, LIST_CLASS);
    var items = self.get('items');

    if (titleDom && showTitle) {
      DomUtil.modifyCSS(titleDom, self.style[TITLE_CLASS]);
      titleDom.innerHTML = titleContent;
    }

    if (listDom) {
      DomUtil.modifyCSS(listDom, self.style[LIST_CLASS]);
      Util.each(items, function (item, index) {
        listDom.appendChild(self._addItem(item, index));
      });
    }
  };

  _proto.clear = function clear() {
    var container = this.get('container');

    if (this.get('htmlContent')) {
      container && container.remove();
    } else {
      var titleDom = find(container, TITLE_CLASS);
      var listDom = find(container, LIST_CLASS);

      if (titleDom) {
        titleDom.innerHTML = '';
      }

      if (listDom) {
        listDom.innerHTML = '';
      }
    }
  };

  _proto.show = function show() {
    var container = this.get('container');

    if (!container || this.destroyed) {
      // 闃叉瀹瑰櫒涓嶅瓨鍦ㄦ垨鑰呰閿€姣佹椂鎶ラ敊
      return;
    }

    container.style.visibility = 'visible';
    container.style.display = 'block';
    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.show();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.show();

    _Tooltip.prototype.show.call(this);

    this.get('canvas').draw();
  };

  _proto.hide = function hide() {
    var container = this.get('container'); // relative: https://github.com/antvis/g2/issues/1221

    if (!container || this.destroyed) {
      return;
    }

    container.style.visibility = 'hidden';
    container.style.display = 'none';
    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.hide();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.hide();

    _Tooltip.prototype.hide.call(this);

    this.get('canvas').draw();
  };

  _proto.destroy = function destroy() {
    var self = this;
    var container = self.get('container');
    var containerTpl = self.get('containerTpl');

    if (container && !/^\#/.test(containerTpl)) {
      container.parentNode.removeChild(container);
    }

    var crosshairGroup = this.get('crosshairGroup');
    crosshairGroup && crosshairGroup.destroy();
    var markerGroup = this.get('markerGroup');
    markerGroup && markerGroup.remove();

    _Tooltip.prototype.destroy.call(this);
  };

  _proto._getMarkerSvg = function _getMarkerSvg(item) {
    var marker = item.marker || {};
    var symbol = marker.activeSymbol || marker.symbol;
    var method;

    if (Util.isFunction(symbol)) {
      method = symbol;
    } else if (Util.isString(symbol)) {
      method = Marker.Symbols[symbol];
    }

    method = Util.isFunction(method) ? method : Marker.Symbols.circle;
    var pathArr = method(MARKER_SIZE / 2, MARKER_SIZE / 2, MARKER_SIZE / 2);
    var path = pathArr.reduce(function (res, arr) {
      return "" + res + arr[0] + arr.slice(1).join(',');
    }, '');
    return "<path d=\"" + path + "\" fill=\"" + (marker.fill || 'none') + "\" stroke=\"" + (marker.stroke || 'none') + "\" />";
  };

  _proto._addItem = function _addItem(item, index) {
    var itemTpl = this.get('itemTpl'); // TODO: 鏈夊彲鑳芥槸涓洖璋冨嚱鏁�

    var itemDiv = Util.substitute(itemTpl, Util.mix({
      index: index
    }, item));
    var itemDOM = DomUtil.createDom(itemDiv);
    DomUtil.modifyCSS(itemDOM, this.style[LIST_ITEM_CLASS]);
    var markerDom = find(itemDOM, MARKER_CLASS);

    if (markerDom) {
      DomUtil.modifyCSS(markerDom, _extends({}, this.style[MARKER_CLASS], {
        borderRadius: 'unset'
      }));

      var markerPath = this._getMarkerSvg(item);

      markerDom.innerHTML = markerPath;
    }

    var valueDom = find(itemDOM, VALUE_CLASS);

    if (valueDom) {
      DomUtil.modifyCSS(valueDom, this.style[VALUE_CLASS]);
    }

    return itemDOM;
  };

  _proto._getHtmlContent = function _getHtmlContent() {
    var htmlContent = this.get('htmlContent');
    var title = this.get('titleContent');
    var items = this.get('items');
    var htmlString = htmlContent(title, items);
    var ele = DomUtil.createDom(htmlString);
    return ele;
  };

  _proto.setPosition = function setPosition(x, y, target) {
    var container = this.get('container');
    var outterNode = this.get('canvas').get('el');
    var viewWidth = DomUtil.getWidth(outterNode);
    var viewHeight = DomUtil.getHeight(outterNode);
    var containerWidth = container.clientWidth;
    var containerHeight = container.clientHeight;
    var endx = x;
    var endy = y;
    var position;
    var prePosition = this.get('prePosition') || {
      x: 0,
      y: 0
    }; // @2019-01-30 by blue.lb 鐢变簬display:none鐨勫厓绱犺幏鍙朿lientWidth鍜宑lientHeight鐨勫€间负0锛岃繖閲屽己鍒舵樉闅愪竴涓嬶紝鍏跺疄鐩存帴鍦╯how鍜宧ide涓幓鎺塪isplay璁剧疆鏈€濂斤紝鐚滄祴涓轰簡鏇村ソ鐨勫吋瀹规祻瑙堝櫒

    if (!containerWidth) {
      container.style.display = 'block';
      containerWidth = container.clientWidth;
      containerHeight = container.clientHeight;
      container.style.display = 'none';
    }

    if (this.get('enterable')) {
      y = y - container.clientHeight / 2;
      position = [x, y];

      if (prePosition && x - prePosition.x > 0) {
        // 鐣� 1px 闃叉榧犳爣鐐瑰嚮浜嬩欢鏃犳硶鍦ㄧ敾甯冧笂瑙﹀彂
        x -= container.clientWidth + 1;
      } else {
        x += 1;
      }
    } else if (this.get('position')) {
      // @2019-01-30 by blue.lb 杩欓噷搴旇鏄浣欎唬鐮�
      // const containerWidth = container.clientWidth;
      // const containerHeight = container.clientHeight;
      position = this._calcTooltipPosition(x, y, this.get('position'), containerWidth, containerHeight, target);
      x = position[0];
      y = position[1];
    } else {
      position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);
      x = position[0];
      y = position[1];
    }

    if (this.get('inPlot')) {
      // tooltip 蹇呴』闄愬埗鍦ㄧ粯鍥惧尯鍩熷唴
      var plotRange = this.get('plotRange');
      position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));
      x = position[0];
      y = position[1];
    }

    var markerItems = this.get('markerItems');

    if (!Util.isEmpty(markerItems)) {
      endx = markerItems[0].x;
      endy = markerItems[0].y;
    }

    this.set('prePosition', position); // 璁板綍涓婃鐨勪綅缃�

    var follow = this.get('follow');

    if (follow) {
      container.style.left = x + 'px';
      container.style.top = y + 'px';
    }

    var crosshairGroup = this.get('crosshairGroup');

    if (crosshairGroup) {
      var items = this.get('items');
      crosshairGroup.setPosition(endx, endy, items);
    }

    _Tooltip.prototype.setPosition.call(this, x, y);
  };

  return HtmlTooltip;
}(Tooltip);

module.exports = HtmlTooltip;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var Tooltip = __webpack_require__(68);

Tooltip.Html = __webpack_require__(262);
Tooltip.Canvas = __webpack_require__(115);
Tooltip.Mini = __webpack_require__(264);
module.exports = Tooltip;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(3);

var CanvasTooltip = __webpack_require__(115);

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY;

var DomUtil = Util.DomUtil;
var MatrixUtil = Util.MatrixUtil;

var MiniTooltip =
/*#__PURE__*/
function (_CanvasTooltip) {
  _inheritsLoose(MiniTooltip, _CanvasTooltip);

  function MiniTooltip() {
    return _CanvasTooltip.apply(this, arguments) || this;
  }

  var _proto = MiniTooltip.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _CanvasTooltip.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * 榛樿鑳屾櫙鏉挎牱寮�
       * @type {Object}
       */
      boardStyle: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        // fill: 'rgba(50, 50, 50, 1)',
        radius: 3
      },

      /**
       * 榛樿value鏍峰紡
       * @type {Object}
       * */
      valueStyle: {
        x: 0,
        y: 0,
        text: '',
        fontFamily: FONT_FAMILY,
        fontSize: 12,
        stroke: '#fff',
        lineWidth: 2,
        fill: 'black',
        textBaseline: 'top',
        textAlign: 'start'
      },

      /**
       * 榛樿padding鍊�
       * @type {Object}
       */
      padding: {
        top: 5,
        right: 5,
        bottom: 0,
        left: 5
      },
      triangleWidth: 10,
      triangleHeight: 4
    });
  };

  _proto._init_ = function _init_() {
    var self = this;
    var padding = self.get('padding');
    var parent = self.get('frontPlot'); // container

    var container = parent.addGroup();
    self.set('container', container); // board

    var board = container.addShape('rect', {
      attrs: Util.mix({}, self.get('boardStyle'))
    });
    self.set('board', board); // triangleShpe

    var triangleShape = container.addShape('path', {
      attrs: {
        fill: self.get('boardStyle').fill
      }
    });
    self.set('triangleShape', triangleShape); // itemGroup

    var itemGroup = container.addGroup();
    itemGroup.move(padding.left, padding.top); // value

    var valueShape = itemGroup.addShape('text', {
      attrs: Util.mix({}, self.get('valueStyle'))
    });
    self.set('valueShape', valueShape);
  };

  _proto.render = function render() {
    var self = this;
    self.clear();
    var board = self.get('board');
    var valueShape = self.get('valueShape');
    var padding = self.get('padding');
    var item = self.get('items')[0];

    if (valueShape) {
      valueShape.attr('text', item.value);
    } // update board based on bbox


    var bbox = valueShape ? valueShape.getBBox() : {
      width: 80,
      height: 30
    };
    var width = padding.left + bbox.width + padding.right;
    var height = padding.top + bbox.height + padding.bottom;
    board.attr('width', width);
    board.attr('height', height); // update triangle shape

    self._centerTriangleShape();
  };

  _proto.clear = function clear() {
    var valueShape = this.get('valueShape');
    valueShape.attr('text', '');
  };

  _proto.setPosition = function setPosition(x, y, target) {
    var self = this;
    var container = self.get('container');
    var plotRange = self.get('plotRange');
    var bbox = container.getBBox();
    var width = bbox.width;
    var height = bbox.height;
    x -= width / 2;

    if (target && (target.name === 'point' || target.name === 'interval')) {
      var targetY = target.getBBox().y;
      y = targetY;
    }

    y -= height;

    if (this.get('inPlot')) {
      // constrain in plot
      if (x < plotRange.tl.x) {
        x = plotRange.tl.x;

        self._leftTriangleShape();
      } else if (x + width / 2 > plotRange.tr.x) {
        x = plotRange.tr.x - width;

        self._rightTriangleShape();
      } else {
        self._centerTriangleShape();
      }

      if (y < plotRange.tl.y) {
        y = plotRange.tl.y;
      } else if (y + height > plotRange.bl.y) {
        y = plotRange.bl.y - height;
      }
    } else {
      // constrain in dom
      var outterNode = this.get('canvas').get('el');
      var viewWidth = DomUtil.getWidth(outterNode);
      var viewHeight = DomUtil.getHeight(outterNode);

      if (x < 0) {
        x = 0;

        self._leftTriangleShape();
      } else if (x + width / 2 > viewWidth) {
        x = viewWidth - width;

        self._rightTriangleShape();
      } else {
        self._centerTriangleShape();
      }

      if (y < 0) {
        y = 0;
      } else if (y + height > viewHeight) {
        y = viewHeight - height;
      }
    }

    var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);
    container.stopAnimate();
    container.animate({
      matrix: mat
    }, this.get('animationDuration'));
  };

  _proto._centerTriangleShape = function _centerTriangleShape() {
    var triangle = this.get('triangleShape');
    var width = this.get('triangleWidth');
    var height = this.get('triangleHeight');
    var boardBBox = this.get('board').getBBox();
    var boardWidth = boardBBox.width;
    var boardHeight = boardBBox.height;
    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width / 2, height], ['L', 0, 0], ['Z']];
    triangle.attr('path', pathArray);
    triangle.move(boardWidth / 2 - width / 2, boardHeight - 1);
  };

  _proto._leftTriangleShape = function _leftTriangleShape() {
    var triangle = this.get('triangleShape');
    var width = this.get('triangleWidth');
    var height = this.get('triangleHeight');
    var boardBBox = this.get('board').getBBox();
    var boardHeight = boardBBox.height;
    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', 0, height + 3], ['L', 0, 0], ['Z']];
    triangle.attr('path', pathArray);
    triangle.move(0, boardHeight - 3);
  };

  _proto._rightTriangleShape = function _rightTriangleShape() {
    var triangle = this.get('triangleShape');
    var width = this.get('triangleWidth');
    var height = this.get('triangleHeight');
    var boardBBox = this.get('board').getBBox();
    var boardWidth = boardBBox.width;
    var boardHeight = boardBBox.height;
    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width, height + 4], ['L', 0, 0], ['Z']];
    triangle.attr('path', pathArray);
    triangle.move(boardWidth - width - 1, boardHeight - 4);
  };

  return MiniTooltip;
}(CanvasTooltip);

module.exports = MiniTooltip;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var _TooltipTheme;

var _require = __webpack_require__(19),
    FONT_FAMILY = _require.FONT_FAMILY; // tooltip 鐩稿叧 dom 鐨� css 绫诲悕


var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
var TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';
var TOOLTIP_LIST_CLASS = 'g2-tooltip-list';
var TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';
var TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';
var TOOLTIP_VALUE_CLASS = 'g2-tooltip-value';
var TooltipTheme = (_TooltipTheme = {
  crosshairs: false,
  offset: 15
}, _TooltipTheme["" + TOOLTIP_CONTAINER_CLASS] = {
  position: 'absolute',
  visibility: 'hidden',
  // @2018-07-25 by blue.lb 杩欓噷鍘绘帀娴姩锛岀伀鐙愪笂瀛樺湪鏍峰紡閿欎綅
  // whiteSpace: 'nowrap',
  zIndex: 8,
  transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
  backgroundColor: 'rgba(255, 255, 255, 0.9)',
  boxShadow: '0px 0px 10px #aeaeae',
  borderRadius: '3px',
  color: 'rgb(87, 87, 87)',
  fontSize: '12px',
  fontFamily: FONT_FAMILY,
  lineHeight: '20px',
  padding: '10px 10px 6px 10px'
}, _TooltipTheme["" + TOOLTIP_TITLE_CLASS] = {
  marginBottom: '4px'
}, _TooltipTheme["" + TOOLTIP_LIST_CLASS] = {
  margin: 0,
  listStyleType: 'none',
  padding: 0
}, _TooltipTheme["" + TOOLTIP_LIST_ITEM_CLASS] = {
  marginBottom: '4px'
}, _TooltipTheme["" + TOOLTIP_MARKER_CLASS] = {
  width: '5px',
  height: '5px',
  borderRadius: '50%',
  display: 'inline-block',
  marginRight: '8px'
}, _TooltipTheme["" + TOOLTIP_VALUE_CLASS] = {
  display: 'inline-block',
  float: 'right',
  marginLeft: '30px'
}, _TooltipTheme);
module.exports = TooltipTheme;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @fileOverview the class of Cartesian Coordinate
 * @author sima.zhang
 */
var mix = __webpack_require__(10);

var Base = __webpack_require__(43);

var Cartesian =
/*#__PURE__*/
function (_Base) {
  _inherits(Cartesian, _Base);

  _createClass(Cartesian, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Cartesian.prototype), "getDefaultCfg", this).call(this);

      return mix({}, cfg, {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        },
        type: 'cartesian',
        isRect: true
      });
    }
  }]);

  function Cartesian(cfg) {
    var _this;

    _classCallCheck(this, Cartesian);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Cartesian).call(this, cfg));

    _this._init();

    return _this;
  }

  _createClass(Cartesian, [{
    key: "_init",
    value: function _init() {
      var start = this.start,
          end = this.end;
      var x = {
        start: start.x,
        end: end.x
      };
      var y = {
        start: start.y,
        end: end.y
      };
      this.x = x;
      this.y = y;
    }
  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      var x;
      var y;

      if (this.isTransposed) {
        x = point.y;
        y = point.x;
      } else {
        x = point.x;
        y = point.y;
      }

      return {
        x: this.convertDim(x, 'x'),
        y: this.convertDim(y, 'y')
      };
    }
  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      var x = this.invertDim(point.x, 'x');
      var y = this.invertDim(point.y, 'y');

      if (this.isTransposed) {
        return {
          x: y,
          y: x
        };
      }

      return {
        x: x,
        y: y
      };
    }
  }]);

  return Cartesian;
}(Base);

module.exports = Cartesian;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYXJ0ZXNpYW4uanMiXSwibmFtZXMiOlsibWl4IiwicmVxdWlyZSIsIkJhc2UiLCJDYXJ0ZXNpYW4iLCJjZmciLCJzdGFydCIsIngiLCJ5IiwiZW5kIiwidHlwZSIsImlzUmVjdCIsIl9pbml0IiwicG9pbnQiLCJpc1RyYW5zcG9zZWQiLCJjb252ZXJ0RGltIiwiaW52ZXJ0RGltIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQSxJQUFNQSxHQUFHLEdBQUdDLE9BQU8sQ0FBQyxvQkFBRCxDQUFuQjs7QUFDQSxJQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxRQUFELENBQXBCOztJQUVNRSxTOzs7Ozs7OztBQUVKOzs7b0NBR2dCO0FBQ2QsVUFBTUMsR0FBRywrRUFBVDs7QUFDQSxhQUFPSixHQUFHLENBQUMsRUFBRCxFQUFLSSxHQUFMLEVBQVU7QUFDbEJDLFFBQUFBLEtBQUssRUFBRTtBQUNMQyxVQUFBQSxDQUFDLEVBQUUsQ0FERTtBQUVMQyxVQUFBQSxDQUFDLEVBQUU7QUFGRSxTQURXO0FBS2xCQyxRQUFBQSxHQUFHLEVBQUU7QUFDSEYsVUFBQUEsQ0FBQyxFQUFFLENBREE7QUFFSEMsVUFBQUEsQ0FBQyxFQUFFO0FBRkEsU0FMYTtBQVNsQkUsUUFBQUEsSUFBSSxFQUFFLFdBVFk7QUFVbEJDLFFBQUFBLE1BQU0sRUFBRTtBQVZVLE9BQVYsQ0FBVjtBQVlEOzs7QUFFRCxxQkFBWU4sR0FBWixFQUFpQjtBQUFBOztBQUFBOztBQUNmLG1GQUFNQSxHQUFOOztBQUNBLFVBQUtPLEtBQUw7O0FBRmU7QUFHaEI7Ozs7NEJBRU87QUFBQSxVQUNFTixLQURGLEdBQ2lCLElBRGpCLENBQ0VBLEtBREY7QUFBQSxVQUNTRyxHQURULEdBQ2lCLElBRGpCLENBQ1NBLEdBRFQ7QUFFTixVQUFNRixDQUFDLEdBQUc7QUFDUkQsUUFBQUEsS0FBSyxFQUFFQSxLQUFLLENBQUNDLENBREw7QUFFUkUsUUFBQUEsR0FBRyxFQUFFQSxHQUFHLENBQUNGO0FBRkQsT0FBVjtBQUlBLFVBQU1DLENBQUMsR0FBRztBQUNSRixRQUFBQSxLQUFLLEVBQUVBLEtBQUssQ0FBQ0UsQ0FETDtBQUVSQyxRQUFBQSxHQUFHLEVBQUVBLEdBQUcsQ0FBQ0Q7QUFGRCxPQUFWO0FBSUEsV0FBS0QsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsV0FBS0MsQ0FBTCxHQUFTQSxDQUFUO0FBQ0Q7OztpQ0FFWUssSyxFQUFPO0FBQ2xCLFVBQUlOLENBQUo7QUFDQSxVQUFJQyxDQUFKOztBQUNBLFVBQUksS0FBS00sWUFBVCxFQUF1QjtBQUNyQlAsUUFBQUEsQ0FBQyxHQUFHTSxLQUFLLENBQUNMLENBQVY7QUFDQUEsUUFBQUEsQ0FBQyxHQUFHSyxLQUFLLENBQUNOLENBQVY7QUFDRCxPQUhELE1BR087QUFDTEEsUUFBQUEsQ0FBQyxHQUFHTSxLQUFLLENBQUNOLENBQVY7QUFDQUMsUUFBQUEsQ0FBQyxHQUFHSyxLQUFLLENBQUNMLENBQVY7QUFDRDs7QUFFRCxhQUFPO0FBQ0xELFFBQUFBLENBQUMsRUFBRSxLQUFLUSxVQUFMLENBQWdCUixDQUFoQixFQUFtQixHQUFuQixDQURFO0FBRUxDLFFBQUFBLENBQUMsRUFBRSxLQUFLTyxVQUFMLENBQWdCUCxDQUFoQixFQUFtQixHQUFuQjtBQUZFLE9BQVA7QUFJRDs7O2dDQUVXSyxLLEVBQU87QUFDakIsVUFBTU4sQ0FBQyxHQUFHLEtBQUtTLFNBQUwsQ0FBZUgsS0FBSyxDQUFDTixDQUFyQixFQUF3QixHQUF4QixDQUFWO0FBQ0EsVUFBTUMsQ0FBQyxHQUFHLEtBQUtRLFNBQUwsQ0FBZUgsS0FBSyxDQUFDTCxDQUFyQixFQUF3QixHQUF4QixDQUFWOztBQUVBLFVBQUksS0FBS00sWUFBVCxFQUF1QjtBQUNyQixlQUFPO0FBQ0xQLFVBQUFBLENBQUMsRUFBRUMsQ0FERTtBQUVMQSxVQUFBQSxDQUFDLEVBQUVEO0FBRkUsU0FBUDtBQUlEOztBQUVELGFBQU87QUFDTEEsUUFBQUEsQ0FBQyxFQUFEQSxDQURLO0FBRUxDLFFBQUFBLENBQUMsRUFBREE7QUFGSyxPQUFQO0FBSUQ7Ozs7RUF4RXFCTCxJOztBQTJFeEJjLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmQsU0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgdGhlIGNsYXNzIG9mIENhcnRlc2lhbiBDb29yZGluYXRlXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuY29uc3QgbWl4ID0gcmVxdWlyZSgnQGFudHYvdXRpbC9saWIvbWl4Jyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbmNsYXNzIENhcnRlc2lhbiBleHRlbmRzIEJhc2Uge1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERlZmF1bHRDZmcoKSB7XG4gICAgY29uc3QgY2ZnID0gc3VwZXIuZ2V0RGVmYXVsdENmZygpO1xuICAgIHJldHVybiBtaXgoe30sIGNmZywge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2NhcnRlc2lhbicsXG4gICAgICBpc1JlY3Q6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSB7XG4gICAgICBzdGFydDogc3RhcnQueCxcbiAgICAgIGVuZDogZW5kLnhcbiAgICB9O1xuICAgIGNvbnN0IHkgPSB7XG4gICAgICBzdGFydDogc3RhcnQueSxcbiAgICAgIGVuZDogZW5kLnlcbiAgICB9O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGlmICh0aGlzLmlzVHJhbnNwb3NlZCkge1xuICAgICAgeCA9IHBvaW50Lnk7XG4gICAgICB5ID0gcG9pbnQueDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBvaW50Lng7XG4gICAgICB5ID0gcG9pbnQueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5jb252ZXJ0RGltKHgsICd4JyksXG4gICAgICB5OiB0aGlzLmNvbnZlcnREaW0oeSwgJ3knKVxuICAgIH07XG4gIH1cblxuICBpbnZlcnRQb2ludChwb2ludCkge1xuICAgIGNvbnN0IHggPSB0aGlzLmludmVydERpbShwb2ludC54LCAneCcpO1xuICAgIGNvbnN0IHkgPSB0aGlzLmludmVydERpbShwb2ludC55LCAneScpO1xuXG4gICAgaWYgKHRoaXMuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB5LFxuICAgICAgICB5OiB4XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW47XG4iXX0=

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @fileOverview the class of Helix Coordinate
 * @author sima.zhang
 */
var MatrixUtil = __webpack_require__(56);

var isNumberEqual = __webpack_require__(55);

var mix = __webpack_require__(10);

var Base = __webpack_require__(43);

var vec2 = MatrixUtil.vec2;

var Helix =
/*#__PURE__*/
function (_Base) {
  _inherits(Helix, _Base);

  _createClass(Helix, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Helix.prototype), "getDefaultCfg", this).call(this);

      return mix({}, cfg, {
        startAngle: 1.25 * Math.PI,
        endAngle: 7.25 * Math.PI,
        innerRadius: 0,
        type: 'helix',
        isHelix: true
      });
    }
  }]);

  function Helix(cfg) {
    var _this;

    _classCallCheck(this, Helix);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Helix).call(this, cfg));

    _this._init();

    return _this;
  }

  _createClass(Helix, [{
    key: "_init",
    value: function _init() {
      var width = this.width;
      var height = this.height;
      var radius = this.radius;
      var innerRadius = this.innerRadius;
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      var index = (endAngle - startAngle) / (2 * Math.PI) + 1; // 铻虹嚎鍦堟暟

      var maxRadius = Math.min(width, height) / 2;

      if (radius && radius >= 0 && radius <= 1) {
        maxRadius = maxRadius * radius;
      }

      var d = Math.floor(maxRadius * (1 - innerRadius) / index);
      var a = d / (Math.PI * 2); // 铻虹嚎绯绘暟

      var x = {
        start: startAngle,
        end: endAngle
      };
      var y = {
        start: innerRadius * maxRadius,
        end: innerRadius * maxRadius + d * 0.99
      };
      this.a = a;
      this.d = d;
      this.x = x;
      this.y = y;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
    /**
     * 灏嗙櫨鍒嗘瘮鏁版嵁鍙樻垚灞忓箷鍧愭爣
     * @param  {Object} point 褰掍竴鍖栫殑鐐瑰潗鏍�
     * @return {Object}       杩斿洖瀵瑰簲鐨勫睆骞曞潗鏍�
     */

  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      var a = this.a;
      var center = this.center;
      var x;
      var y;

      if (this.isTransposed) {
        x = point.y;
        y = point.x;
      } else {
        x = point.x;
        y = point.y;
      }

      var thi = this.convertDim(x, 'x');
      var r = a * thi;
      var newY = this.convertDim(y, 'y');
      return {
        x: center.x + Math.cos(thi) * (r + newY),
        y: center.y + Math.sin(thi) * (r + newY)
      };
    }
    /**
     * 灏嗗睆骞曞潗鏍囩偣杩樺師鎴愮櫨鍒嗘瘮鏁版嵁
     * @param  {Object} point 灞忓箷鍧愭爣
     * @return {Object}       杩斿洖瀵瑰簲鐨勫綊涓€鍖栧悗鐨勬暟鎹�
     */

  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      var center = this.center;
      var a = this.a;
      var d = this.d + this.y.start;
      var v = vec2.subtract([], [point.x, point.y], [center.x, center.y]);
      var thi = vec2.angleTo(v, [1, 0], true);
      var rMin = thi * a; // 鍧愭爣涓庡師鐐圭殑杩炵嚎鍦ㄧ涓€鍦堜笂鐨勪氦鐐癸紝鏈€灏弐鍊�

      if (vec2.length(v) < rMin) {
        // 鍧愭爣涓庡師鐐圭殑杩炵嚎涓嶅彲鑳藉皬浜庢渶灏弐鍊硷紝浣嗕笉鎺掗櫎鍥犲皬鏁拌绠椾骇鐢熺殑鐣ュ皬浜巖Min鐨勬儏鍐�
        rMin = vec2.length(v);
      }

      var index = Math.floor((vec2.length(v) - rMin) / d); // 褰撳墠鐐逛綅浜庣index鍦�

      thi = 2 * index * Math.PI + thi;
      var r = a * thi;
      var newY = vec2.length(v) - r;
      newY = isNumberEqual(newY, 0) ? 0 : newY;
      var x = this.invertDim(thi, 'x');
      var y = this.invertDim(newY, 'y');
      x = isNumberEqual(x, 0) ? 0 : x;
      y = isNumberEqual(y, 0) ? 0 : y;
      var rst = {};
      rst.x = this.isTransposed ? y : x;
      rst.y = this.isTransposed ? x : y;
      return rst;
    }
  }]);

  return Helix;
}(Base);

module.exports = Helix;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxpeC5qcyJdLCJuYW1lcyI6WyJNYXRyaXhVdGlsIiwicmVxdWlyZSIsImlzTnVtYmVyRXF1YWwiLCJtaXgiLCJCYXNlIiwidmVjMiIsIkhlbGl4IiwiY2ZnIiwic3RhcnRBbmdsZSIsIk1hdGgiLCJQSSIsImVuZEFuZ2xlIiwiaW5uZXJSYWRpdXMiLCJ0eXBlIiwiaXNIZWxpeCIsIl9pbml0Iiwid2lkdGgiLCJoZWlnaHQiLCJyYWRpdXMiLCJpbmRleCIsIm1heFJhZGl1cyIsIm1pbiIsImQiLCJmbG9vciIsImEiLCJ4Iiwic3RhcnQiLCJlbmQiLCJ5IiwiY2VudGVyIiwicG9pbnQiLCJpc1RyYW5zcG9zZWQiLCJ0aGkiLCJjb252ZXJ0RGltIiwiciIsIm5ld1kiLCJjb3MiLCJzaW4iLCJ2Iiwic3VidHJhY3QiLCJhbmdsZVRvIiwick1pbiIsImxlbmd0aCIsImludmVydERpbSIsInJzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBSUEsSUFBTUEsVUFBVSxHQUFHQyxPQUFPLENBQUMsd0JBQUQsQ0FBMUI7O0FBQ0EsSUFBTUMsYUFBYSxHQUFHRCxPQUFPLENBQUMscUNBQUQsQ0FBN0I7O0FBQ0EsSUFBTUUsR0FBRyxHQUFHRixPQUFPLENBQUMsb0JBQUQsQ0FBbkI7O0FBQ0EsSUFBTUcsSUFBSSxHQUFHSCxPQUFPLENBQUMsUUFBRCxDQUFwQjs7QUFFQSxJQUFNSSxJQUFJLEdBQUdMLFVBQVUsQ0FBQ0ssSUFBeEI7O0lBRU1DLEs7Ozs7Ozs7b0NBRVk7QUFDZCxVQUFNQyxHQUFHLDJFQUFUOztBQUNBLGFBQU9KLEdBQUcsQ0FBQyxFQUFELEVBQUtJLEdBQUwsRUFBVTtBQUNsQkMsUUFBQUEsVUFBVSxFQUFFLE9BQU9DLElBQUksQ0FBQ0MsRUFETjtBQUVsQkMsUUFBQUEsUUFBUSxFQUFFLE9BQU9GLElBQUksQ0FBQ0MsRUFGSjtBQUdsQkUsUUFBQUEsV0FBVyxFQUFFLENBSEs7QUFJbEJDLFFBQUFBLElBQUksRUFBRSxPQUpZO0FBS2xCQyxRQUFBQSxPQUFPLEVBQUU7QUFMUyxPQUFWLENBQVY7QUFPRDs7O0FBRUQsaUJBQVlQLEdBQVosRUFBaUI7QUFBQTs7QUFBQTs7QUFDZiwrRUFBTUEsR0FBTjs7QUFDQSxVQUFLUSxLQUFMOztBQUZlO0FBR2hCOzs7OzRCQUVPO0FBQ04sVUFBTUMsS0FBSyxHQUFHLEtBQUtBLEtBQW5CO0FBQ0EsVUFBTUMsTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBQ0EsVUFBTUMsTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBQ0EsVUFBTU4sV0FBVyxHQUFHLEtBQUtBLFdBQXpCO0FBQ0EsVUFBTUosVUFBVSxHQUFHLEtBQUtBLFVBQXhCO0FBQ0EsVUFBTUcsUUFBUSxHQUFHLEtBQUtBLFFBQXRCO0FBRUEsVUFBTVEsS0FBSyxHQUFHLENBQUNSLFFBQVEsR0FBR0gsVUFBWixLQUEyQixJQUFJQyxJQUFJLENBQUNDLEVBQXBDLElBQTBDLENBQXhELENBUk0sQ0FRcUQ7O0FBQzNELFVBQUlVLFNBQVMsR0FBR1gsSUFBSSxDQUFDWSxHQUFMLENBQVNMLEtBQVQsRUFBZ0JDLE1BQWhCLElBQTBCLENBQTFDOztBQUNBLFVBQUlDLE1BQU0sSUFBSUEsTUFBTSxJQUFJLENBQXBCLElBQXlCQSxNQUFNLElBQUksQ0FBdkMsRUFBMEM7QUFDeENFLFFBQUFBLFNBQVMsR0FBR0EsU0FBUyxHQUFHRixNQUF4QjtBQUNEOztBQUVELFVBQU1JLENBQUMsR0FBR2IsSUFBSSxDQUFDYyxLQUFMLENBQVdILFNBQVMsSUFBSSxJQUFJUixXQUFSLENBQVQsR0FBZ0NPLEtBQTNDLENBQVY7QUFDQSxVQUFNSyxDQUFDLEdBQUdGLENBQUMsSUFBSWIsSUFBSSxDQUFDQyxFQUFMLEdBQVUsQ0FBZCxDQUFYLENBZk0sQ0Flc0I7O0FBRTVCLFVBQU1lLENBQUMsR0FBRztBQUNSQyxRQUFBQSxLQUFLLEVBQUVsQixVQURDO0FBRVJtQixRQUFBQSxHQUFHLEVBQUVoQjtBQUZHLE9BQVY7QUFJQSxVQUFNaUIsQ0FBQyxHQUFHO0FBQ1JGLFFBQUFBLEtBQUssRUFBRWQsV0FBVyxHQUFHUSxTQURiO0FBRVJPLFFBQUFBLEdBQUcsRUFBRWYsV0FBVyxHQUFHUSxTQUFkLEdBQTBCRSxDQUFDLEdBQUc7QUFGM0IsT0FBVjtBQUtBLFdBQUtFLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFdBQUtGLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFdBQUtHLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFdBQUtHLENBQUwsR0FBU0EsQ0FBVDtBQUNEOzs7Z0NBRVc7QUFDVixhQUFPLEtBQUtDLE1BQVo7QUFDRDtBQUVEOzs7Ozs7OztpQ0FLYUMsSyxFQUFPO0FBQ2xCLFVBQU1OLENBQUMsR0FBRyxLQUFLQSxDQUFmO0FBQ0EsVUFBTUssTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBQ0EsVUFBSUosQ0FBSjtBQUNBLFVBQUlHLENBQUo7O0FBRUEsVUFBSSxLQUFLRyxZQUFULEVBQXVCO0FBQ3JCTixRQUFBQSxDQUFDLEdBQUdLLEtBQUssQ0FBQ0YsQ0FBVjtBQUNBQSxRQUFBQSxDQUFDLEdBQUdFLEtBQUssQ0FBQ0wsQ0FBVjtBQUNELE9BSEQsTUFHTztBQUNMQSxRQUFBQSxDQUFDLEdBQUdLLEtBQUssQ0FBQ0wsQ0FBVjtBQUNBRyxRQUFBQSxDQUFDLEdBQUdFLEtBQUssQ0FBQ0YsQ0FBVjtBQUNEOztBQUVELFVBQU1JLEdBQUcsR0FBRyxLQUFLQyxVQUFMLENBQWdCUixDQUFoQixFQUFtQixHQUFuQixDQUFaO0FBQ0EsVUFBTVMsQ0FBQyxHQUFHVixDQUFDLEdBQUdRLEdBQWQ7QUFDQSxVQUFNRyxJQUFJLEdBQUcsS0FBS0YsVUFBTCxDQUFnQkwsQ0FBaEIsRUFBbUIsR0FBbkIsQ0FBYjtBQUVBLGFBQU87QUFDTEgsUUFBQUEsQ0FBQyxFQUFFSSxNQUFNLENBQUNKLENBQVAsR0FBV2hCLElBQUksQ0FBQzJCLEdBQUwsQ0FBU0osR0FBVCxLQUFpQkUsQ0FBQyxHQUFHQyxJQUFyQixDQURUO0FBRUxQLFFBQUFBLENBQUMsRUFBRUMsTUFBTSxDQUFDRCxDQUFQLEdBQVduQixJQUFJLENBQUM0QixHQUFMLENBQVNMLEdBQVQsS0FBaUJFLENBQUMsR0FBR0MsSUFBckI7QUFGVCxPQUFQO0FBSUQ7QUFFRDs7Ozs7Ozs7Z0NBS1lMLEssRUFBTztBQUNqQixVQUFNRCxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFDQSxVQUFNTCxDQUFDLEdBQUcsS0FBS0EsQ0FBZjtBQUNBLFVBQU1GLENBQUMsR0FBRyxLQUFLQSxDQUFMLEdBQVMsS0FBS00sQ0FBTCxDQUFPRixLQUExQjtBQUNBLFVBQU1ZLENBQUMsR0FBR2pDLElBQUksQ0FBQ2tDLFFBQUwsQ0FBYyxFQUFkLEVBQWtCLENBQUVULEtBQUssQ0FBQ0wsQ0FBUixFQUFXSyxLQUFLLENBQUNGLENBQWpCLENBQWxCLEVBQXdDLENBQUVDLE1BQU0sQ0FBQ0osQ0FBVCxFQUFZSSxNQUFNLENBQUNELENBQW5CLENBQXhDLENBQVY7QUFDQSxVQUFJSSxHQUFHLEdBQUczQixJQUFJLENBQUNtQyxPQUFMLENBQWFGLENBQWIsRUFBZ0IsQ0FBRSxDQUFGLEVBQUssQ0FBTCxDQUFoQixFQUEwQixJQUExQixDQUFWO0FBQ0EsVUFBSUcsSUFBSSxHQUFHVCxHQUFHLEdBQUdSLENBQWpCLENBTmlCLENBTUc7O0FBRXBCLFVBQUluQixJQUFJLENBQUNxQyxNQUFMLENBQVlKLENBQVosSUFBaUJHLElBQXJCLEVBQTJCO0FBQUc7QUFDNUJBLFFBQUFBLElBQUksR0FBR3BDLElBQUksQ0FBQ3FDLE1BQUwsQ0FBWUosQ0FBWixDQUFQO0FBQ0Q7O0FBRUQsVUFBTW5CLEtBQUssR0FBR1YsSUFBSSxDQUFDYyxLQUFMLENBQVcsQ0FBQ2xCLElBQUksQ0FBQ3FDLE1BQUwsQ0FBWUosQ0FBWixJQUFpQkcsSUFBbEIsSUFBMEJuQixDQUFyQyxDQUFkLENBWmlCLENBWXNDOztBQUN2RFUsTUFBQUEsR0FBRyxHQUFHLElBQUliLEtBQUosR0FBWVYsSUFBSSxDQUFDQyxFQUFqQixHQUFzQnNCLEdBQTVCO0FBQ0EsVUFBTUUsQ0FBQyxHQUFHVixDQUFDLEdBQUdRLEdBQWQ7QUFDQSxVQUFJRyxJQUFJLEdBQUc5QixJQUFJLENBQUNxQyxNQUFMLENBQVlKLENBQVosSUFBaUJKLENBQTVCO0FBQ0FDLE1BQUFBLElBQUksR0FBR2pDLGFBQWEsQ0FBQ2lDLElBQUQsRUFBTyxDQUFQLENBQWIsR0FBeUIsQ0FBekIsR0FBNkJBLElBQXBDO0FBRUEsVUFBSVYsQ0FBQyxHQUFHLEtBQUtrQixTQUFMLENBQWVYLEdBQWYsRUFBb0IsR0FBcEIsQ0FBUjtBQUNBLFVBQUlKLENBQUMsR0FBRyxLQUFLZSxTQUFMLENBQWVSLElBQWYsRUFBcUIsR0FBckIsQ0FBUjtBQUNBVixNQUFBQSxDQUFDLEdBQUd2QixhQUFhLENBQUN1QixDQUFELEVBQUksQ0FBSixDQUFiLEdBQXNCLENBQXRCLEdBQTBCQSxDQUE5QjtBQUNBRyxNQUFBQSxDQUFDLEdBQUcxQixhQUFhLENBQUMwQixDQUFELEVBQUksQ0FBSixDQUFiLEdBQXNCLENBQXRCLEdBQTBCQSxDQUE5QjtBQUVBLFVBQU1nQixHQUFHLEdBQUcsRUFBWjtBQUNBQSxNQUFBQSxHQUFHLENBQUNuQixDQUFKLEdBQVEsS0FBS00sWUFBTCxHQUFvQkgsQ0FBcEIsR0FBd0JILENBQWhDO0FBQ0FtQixNQUFBQSxHQUFHLENBQUNoQixDQUFKLEdBQVEsS0FBS0csWUFBTCxHQUFvQk4sQ0FBcEIsR0FBd0JHLENBQWhDO0FBQ0EsYUFBT2dCLEdBQVA7QUFDRDs7OztFQW5IaUJ4QyxJOztBQXNIcEJ5QyxNQUFNLENBQUNDLE9BQVAsR0FBaUJ4QyxLQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgY2xhc3Mgb2YgSGVsaXggQ29vcmRpbmF0ZVxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbmNvbnN0IE1hdHJpeFV0aWwgPSByZXF1aXJlKCdAYW50di91dGlsL2xpYi9tYXRyaXgvJyk7XG5jb25zdCBpc051bWJlckVxdWFsID0gcmVxdWlyZSgnQGFudHYvdXRpbC9saWIvbWF0aC9pcy1udW1iZXItZXF1YWwnKTtcbmNvbnN0IG1peCA9IHJlcXVpcmUoJ0BhbnR2L3V0aWwvbGliL21peCcpO1xuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG5jb25zdCB2ZWMyID0gTWF0cml4VXRpbC52ZWMyO1xuXG5jbGFzcyBIZWxpeCBleHRlbmRzIEJhc2Uge1xuXG4gIGdldERlZmF1bHRDZmcoKSB7XG4gICAgY29uc3QgY2ZnID0gc3VwZXIuZ2V0RGVmYXVsdENmZygpO1xuICAgIHJldHVybiBtaXgoe30sIGNmZywge1xuICAgICAgc3RhcnRBbmdsZTogMS4yNSAqIE1hdGguUEksXG4gICAgICBlbmRBbmdsZTogNy4yNSAqIE1hdGguUEksXG4gICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgIHR5cGU6ICdoZWxpeCcsXG4gICAgICBpc0hlbGl4OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHRoaXMuZW5kQW5nbGU7XG5cbiAgICBjb25zdCBpbmRleCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gKDIgKiBNYXRoLlBJKSArIDE7IC8vIOieuue6v+WciOaVsFxuICAgIGxldCBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgaWYgKHJhZGl1cyAmJiByYWRpdXMgPj0gMCAmJiByYWRpdXMgPD0gMSkge1xuICAgICAgbWF4UmFkaXVzID0gbWF4UmFkaXVzICogcmFkaXVzO1xuICAgIH1cblxuICAgIGNvbnN0IGQgPSBNYXRoLmZsb29yKG1heFJhZGl1cyAqICgxIC0gaW5uZXJSYWRpdXMpIC8gaW5kZXgpO1xuICAgIGNvbnN0IGEgPSBkIC8gKE1hdGguUEkgKiAyKTsvLyDonrrnur/ns7vmlbBcblxuICAgIGNvbnN0IHggPSB7XG4gICAgICBzdGFydDogc3RhcnRBbmdsZSxcbiAgICAgIGVuZDogZW5kQW5nbGVcbiAgICB9O1xuICAgIGNvbnN0IHkgPSB7XG4gICAgICBzdGFydDogaW5uZXJSYWRpdXMgKiBtYXhSYWRpdXMsXG4gICAgICBlbmQ6IGlubmVyUmFkaXVzICogbWF4UmFkaXVzICsgZCAqIDAuOTlcbiAgICB9O1xuXG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmQgPSBkO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIGdldENlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXI7XG4gIH1cblxuICAvKipcbiAgICog5bCG55m+5YiG5q+U5pWw5o2u5Y+Y5oiQ5bGP5bmV5Z2Q5qCHXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg5b2S5LiA5YyW55qE54K55Z2Q5qCHXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAg6L+U5Zue5a+55bqU55qE5bGP5bmV5Z2Q5qCHXG4gICAqL1xuICBjb252ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBhID0gdGhpcy5hO1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuXG4gICAgaWYgKHRoaXMuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICB4ID0gcG9pbnQueTtcbiAgICAgIHkgPSBwb2ludC54O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcG9pbnQueDtcbiAgICAgIHkgPSBwb2ludC55O1xuICAgIH1cblxuICAgIGNvbnN0IHRoaSA9IHRoaXMuY29udmVydERpbSh4LCAneCcpO1xuICAgIGNvbnN0IHIgPSBhICogdGhpO1xuICAgIGNvbnN0IG5ld1kgPSB0aGlzLmNvbnZlcnREaW0oeSwgJ3knKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBjZW50ZXIueCArIE1hdGguY29zKHRoaSkgKiAociArIG5ld1kpLFxuICAgICAgeTogY2VudGVyLnkgKyBNYXRoLnNpbih0aGkpICogKHIgKyBuZXdZKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICog5bCG5bGP5bmV5Z2Q5qCH54K56L+Y5Y6f5oiQ55m+5YiG5q+U5pWw5o2uXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg5bGP5bmV5Z2Q5qCHXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAg6L+U5Zue5a+55bqU55qE5b2S5LiA5YyW5ZCO55qE5pWw5o2uXG4gICAqL1xuICBpbnZlcnRQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgZCA9IHRoaXMuZCArIHRoaXMueS5zdGFydDtcbiAgICBjb25zdCB2ID0gdmVjMi5zdWJ0cmFjdChbXSwgWyBwb2ludC54LCBwb2ludC55IF0sIFsgY2VudGVyLngsIGNlbnRlci55IF0pO1xuICAgIGxldCB0aGkgPSB2ZWMyLmFuZ2xlVG8odiwgWyAxLCAwIF0sIHRydWUpO1xuICAgIGxldCByTWluID0gdGhpICogYTsgLy8g5Z2Q5qCH5LiO5Y6f54K555qE6L+e57q/5Zyo56ys5LiA5ZyI5LiK55qE5Lqk54K577yM5pyA5bCPcuWAvFxuXG4gICAgaWYgKHZlYzIubGVuZ3RoKHYpIDwgck1pbikgeyAgLy8g5Z2Q5qCH5LiO5Y6f54K555qE6L+e57q/5LiN5Y+v6IO95bCP5LqO5pyA5bCPcuWAvO+8jOS9huS4jeaOkumZpOWboOWwj+aVsOiuoeeul+S6p+eUn+eahOeVpeWwj+S6jnJNaW7nmoTmg4XlhrVcbiAgICAgIHJNaW4gPSB2ZWMyLmxlbmd0aCh2KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoKHZlYzIubGVuZ3RoKHYpIC0gck1pbikgLyBkKTsgLy8g5b2T5YmN54K55L2N5LqO56ysaW5kZXjlnIhcbiAgICB0aGkgPSAyICogaW5kZXggKiBNYXRoLlBJICsgdGhpO1xuICAgIGNvbnN0IHIgPSBhICogdGhpO1xuICAgIGxldCBuZXdZID0gdmVjMi5sZW5ndGgodikgLSByO1xuICAgIG5ld1kgPSBpc051bWJlckVxdWFsKG5ld1ksIDApID8gMCA6IG5ld1k7XG5cbiAgICBsZXQgeCA9IHRoaXMuaW52ZXJ0RGltKHRoaSwgJ3gnKTtcbiAgICBsZXQgeSA9IHRoaXMuaW52ZXJ0RGltKG5ld1ksICd5Jyk7XG4gICAgeCA9IGlzTnVtYmVyRXF1YWwoeCwgMCkgPyAwIDogeDtcbiAgICB5ID0gaXNOdW1iZXJFcXVhbCh5LCAwKSA/IDAgOiB5O1xuXG4gICAgY29uc3QgcnN0ID0ge307XG4gICAgcnN0LnggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHkgOiB4O1xuICAgIHJzdC55ID0gdGhpcy5pc1RyYW5zcG9zZWQgPyB4IDogeTtcbiAgICByZXR1cm4gcnN0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGVsaXg7XG4iXX0=

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @fileOverview the entry of coordinate
 * @author sima.zhang1990@gmail.com
 */
var Coord = __webpack_require__(43);

Coord.Cartesian = __webpack_require__(266);
Coord.Rect = Coord.Cartesian;
Coord.Polar = __webpack_require__(269);
Coord.Helix = __webpack_require__(267);
module.exports = Coord;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJDb29yZCIsInJlcXVpcmUiLCJDYXJ0ZXNpYW4iLCJSZWN0IiwiUG9sYXIiLCJIZWxpeCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQSxJQUFNQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxRQUFELENBQXJCOztBQUNBRCxLQUFLLENBQUNFLFNBQU4sR0FBa0JELE9BQU8sQ0FBQyxhQUFELENBQXpCO0FBQ0FELEtBQUssQ0FBQ0csSUFBTixHQUFhSCxLQUFLLENBQUNFLFNBQW5CO0FBQ0FGLEtBQUssQ0FBQ0ksS0FBTixHQUFjSCxPQUFPLENBQUMsU0FBRCxDQUFyQjtBQUNBRCxLQUFLLENBQUNLLEtBQU4sR0FBY0osT0FBTyxDQUFDLFNBQUQsQ0FBckI7QUFFQUssTUFBTSxDQUFDQyxPQUFQLEdBQWlCUCxLQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgZW50cnkgb2YgY29vcmRpbmF0ZVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqL1xuY29uc3QgQ29vcmQgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbkNvb3JkLkNhcnRlc2lhbiA9IHJlcXVpcmUoJy4vY2FydGVzaWFuJyk7XG5Db29yZC5SZWN0ID0gQ29vcmQuQ2FydGVzaWFuO1xuQ29vcmQuUG9sYXIgPSByZXF1aXJlKCcuL3BvbGFyJyk7XG5Db29yZC5IZWxpeCA9IHJlcXVpcmUoJy4vaGVsaXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZDtcbiJdfQ==

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @fileOverview the class of Polar Coordinate
 * @author sima.zhang
 */
var MatrixUtil = __webpack_require__(56);

var isNumberEqual = __webpack_require__(55);

var mix = __webpack_require__(10);

var Base = __webpack_require__(43);

var mat3 = MatrixUtil.mat3;
var vec2 = MatrixUtil.vec2;
var vec3 = MatrixUtil.vec3;

var Polar =
/*#__PURE__*/
function (_Base) {
  _inherits(Polar, _Base);

  _createClass(Polar, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Polar.prototype), "getDefaultCfg", this).call(this);

      return mix({}, cfg, {
        startAngle: -Math.PI / 2,
        endAngle: Math.PI * 3 / 2,
        innerRadius: 0,
        type: 'polar',
        isPolar: true
      });
    }
  }]);

  function Polar(cfg) {
    var _this;

    _classCallCheck(this, Polar);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Polar).call(this, cfg));

    _this._init();

    return _this;
  }

  _createClass(Polar, [{
    key: "_init",
    value: function _init() {
      var radius = this.radius;
      var innerRadius = this.innerRadius;
      var center = this.center;
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;

      while (endAngle < startAngle) {
        endAngle += Math.PI * 2;
      }

      this.endAngle = endAngle;
      var oneBox = this.getOneBox();
      var oneWidth = oneBox.maxX - oneBox.minX;
      var oneHeight = oneBox.maxY - oneBox.minY;
      var left = Math.abs(oneBox.minX) / oneWidth;
      var top = Math.abs(oneBox.minY) / oneHeight;
      var width = this.width;
      var height = this.height;
      var maxRadius;
      var circleCentre;

      if (height / oneHeight > width / oneWidth) {
        // width涓轰富
        maxRadius = width / oneWidth;
        circleCentre = {
          x: center.x - (0.5 - left) * width,
          y: center.y - (0.5 - top) * maxRadius * oneHeight
        };
      } else {
        // height涓轰富
        maxRadius = height / oneHeight;
        circleCentre = {
          x: center.x - (0.5 - left) * maxRadius * oneWidth,
          y: center.y - (0.5 - top) * height
        };
      }

      if (!radius) {
        radius = maxRadius;
      } else if (radius > 0 && radius <= 1) {
        radius = maxRadius * radius;
      } else if (radius <= 0 || radius > maxRadius) {
        radius = maxRadius;
      }

      var x = {
        start: startAngle,
        end: endAngle
      };
      var y = {
        start: innerRadius * radius,
        end: radius
      };
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.circleCentre = circleCentre;
      this.center = circleCentre;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.circleCentre;
    }
  }, {
    key: "getOneBox",
    value: function getOneBox() {
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;

      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
        return {
          minX: -1,
          maxX: 1,
          minY: -1,
          maxY: 1
        };
      }

      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];

      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
        xs.push(Math.cos(i));
        ys.push(Math.sin(i));
      }

      return {
        minX: Math.min.apply(Math, xs),
        maxX: Math.max.apply(Math, xs),
        minY: Math.min.apply(Math, ys),
        maxY: Math.max.apply(Math, ys)
      };
    }
  }, {
    key: "getRadius",
    value: function getRadius() {
      return this.radius;
    }
  }, {
    key: "convertPoint",
    value: function convertPoint(point) {
      var center = this.getCenter();
      var x = this.isTransposed ? point.y : point.x;
      var y = this.isTransposed ? point.x : point.y;
      x = this.convertDim(x, 'x');
      y = this.convertDim(y, 'y');
      return {
        x: center.x + Math.cos(x) * y,
        y: center.y + Math.sin(x) * y
      };
    }
  }, {
    key: "invertPoint",
    value: function invertPoint(point) {
      var center = this.getCenter();
      var vPoint = [point.x - center.x, point.y - center.y];
      var x = this.x;
      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      mat3.rotate(m, m, x.start);
      var vStart = [1, 0, 0];
      vec3.transformMat3(vStart, vStart, m);
      vStart = [vStart[0], vStart[1]];
      var angle = vec2.angleTo(vStart, vPoint, x.end < x.start);

      if (isNumberEqual(angle, Math.PI * 2)) {
        angle = 0;
      }

      var radius = vec2.length(vPoint);
      var xPercent = angle / (x.end - x.start);
      xPercent = x.end - x.start > 0 ? xPercent : -xPercent;
      var yPercent = this.invertDim(radius, 'y');
      var rst = {};
      rst.x = this.isTransposed ? yPercent : xPercent;
      rst.y = this.isTransposed ? xPercent : yPercent;
      return rst;
    }
  }]);

  return Polar;
}(Base);

module.exports = Polar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wb2xhci5qcyJdLCJuYW1lcyI6WyJNYXRyaXhVdGlsIiwicmVxdWlyZSIsImlzTnVtYmVyRXF1YWwiLCJtaXgiLCJCYXNlIiwibWF0MyIsInZlYzIiLCJ2ZWMzIiwiUG9sYXIiLCJjZmciLCJzdGFydEFuZ2xlIiwiTWF0aCIsIlBJIiwiZW5kQW5nbGUiLCJpbm5lclJhZGl1cyIsInR5cGUiLCJpc1BvbGFyIiwiX2luaXQiLCJyYWRpdXMiLCJjZW50ZXIiLCJvbmVCb3giLCJnZXRPbmVCb3giLCJvbmVXaWR0aCIsIm1heFgiLCJtaW5YIiwib25lSGVpZ2h0IiwibWF4WSIsIm1pblkiLCJsZWZ0IiwiYWJzIiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJtYXhSYWRpdXMiLCJjaXJjbGVDZW50cmUiLCJ4IiwieSIsInN0YXJ0IiwiZW5kIiwieHMiLCJjb3MiLCJ5cyIsInNpbiIsImkiLCJtaW4iLCJtYXgiLCJwdXNoIiwiYXBwbHkiLCJwb2ludCIsImdldENlbnRlciIsImlzVHJhbnNwb3NlZCIsImNvbnZlcnREaW0iLCJ2UG9pbnQiLCJtIiwicm90YXRlIiwidlN0YXJ0IiwidHJhbnNmb3JtTWF0MyIsImFuZ2xlIiwiYW5nbGVUbyIsImxlbmd0aCIsInhQZXJjZW50IiwieVBlcmNlbnQiLCJpbnZlcnREaW0iLCJyc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUlBLElBQU1BLFVBQVUsR0FBR0MsT0FBTyxDQUFDLHdCQUFELENBQTFCOztBQUNBLElBQU1DLGFBQWEsR0FBR0QsT0FBTyxDQUFDLHFDQUFELENBQTdCOztBQUNBLElBQU1FLEdBQUcsR0FBR0YsT0FBTyxDQUFDLG9CQUFELENBQW5COztBQUNBLElBQU1HLElBQUksR0FBR0gsT0FBTyxDQUFDLFFBQUQsQ0FBcEI7O0FBRUEsSUFBTUksSUFBSSxHQUFHTCxVQUFVLENBQUNLLElBQXhCO0FBQ0EsSUFBTUMsSUFBSSxHQUFHTixVQUFVLENBQUNNLElBQXhCO0FBQ0EsSUFBTUMsSUFBSSxHQUFHUCxVQUFVLENBQUNPLElBQXhCOztJQUVNQyxLOzs7Ozs7O29DQUVZO0FBQ2QsVUFBTUMsR0FBRywyRUFBVDs7QUFDQSxhQUFPTixHQUFHLENBQUMsRUFBRCxFQUFLTSxHQUFMLEVBQVU7QUFDbEJDLFFBQUFBLFVBQVUsRUFBRSxDQUFDQyxJQUFJLENBQUNDLEVBQU4sR0FBVyxDQURMO0FBRWxCQyxRQUFBQSxRQUFRLEVBQUVGLElBQUksQ0FBQ0MsRUFBTCxHQUFVLENBQVYsR0FBYyxDQUZOO0FBR2xCRSxRQUFBQSxXQUFXLEVBQUUsQ0FISztBQUlsQkMsUUFBQUEsSUFBSSxFQUFFLE9BSlk7QUFLbEJDLFFBQUFBLE9BQU8sRUFBRTtBQUxTLE9BQVYsQ0FBVjtBQU9EOzs7QUFFRCxpQkFBWVAsR0FBWixFQUFpQjtBQUFBOztBQUFBOztBQUNmLCtFQUFNQSxHQUFOOztBQUNBLFVBQUtRLEtBQUw7O0FBRmU7QUFHaEI7Ozs7NEJBRU87QUFDTixVQUFJQyxNQUFNLEdBQUcsS0FBS0EsTUFBbEI7QUFDQSxVQUFNSixXQUFXLEdBQUcsS0FBS0EsV0FBekI7QUFDQSxVQUFNSyxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFDQSxVQUFNVCxVQUFVLEdBQUcsS0FBS0EsVUFBeEI7QUFFQSxVQUFJRyxRQUFRLEdBQUcsS0FBS0EsUUFBcEI7O0FBQ0EsYUFBT0EsUUFBUSxHQUFHSCxVQUFsQixFQUE4QjtBQUM1QkcsUUFBQUEsUUFBUSxJQUFLRixJQUFJLENBQUNDLEVBQUwsR0FBVSxDQUF2QjtBQUNEOztBQUNELFdBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsVUFBTU8sTUFBTSxHQUFHLEtBQUtDLFNBQUwsRUFBZjtBQUVBLFVBQU1DLFFBQVEsR0FBR0YsTUFBTSxDQUFDRyxJQUFQLEdBQWNILE1BQU0sQ0FBQ0ksSUFBdEM7QUFDQSxVQUFNQyxTQUFTLEdBQUdMLE1BQU0sQ0FBQ00sSUFBUCxHQUFjTixNQUFNLENBQUNPLElBQXZDO0FBQ0EsVUFBTUMsSUFBSSxHQUFHakIsSUFBSSxDQUFDa0IsR0FBTCxDQUFTVCxNQUFNLENBQUNJLElBQWhCLElBQXdCRixRQUFyQztBQUNBLFVBQU1RLEdBQUcsR0FBR25CLElBQUksQ0FBQ2tCLEdBQUwsQ0FBU1QsTUFBTSxDQUFDTyxJQUFoQixJQUF3QkYsU0FBcEM7QUFDQSxVQUFNTSxLQUFLLEdBQUcsS0FBS0EsS0FBbkI7QUFDQSxVQUFNQyxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFDQSxVQUFJQyxTQUFKO0FBQ0EsVUFBSUMsWUFBSjs7QUFDQSxVQUFLRixNQUFNLEdBQUdQLFNBQVYsR0FBd0JNLEtBQUssR0FBR1QsUUFBcEMsRUFBK0M7QUFBRTtBQUMvQ1csUUFBQUEsU0FBUyxHQUFHRixLQUFLLEdBQUdULFFBQXBCO0FBQ0FZLFFBQUFBLFlBQVksR0FBRztBQUNiQyxVQUFBQSxDQUFDLEVBQUVoQixNQUFNLENBQUNnQixDQUFQLEdBQVcsQ0FBQyxNQUFNUCxJQUFQLElBQWVHLEtBRGhCO0FBRWJLLFVBQUFBLENBQUMsRUFBRWpCLE1BQU0sQ0FBQ2lCLENBQVAsR0FBVyxDQUFDLE1BQU1OLEdBQVAsSUFBY0csU0FBZCxHQUEwQlI7QUFGM0IsU0FBZjtBQUlELE9BTkQsTUFNTztBQUFFO0FBQ1BRLFFBQUFBLFNBQVMsR0FBR0QsTUFBTSxHQUFHUCxTQUFyQjtBQUNBUyxRQUFBQSxZQUFZLEdBQUc7QUFDYkMsVUFBQUEsQ0FBQyxFQUFFaEIsTUFBTSxDQUFDZ0IsQ0FBUCxHQUFXLENBQUMsTUFBTVAsSUFBUCxJQUFlSyxTQUFmLEdBQTJCWCxRQUQ1QjtBQUViYyxVQUFBQSxDQUFDLEVBQUVqQixNQUFNLENBQUNpQixDQUFQLEdBQVcsQ0FBQyxNQUFNTixHQUFQLElBQWNFO0FBRmYsU0FBZjtBQUlEOztBQUVELFVBQUksQ0FBQ2QsTUFBTCxFQUFhO0FBQ1hBLFFBQUFBLE1BQU0sR0FBR2UsU0FBVDtBQUNELE9BRkQsTUFFTyxJQUFJZixNQUFNLEdBQUcsQ0FBVCxJQUFjQSxNQUFNLElBQUksQ0FBNUIsRUFBK0I7QUFDcENBLFFBQUFBLE1BQU0sR0FBR2UsU0FBUyxHQUFHZixNQUFyQjtBQUNELE9BRk0sTUFFQSxJQUFJQSxNQUFNLElBQUksQ0FBVixJQUFlQSxNQUFNLEdBQUdlLFNBQTVCLEVBQXVDO0FBQzVDZixRQUFBQSxNQUFNLEdBQUdlLFNBQVQ7QUFDRDs7QUFFRCxVQUFNRSxDQUFDLEdBQUc7QUFDUkUsUUFBQUEsS0FBSyxFQUFFM0IsVUFEQztBQUVSNEIsUUFBQUEsR0FBRyxFQUFFekI7QUFGRyxPQUFWO0FBS0EsVUFBTXVCLENBQUMsR0FBRztBQUNSQyxRQUFBQSxLQUFLLEVBQUV2QixXQUFXLEdBQUdJLE1BRGI7QUFFUm9CLFFBQUFBLEdBQUcsRUFBRXBCO0FBRkcsT0FBVjtBQUtBLFdBQUtpQixDQUFMLEdBQVNBLENBQVQ7QUFDQSxXQUFLQyxDQUFMLEdBQVNBLENBQVQ7QUFDQSxXQUFLbEIsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsV0FBS2dCLFlBQUwsR0FBb0JBLFlBQXBCO0FBQ0EsV0FBS2YsTUFBTCxHQUFjZSxZQUFkO0FBQ0Q7OztnQ0FFVztBQUNWLGFBQU8sS0FBS0EsWUFBWjtBQUNEOzs7Z0NBRVc7QUFDVixVQUFNeEIsVUFBVSxHQUFHLEtBQUtBLFVBQXhCO0FBQ0EsVUFBTUcsUUFBUSxHQUFHLEtBQUtBLFFBQXRCOztBQUNBLFVBQUlGLElBQUksQ0FBQ2tCLEdBQUwsQ0FBU2hCLFFBQVEsR0FBR0gsVUFBcEIsS0FBbUNDLElBQUksQ0FBQ0MsRUFBTCxHQUFVLENBQWpELEVBQW9EO0FBQ2xELGVBQU87QUFDTFksVUFBQUEsSUFBSSxFQUFFLENBQUMsQ0FERjtBQUVMRCxVQUFBQSxJQUFJLEVBQUUsQ0FGRDtBQUdMSSxVQUFBQSxJQUFJLEVBQUUsQ0FBQyxDQUhGO0FBSUxELFVBQUFBLElBQUksRUFBRTtBQUpELFNBQVA7QUFNRDs7QUFDRCxVQUFNYSxFQUFFLEdBQUcsQ0FBRSxDQUFGLEVBQUs1QixJQUFJLENBQUM2QixHQUFMLENBQVM5QixVQUFULENBQUwsRUFBMkJDLElBQUksQ0FBQzZCLEdBQUwsQ0FBUzNCLFFBQVQsQ0FBM0IsQ0FBWDtBQUNBLFVBQU00QixFQUFFLEdBQUcsQ0FBRSxDQUFGLEVBQUs5QixJQUFJLENBQUMrQixHQUFMLENBQVNoQyxVQUFULENBQUwsRUFBMkJDLElBQUksQ0FBQytCLEdBQUwsQ0FBUzdCLFFBQVQsQ0FBM0IsQ0FBWDs7QUFFQSxXQUFLLElBQUk4QixDQUFDLEdBQUdoQyxJQUFJLENBQUNpQyxHQUFMLENBQVNsQyxVQUFULEVBQXFCRyxRQUFyQixDQUFiLEVBQTZDOEIsQ0FBQyxHQUFHaEMsSUFBSSxDQUFDa0MsR0FBTCxDQUFTbkMsVUFBVCxFQUFxQkcsUUFBckIsQ0FBakQsRUFBaUY4QixDQUFDLElBQUloQyxJQUFJLENBQUNDLEVBQUwsR0FBVSxFQUFoRyxFQUFvRztBQUNsRzJCLFFBQUFBLEVBQUUsQ0FBQ08sSUFBSCxDQUFRbkMsSUFBSSxDQUFDNkIsR0FBTCxDQUFTRyxDQUFULENBQVI7QUFDQUYsUUFBQUEsRUFBRSxDQUFDSyxJQUFILENBQVFuQyxJQUFJLENBQUMrQixHQUFMLENBQVNDLENBQVQsQ0FBUjtBQUNEOztBQUVELGFBQU87QUFDTG5CLFFBQUFBLElBQUksRUFBRWIsSUFBSSxDQUFDaUMsR0FBTCxDQUFTRyxLQUFULENBQWVwQyxJQUFmLEVBQXFCNEIsRUFBckIsQ0FERDtBQUVMaEIsUUFBQUEsSUFBSSxFQUFFWixJQUFJLENBQUNrQyxHQUFMLENBQVNFLEtBQVQsQ0FBZXBDLElBQWYsRUFBcUI0QixFQUFyQixDQUZEO0FBR0xaLFFBQUFBLElBQUksRUFBRWhCLElBQUksQ0FBQ2lDLEdBQUwsQ0FBU0csS0FBVCxDQUFlcEMsSUFBZixFQUFxQjhCLEVBQXJCLENBSEQ7QUFJTGYsUUFBQUEsSUFBSSxFQUFFZixJQUFJLENBQUNrQyxHQUFMLENBQVNFLEtBQVQsQ0FBZXBDLElBQWYsRUFBcUI4QixFQUFyQjtBQUpELE9BQVA7QUFNRDs7O2dDQUVXO0FBQ1YsYUFBTyxLQUFLdkIsTUFBWjtBQUNEOzs7aUNBRVk4QixLLEVBQU87QUFDbEIsVUFBTTdCLE1BQU0sR0FBRyxLQUFLOEIsU0FBTCxFQUFmO0FBQ0EsVUFBSWQsQ0FBQyxHQUFHLEtBQUtlLFlBQUwsR0FBb0JGLEtBQUssQ0FBQ1osQ0FBMUIsR0FBOEJZLEtBQUssQ0FBQ2IsQ0FBNUM7QUFDQSxVQUFJQyxDQUFDLEdBQUcsS0FBS2MsWUFBTCxHQUFvQkYsS0FBSyxDQUFDYixDQUExQixHQUE4QmEsS0FBSyxDQUFDWixDQUE1QztBQUVBRCxNQUFBQSxDQUFDLEdBQUcsS0FBS2dCLFVBQUwsQ0FBZ0JoQixDQUFoQixFQUFtQixHQUFuQixDQUFKO0FBQ0FDLE1BQUFBLENBQUMsR0FBRyxLQUFLZSxVQUFMLENBQWdCZixDQUFoQixFQUFtQixHQUFuQixDQUFKO0FBRUEsYUFBTztBQUNMRCxRQUFBQSxDQUFDLEVBQUVoQixNQUFNLENBQUNnQixDQUFQLEdBQVd4QixJQUFJLENBQUM2QixHQUFMLENBQVNMLENBQVQsSUFBY0MsQ0FEdkI7QUFFTEEsUUFBQUEsQ0FBQyxFQUFFakIsTUFBTSxDQUFDaUIsQ0FBUCxHQUFXekIsSUFBSSxDQUFDK0IsR0FBTCxDQUFTUCxDQUFULElBQWNDO0FBRnZCLE9BQVA7QUFJRDs7O2dDQUVXWSxLLEVBQU87QUFDakIsVUFBTTdCLE1BQU0sR0FBRyxLQUFLOEIsU0FBTCxFQUFmO0FBQ0EsVUFBTUcsTUFBTSxHQUFHLENBQUVKLEtBQUssQ0FBQ2IsQ0FBTixHQUFVaEIsTUFBTSxDQUFDZ0IsQ0FBbkIsRUFBc0JhLEtBQUssQ0FBQ1osQ0FBTixHQUFVakIsTUFBTSxDQUFDaUIsQ0FBdkMsQ0FBZjtBQUNBLFVBQU1ELENBQUMsR0FBRyxLQUFLQSxDQUFmO0FBQ0EsVUFBTWtCLENBQUMsR0FBRyxDQUFFLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBQVY7QUFDQWhELE1BQUFBLElBQUksQ0FBQ2lELE1BQUwsQ0FBWUQsQ0FBWixFQUFlQSxDQUFmLEVBQWtCbEIsQ0FBQyxDQUFDRSxLQUFwQjtBQUVBLFVBQUlrQixNQUFNLEdBQUcsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FBYjtBQUNBaEQsTUFBQUEsSUFBSSxDQUFDaUQsYUFBTCxDQUFtQkQsTUFBbkIsRUFBMkJBLE1BQTNCLEVBQW1DRixDQUFuQztBQUNBRSxNQUFBQSxNQUFNLEdBQUcsQ0FBRUEsTUFBTSxDQUFDLENBQUQsQ0FBUixFQUFhQSxNQUFNLENBQUMsQ0FBRCxDQUFuQixDQUFUO0FBQ0EsVUFBSUUsS0FBSyxHQUFHbkQsSUFBSSxDQUFDb0QsT0FBTCxDQUFhSCxNQUFiLEVBQXFCSCxNQUFyQixFQUE2QmpCLENBQUMsQ0FBQ0csR0FBRixHQUFRSCxDQUFDLENBQUNFLEtBQXZDLENBQVo7O0FBQ0EsVUFBSW5DLGFBQWEsQ0FBQ3VELEtBQUQsRUFBUTlDLElBQUksQ0FBQ0MsRUFBTCxHQUFVLENBQWxCLENBQWpCLEVBQXVDO0FBQ3JDNkMsUUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRDs7QUFDRCxVQUFNdkMsTUFBTSxHQUFHWixJQUFJLENBQUNxRCxNQUFMLENBQVlQLE1BQVosQ0FBZjtBQUVBLFVBQUlRLFFBQVEsR0FBR0gsS0FBSyxJQUFJdEIsQ0FBQyxDQUFDRyxHQUFGLEdBQVFILENBQUMsQ0FBQ0UsS0FBZCxDQUFwQjtBQUNBdUIsTUFBQUEsUUFBUSxHQUFHekIsQ0FBQyxDQUFDRyxHQUFGLEdBQVFILENBQUMsQ0FBQ0UsS0FBVixHQUFrQixDQUFsQixHQUFzQnVCLFFBQXRCLEdBQWlDLENBQUNBLFFBQTdDO0FBRUEsVUFBTUMsUUFBUSxHQUFHLEtBQUtDLFNBQUwsQ0FBZTVDLE1BQWYsRUFBdUIsR0FBdkIsQ0FBakI7QUFDQSxVQUFNNkMsR0FBRyxHQUFHLEVBQVo7QUFDQUEsTUFBQUEsR0FBRyxDQUFDNUIsQ0FBSixHQUFRLEtBQUtlLFlBQUwsR0FBb0JXLFFBQXBCLEdBQStCRCxRQUF2QztBQUNBRyxNQUFBQSxHQUFHLENBQUMzQixDQUFKLEdBQVEsS0FBS2MsWUFBTCxHQUFvQlUsUUFBcEIsR0FBK0JDLFFBQXZDO0FBQ0EsYUFBT0UsR0FBUDtBQUNEOzs7O0VBdkppQjNELEk7O0FBMEpwQjRELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQnpELEtBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHRoZSBjbGFzcyBvZiBQb2xhciBDb29yZGluYXRlXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuY29uc3QgTWF0cml4VXRpbCA9IHJlcXVpcmUoJ0BhbnR2L3V0aWwvbGliL21hdHJpeC8nKTtcbmNvbnN0IGlzTnVtYmVyRXF1YWwgPSByZXF1aXJlKCdAYW50di91dGlsL2xpYi9tYXRoL2lzLW51bWJlci1lcXVhbCcpO1xuY29uc3QgbWl4ID0gcmVxdWlyZSgnQGFudHYvdXRpbC9saWIvbWl4Jyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbmNvbnN0IG1hdDMgPSBNYXRyaXhVdGlsLm1hdDM7XG5jb25zdCB2ZWMyID0gTWF0cml4VXRpbC52ZWMyO1xuY29uc3QgdmVjMyA9IE1hdHJpeFV0aWwudmVjMztcblxuY2xhc3MgUG9sYXIgZXh0ZW5kcyBCYXNlIHtcblxuICBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIGNvbnN0IGNmZyA9IHN1cGVyLmdldERlZmF1bHRDZmcoKTtcbiAgICByZXR1cm4gbWl4KHt9LCBjZmcsIHtcbiAgICAgIHN0YXJ0QW5nbGU6IC1NYXRoLlBJIC8gMixcbiAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMyAvIDIsXG4gICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgIHR5cGU6ICdwb2xhcicsXG4gICAgICBpc1BvbGFyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIGxldCByYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcblxuICAgIGxldCBlbmRBbmdsZSA9IHRoaXMuZW5kQW5nbGU7XG4gICAgd2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuICAgICAgZW5kQW5nbGUgKz0gKE1hdGguUEkgKiAyKTtcbiAgICB9XG4gICAgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIGNvbnN0IG9uZUJveCA9IHRoaXMuZ2V0T25lQm94KCk7XG5cbiAgICBjb25zdCBvbmVXaWR0aCA9IG9uZUJveC5tYXhYIC0gb25lQm94Lm1pblg7XG4gICAgY29uc3Qgb25lSGVpZ2h0ID0gb25lQm94Lm1heFkgLSBvbmVCb3gubWluWTtcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMob25lQm94Lm1pblgpIC8gb25lV2lkdGg7XG4gICAgY29uc3QgdG9wID0gTWF0aC5hYnMob25lQm94Lm1pblkpIC8gb25lSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBsZXQgbWF4UmFkaXVzO1xuICAgIGxldCBjaXJjbGVDZW50cmU7XG4gICAgaWYgKChoZWlnaHQgLyBvbmVIZWlnaHQpID4gKHdpZHRoIC8gb25lV2lkdGgpKSB7IC8vIHdpZHRo5Li65Li7XG4gICAgICBtYXhSYWRpdXMgPSB3aWR0aCAvIG9uZVdpZHRoO1xuICAgICAgY2lyY2xlQ2VudHJlID0ge1xuICAgICAgICB4OiBjZW50ZXIueCAtICgwLjUgLSBsZWZ0KSAqIHdpZHRoLFxuICAgICAgICB5OiBjZW50ZXIueSAtICgwLjUgLSB0b3ApICogbWF4UmFkaXVzICogb25lSGVpZ2h0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7IC8vIGhlaWdodOS4uuS4u1xuICAgICAgbWF4UmFkaXVzID0gaGVpZ2h0IC8gb25lSGVpZ2h0O1xuICAgICAgY2lyY2xlQ2VudHJlID0ge1xuICAgICAgICB4OiBjZW50ZXIueCAtICgwLjUgLSBsZWZ0KSAqIG1heFJhZGl1cyAqIG9uZVdpZHRoLFxuICAgICAgICB5OiBjZW50ZXIueSAtICgwLjUgLSB0b3ApICogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghcmFkaXVzKSB7XG4gICAgICByYWRpdXMgPSBtYXhSYWRpdXM7XG4gICAgfSBlbHNlIGlmIChyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSAxKSB7XG4gICAgICByYWRpdXMgPSBtYXhSYWRpdXMgKiByYWRpdXM7XG4gICAgfSBlbHNlIGlmIChyYWRpdXMgPD0gMCB8fCByYWRpdXMgPiBtYXhSYWRpdXMpIHtcbiAgICAgIHJhZGl1cyA9IG1heFJhZGl1cztcbiAgICB9XG5cbiAgICBjb25zdCB4ID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0QW5nbGUsXG4gICAgICBlbmQ6IGVuZEFuZ2xlXG4gICAgfTtcblxuICAgIGNvbnN0IHkgPSB7XG4gICAgICBzdGFydDogaW5uZXJSYWRpdXMgKiByYWRpdXMsXG4gICAgICBlbmQ6IHJhZGl1c1xuICAgIH07XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5jaXJjbGVDZW50cmUgPSBjaXJjbGVDZW50cmU7XG4gICAgdGhpcy5jZW50ZXIgPSBjaXJjbGVDZW50cmU7XG4gIH1cblxuICBnZXRDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlQ2VudHJlO1xuICB9XG5cbiAgZ2V0T25lQm94KCkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0QW5nbGU7XG4gICAgY29uc3QgZW5kQW5nbGUgPSB0aGlzLmVuZEFuZ2xlO1xuICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID49IE1hdGguUEkgKiAyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiAtMSxcbiAgICAgICAgbWF4WDogMSxcbiAgICAgICAgbWluWTogLTEsXG4gICAgICAgIG1heFk6IDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHhzID0gWyAwLCBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgTWF0aC5jb3MoZW5kQW5nbGUpIF07XG4gICAgY29uc3QgeXMgPSBbIDAsIE1hdGguc2luKHN0YXJ0QW5nbGUpLCBNYXRoLnNpbihlbmRBbmdsZSkgXTtcblxuICAgIGZvciAobGV0IGkgPSBNYXRoLm1pbihzdGFydEFuZ2xlLCBlbmRBbmdsZSk7IGkgPCBNYXRoLm1heChzdGFydEFuZ2xlLCBlbmRBbmdsZSk7IGkgKz0gTWF0aC5QSSAvIDE4KSB7XG4gICAgICB4cy5wdXNoKE1hdGguY29zKGkpKTtcbiAgICAgIHlzLnB1c2goTWF0aC5zaW4oaSkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4cyksXG4gICAgICBtYXhYOiBNYXRoLm1heC5hcHBseShNYXRoLCB4cyksXG4gICAgICBtaW5ZOiBNYXRoLm1pbi5hcHBseShNYXRoLCB5cyksXG4gICAgICBtYXhZOiBNYXRoLm1heC5hcHBseShNYXRoLCB5cylcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cztcbiAgfVxuXG4gIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgbGV0IHggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHBvaW50LnkgOiBwb2ludC54O1xuICAgIGxldCB5ID0gdGhpcy5pc1RyYW5zcG9zZWQgPyBwb2ludC54IDogcG9pbnQueTtcblxuICAgIHggPSB0aGlzLmNvbnZlcnREaW0oeCwgJ3gnKTtcbiAgICB5ID0gdGhpcy5jb252ZXJ0RGltKHksICd5Jyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogY2VudGVyLnggKyBNYXRoLmNvcyh4KSAqIHksXG4gICAgICB5OiBjZW50ZXIueSArIE1hdGguc2luKHgpICogeVxuICAgIH07XG4gIH1cblxuICBpbnZlcnRQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3QgdlBvaW50ID0gWyBwb2ludC54IC0gY2VudGVyLngsIHBvaW50LnkgLSBjZW50ZXIueSBdO1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgbSA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuICAgIG1hdDMucm90YXRlKG0sIG0sIHguc3RhcnQpO1xuXG4gICAgbGV0IHZTdGFydCA9IFsgMSwgMCwgMCBdO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0Myh2U3RhcnQsIHZTdGFydCwgbSk7XG4gICAgdlN0YXJ0ID0gWyB2U3RhcnRbMF0sIHZTdGFydFsxXSBdO1xuICAgIGxldCBhbmdsZSA9IHZlYzIuYW5nbGVUbyh2U3RhcnQsIHZQb2ludCwgeC5lbmQgPCB4LnN0YXJ0KTtcbiAgICBpZiAoaXNOdW1iZXJFcXVhbChhbmdsZSwgTWF0aC5QSSAqIDIpKSB7XG4gICAgICBhbmdsZSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZlYzIubGVuZ3RoKHZQb2ludCk7XG5cbiAgICBsZXQgeFBlcmNlbnQgPSBhbmdsZSAvICh4LmVuZCAtIHguc3RhcnQpO1xuICAgIHhQZXJjZW50ID0geC5lbmQgLSB4LnN0YXJ0ID4gMCA/IHhQZXJjZW50IDogLXhQZXJjZW50O1xuXG4gICAgY29uc3QgeVBlcmNlbnQgPSB0aGlzLmludmVydERpbShyYWRpdXMsICd5Jyk7XG4gICAgY29uc3QgcnN0ID0ge307XG4gICAgcnN0LnggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHlQZXJjZW50IDogeFBlcmNlbnQ7XG4gICAgcnN0LnkgPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHhQZXJjZW50IDogeVBlcmNlbnQ7XG4gICAgcmV0dXJuIHJzdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGFyO1xuIl19

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Default animation funciton
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var G = __webpack_require__(16);

var PathUtil = Util.PathUtil;

function getClip(coord) {
  var start = coord.start;
  var end = coord.end;
  var width = coord.getWidth();
  var height = coord.getHeight();
  var margin = 200;
  var startAngle;
  var endAngle;
  var center;
  var radius;
  var clip;

  if (coord.isPolar) {
    radius = coord.getRadius();
    center = coord.getCenter();
    startAngle = coord.startAngle;
    endAngle = coord.endAngle;
    clip = new G.Fan({
      attrs: {
        x: center.x,
        y: center.y,
        rs: 0,
        re: radius + margin,
        startAngle: startAngle,
        endAngle: startAngle
      }
    });
    clip.endState = {
      endAngle: endAngle
    };
  } else {
    clip = new G.Rect({
      attrs: {
        x: start.x - margin,
        y: end.y - margin,
        width: coord.isTransposed ? width + margin * 2 : 0,
        height: coord.isTransposed ? 0 : height + margin * 2
      }
    });

    if (coord.isTransposed) {
      clip.endState = {
        height: height + margin * 2
      };
    } else {
      clip.endState = {
        width: width + margin * 2
      };
    }
  }

  clip.isClip = true;
  return clip;
} // 鑾峰彇鍥惧舰鐨勫寘鍥寸洅


function getPointsBox(points) {
  if (Util.isEmpty(points)) {
    return null;
  }

  var minX = points[0].x;
  var maxX = points[0].x;
  var minY = points[0].y;
  var maxY = points[0].y;
  Util.each(points, function (point) {
    minX = minX > point.x ? point.x : minX;
    maxX = maxX < point.x ? point.x : maxX;
    minY = minY > point.y ? point.y : minY;
    maxY = maxY < point.y ? point.y : maxY;
  });
  return {
    minX: minX,
    maxX: maxX,
    minY: minY,
    maxY: maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2
  };
}

function getAngle(shape, coord) {
  var points = shape.points || shape.get('origin').points;
  var box = getPointsBox(points);
  var endAngle;
  var startAngle;
  var coordStartAngle = coord.startAngle;
  var coordEndAngle = coord.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;

  if (coord.isTransposed) {
    endAngle = box.maxY * diffAngle;
    startAngle = box.minY * diffAngle;
  } else {
    endAngle = box.maxX * diffAngle;
    startAngle = box.minX * diffAngle;
  }

  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle: startAngle,
    endAngle: endAngle
  };
}

function getAnimateParam(animateCfg, index, id) {
  var result = {};

  if (animateCfg.delay) {
    result.delay = Util.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay;
  }

  result.easing = Util.isFunction(animateCfg.easing) ? animateCfg.easing(index, id) : animateCfg.easing;
  result.duration = Util.isFunction(animateCfg.duration) ? animateCfg.duration(index, id) : animateCfg.duration;
  result.callback = animateCfg.callback;
  return result;
}

function scaleInY(shape, animateCfg) {
  var id = shape._id;
  var index = shape.get('index');
  var box = shape.getBBox();
  var points = shape.get('origin').points;
  var x = (box.minX + box.maxX) / 2;
  var y;

  if (points[0].y - points[1].y <= 0) {
    // 褰撻《鐐瑰湪闆剁偣涔嬩笅
    y = box.maxY;
  } else {
    y = box.minY;
  }

  var v = [x, y, 1];
  shape.apply(v);
  shape.attr('transform', [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);
  var endState = {
    transform: [['t', -x, -y], ['s', 1, 100], ['t', x, y]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
}

function scaleInX(shape, animateCfg) {
  var id = shape._id;
  var index = shape.get('index');
  var box = shape.getBBox();
  var points = shape.get('origin').points;
  var x;
  var y = (box.minY + box.maxY) / 2;

  if (points[0].y - points[1].y > 0) {
    // 褰撻《鐐瑰湪闆剁偣涔嬩笅
    x = box.maxX;
  } else {
    x = box.minX;
  }

  var v = [x, y, 1];
  shape.apply(v);
  shape.attr({
    transform: [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]
  });
  var endState = {
    transform: [['t', -x, -y], ['s', 100, 1], ['t', x, y]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
}

function lineWidthOut(shape, animateCfg) {
  var endState = {
    lineWidth: 0,
    opacity: 0
  };
  var id = shape._id;
  var index = shape.get('index');
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    shape.remove();
  }, animateParam.delay);
}

function zoomIn(shape, animateCfg, coord) {
  var id = shape._id;
  var index = shape.get('index');
  var x;
  var y;

  if (coord.isPolar && shape.name !== 'point') {
    x = coord.getCenter().x;
    y = coord.getCenter().y;
  } else {
    var box = shape.getBBox();
    x = (box.minX + box.maxX) / 2;
    y = (box.minY + box.maxY) / 2;
  }

  var v = [x, y, 1];
  shape.apply(v);
  shape.attr({
    transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]
  });
  var endState = {
    transform: [['t', -x, -y], ['s', 100, 100], ['t', x, y]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
}

function zoomOut(shape, animateCfg, coord) {
  var id = shape._id;
  var index = shape.get('index');
  var x;
  var y;

  if (coord.isPolar && shape.name !== 'point') {
    x = coord.getCenter().x;
    y = coord.getCenter().y;
  } else {
    var box = shape.getBBox();
    x = (box.minX + box.maxX) / 2;
    y = (box.minY + box.maxY) / 2;
  }

  var v = [x, y, 1];
  shape.apply(v);
  var endState = {
    transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    shape.remove();
  }, animateParam.delay);
}

function pathIn(shape, animateCfg) {
  if (shape.get('type') !== 'path') return;
  var id = shape._id;
  var index = shape.get('index');
  var path = PathUtil.pathToAbsolute(shape.attr('path'));
  shape.attr('path', [path[0]]);
  var endState = {
    path: path
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
}

function pathOut(shape, animateCfg) {
  if (shape.get('type') !== 'path') return;
  var id = shape._id;
  var index = shape.get('index');
  var path = PathUtil.pathToAbsolute(shape.attr('path'));
  var endState = {
    path: [path[0]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    shape.remove();
  }, animateParam.delay);
}

function clipIn(shape, animateCfg, coord, startAngle, endAngle) {
  var clip = getClip(coord);
  var canvas = shape.get('canvas');
  var id = shape._id;
  var index = shape.get('index');
  var endState;

  if (startAngle) {
    clip.attr('startAngle', startAngle);
    clip.attr('endAngle', startAngle);
    endState = {
      endAngle: endAngle
    };
  } else {
    endState = clip.endState;
  }

  clip.set('canvas', canvas);
  shape.attr('clip', clip);
  shape.setSilent('animating', true);
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  clip.animate(endState, animateParam.duration, animateParam.easing, function () {
    if (shape && !shape.get('destroyed')) {
      shape.attr('clip', null);
      shape.setSilent('cacheShape', null);
      shape.setSilent('animating', false);
      clip.remove();
    }
  }, animateParam.delay);
}

function fadeIn(shape, animateCfg) {
  var id = shape._id;
  var index = shape.get('index');
  var fillOpacity = Util.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');
  var strokeOpacity = Util.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');
  shape.attr('fillOpacity', 0);
  shape.attr('strokeOpacity', 0);
  var endState = {
    fillOpacity: fillOpacity,
    strokeOpacity: strokeOpacity
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);
}

function fadeOut(shape, animateCfg) {
  var id = shape._id;
  var index = shape.get('index');
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    shape.remove();
  }, animateParam.delay);
}

function fanIn(shape, animateCfg, coord) {
  var angle = getAngle(shape, coord);
  var endAngle = angle.endAngle;
  var startAngle = angle.startAngle;
  clipIn(shape, animateCfg, coord, startAngle, endAngle);
}

function lineSlideLeft(shape, animateCfg, coord) {
  if (shape.name !== 'line') {
    return;
  }

  var canvas = shape.get('canvas');
  var cache = shape.get('cacheShape');
  var id = shape._id;
  var index = shape.get('index');
  var clip = new G.Rect({
    attrs: {
      x: coord.start.x,
      y: coord.end.y,
      width: coord.getWidth(),
      height: coord.getHeight()
    }
  });
  clip.isClip = true;
  clip.set('canvas', canvas);
  var lastPath = PathUtil.pathToAbsolute(cache.attrs.path);
  var updatePath = PathUtil.pathToAbsolute(shape.attr('path'));
  var gap = lastPath[1][1] - lastPath[0][1]; // 鐢熸垚杩囨浮Path

  var pathPatchPosX = lastPath[lastPath.length - 1][1] + gap;
  var pathPatchPosY = updatePath[updatePath.length - 1][2];
  var transitionPath = lastPath.concat([['L', pathPatchPosX, pathPatchPosY]]);
  var v = [0, 0, 1];
  shape.apply(v);
  shape.attr('clip', clip);
  shape.attr('path', transitionPath);
  var endState = {
    transform: [['t', -gap, 0]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    if (shape && !shape.get('destroyed')) {
      shape.attr('path', updatePath);
      shape.attr({
        transform: [['t', gap, 0]]
      });
      shape.attr('clip', null);
      shape.setSilent('cacheShape', null);
      clip.remove();
    }
  }, animateParam.delay);
}

function areaSlideLeft(shape, animateCfg, coord) {
  if (shape.name !== 'area') {
    return;
  }

  var canvas = shape.get('canvas');
  var cache = shape.get('cacheShape');
  var id = shape._id;
  var index = shape.get('index');
  var clip = new G.Rect({
    attrs: {
      x: coord.start.x,
      y: coord.end.y,
      width: coord.getWidth(),
      height: coord.getHeight()
    }
  });
  clip.isClip = true;
  clip.set('canvas', canvas);
  var lastPath = PathUtil.pathToAbsolute(cache.attrs.path);
  var updatePath = PathUtil.pathToAbsolute(shape.attr('path'));
  var gap = lastPath[1][1] - lastPath[0][1]; // 鐢熸垚杩囨浮Path

  var middleIndex = Math.floor(lastPath.length / 2);
  var pathPatchPosX = lastPath[middleIndex - 1][1] + gap;
  var pathPatchPosY = updatePath[middleIndex - 1][2];
  var transitionPath = [].concat(lastPath.slice(0, middleIndex), [['L', pathPatchPosX, pathPatchPosY], ['L', pathPatchPosX, updatePath[middleIndex][2]]], lastPath.slice(middleIndex));
  var v = [0, 0, 1];
  shape.apply(v);
  shape.attr('clip', clip);
  shape.attr('path', transitionPath);
  var endState = {
    transform: [['t', -gap, 0]]
  };
  var animateParam = getAnimateParam(animateCfg, index, id, endState);
  shape.animate(endState, animateParam.duration, animateParam.easing, function () {
    if (shape && !shape.get('destroyed')) {
      shape.attr('path', updatePath);
      shape.attr({
        transform: [['t', gap, 0]]
      });
      shape.attr('clip', null);
      shape.setSilent('cacheShape', null);
      clip.remove();
    }
  }, animateParam.delay);
} // 榛樿鍔ㄧ敾搴�


module.exports = {
  enter: {
    clipIn: clipIn,
    zoomIn: zoomIn,
    pathIn: pathIn,
    scaleInY: scaleInY,
    scaleInX: scaleInX,
    fanIn: fanIn,
    fadeIn: fadeIn
  },
  leave: {
    lineWidthOut: lineWidthOut,
    zoomOut: zoomOut,
    pathOut: pathOut,
    fadeOut: fadeOut
  },
  appear: {
    clipIn: clipIn,
    zoomIn: zoomIn,
    pathIn: pathIn,
    scaleInY: scaleInY,
    scaleInX: scaleInX,
    fanIn: fanIn,
    fadeIn: fadeIn
  },
  update: {
    fadeIn: fadeIn,
    fanIn: fanIn,
    lineSlideLeft: lineSlideLeft,
    areaSlideLeft: areaSlideLeft
  }
};

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The entry of chart's animation
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var Animate = __webpack_require__(119);

var MatrixUtil = Util.MatrixUtil;
var mat3 = MatrixUtil.mat3; // 鑾峰彇鍥剧粍鍐呮墍鏈夌殑shapes

function getShapes(container, viewId) {
  var shapes = [];

  if (container.get('animate') === false) {
    return [];
  }

  var children = container.get('children');
  Util.each(children, function (child) {
    if (child.isGroup) {
      shapes = shapes.concat(getShapes(child, viewId));
    } else if (child.isShape && child._id) {
      var id = child._id;
      id = id.split('-')[0];

      if (id === viewId) {
        shapes.push(child);
      }
    }
  });
  return shapes;
}

function cache(shapes) {
  var rst = {};
  Util.each(shapes, function (shape) {
    if (!shape._id || shape.isClip) return;
    var id = shape._id;
    rst[id] = {
      _id: id,
      type: shape.get('type'),
      attrs: Util.cloneDeep(shape.attr()),
      // 鍘熷灞炴€�
      name: shape.name,
      index: shape.get('index'),
      animateCfg: shape.get('animateCfg'),
      coord: shape.get('coord')
    };
  });
  return rst;
}

function getAnimate(geomType, coord, animationType, animationName) {
  var result;

  if (animationName) {
    result = Animate.Action[animationType][animationName];
  } else {
    result = Animate.getAnimation(geomType, coord, animationType);
  }

  return result;
}

function getAnimateCfg(geomType, animationType, animateCfg) {
  var defaultCfg = Animate.getAnimateCfg(geomType, animationType);

  if (animateCfg && animateCfg[animationType]) {
    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);
  }

  return defaultCfg;
}

function addAnimate(cache, shapes, canvas, isUpdate) {
  var animate;
  var animateCfg;
  var canvasDrawn = false;

  if (isUpdate) {
    // Step: leave -> update -> enter
    var updateShapes = []; // 瀛樺偍鐨勬槸 shapes

    var newShapes = []; // 瀛樺偍鐨勬槸 shapes

    Util.each(shapes, function (shape) {
      var result = cache[shape._id];

      if (!result) {
        newShapes.push(shape);
      } else {
        shape.setSilent('cacheShape', result);
        updateShapes.push(shape);
        delete cache[shape._id];
      }
    });
    Util.each(cache, function (deletedShape) {
      var name = deletedShape.name,
          coord = deletedShape.coord,
          _id = deletedShape._id,
          attrs = deletedShape.attrs,
          index = deletedShape.index,
          type = deletedShape.type;
      animateCfg = getAnimateCfg(name, 'leave', deletedShape.animateCfg);
      animate = getAnimate(name, coord, 'leave', animateCfg.animation);

      if (Util.isFunction(animate)) {
        var tempShape = canvas.addShape(type, {
          attrs: attrs,
          index: index
        });
        tempShape._id = _id;
        tempShape.name = name;

        if (coord && name !== 'label') {
          var tempShapeMatrix = tempShape.getMatrix();
          var finalMatrix = mat3.multiply([], tempShapeMatrix, coord.matrix);
          tempShape.setMatrix(finalMatrix);
        }

        canvasDrawn = true;
        animate(tempShape, animateCfg, coord);
      }
    });
    Util.each(updateShapes, function (updateShape) {
      var name = updateShape.name;
      var coord = updateShape.get('coord');
      var cacheAttrs = updateShape.get('cacheShape').attrs; // 鍒ゆ柇濡傛灉灞炴€х浉鍚岀殑璇濆氨涓嶈繘琛屽彉鎹�

      if (!Util.isEqual(cacheAttrs, updateShape.attr())) {
        animateCfg = getAnimateCfg(name, 'update', updateShape.get('animateCfg'));
        animate = getAnimate(name, coord, 'update', animateCfg.animation);

        if (Util.isFunction(animate)) {
          animate(updateShape, animateCfg, coord);
        } else {
          var endState = Util.cloneDeep(updateShape.attr());
          updateShape.attr(cacheAttrs);
          updateShape.animate(endState, animateCfg.duration, animateCfg.easing, function () {
            updateShape.setSilent('cacheShape', null);
          });
        }

        canvasDrawn = true;
      }
    });
    Util.each(newShapes, function (newShape) {
      var name = newShape.name;
      var coord = newShape.get('coord');
      animateCfg = getAnimateCfg(name, 'enter', newShape.get('animateCfg'));
      animate = getAnimate(name, coord, 'enter', animateCfg.animation);

      if (Util.isFunction(animate)) {
        animate(newShape, animateCfg, coord);
        canvasDrawn = true;
      }
    });
  } else {
    Util.each(shapes, function (shape) {
      var name = shape.name;
      var coord = shape.get('coord');
      animateCfg = getAnimateCfg(name, 'appear', shape.get('animateCfg'));
      animate = getAnimate(name, coord, 'appear', animateCfg.animation);

      if (Util.isFunction(animate)) {
        animate(shape, animateCfg, coord);
        canvasDrawn = true;
      }
    });
  }

  return canvasDrawn;
}

module.exports = {
  execAnimation: function execAnimation(view, isUpdate) {
    var viewContainer = view.get('middlePlot');
    var axisContainer = view.get('backPlot');
    var viewId = view.get('_id');
    var canvas = view.get('canvas');
    var caches = canvas.get(viewId + 'caches') || [];

    if (caches.length === 0) {
      isUpdate = false;
    }

    var shapes = getShapes(viewContainer, viewId);
    var axisShapes = getShapes(axisContainer, viewId);
    var cacheShapes = shapes.concat(axisShapes);
    canvas.setSilent(viewId + 'caches', cache(cacheShapes));
    var drawn;

    if (isUpdate) {
      drawn = addAnimate(caches, cacheShapes, canvas, isUpdate);
    } else {
      drawn = addAnimate(caches, shapes, canvas, isUpdate);
    }

    if (!drawn) {
      canvas.draw();
    }
  }
};

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The controller of axis
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var _require = __webpack_require__(30),
    Axis = _require.Axis;

var vec2 = Util.MatrixUtil.vec2;

function formatTicks(ticks) {
  var tmp = [];

  if (ticks.length > 0) {
    tmp = ticks.slice(0);
    var first = tmp[0];
    var last = tmp[tmp.length - 1];

    if (first.value !== 0) {
      tmp.unshift({
        value: 0
      });
    }

    if (last.value !== 1) {
      tmp.push({
        value: 1
      });
    }
  }

  return tmp;
}

function fillAxisTicks(ticks, isLinear, gridCentering) {
  var result = [];
  if (ticks.length < 1) return result;

  if (ticks.length >= 2 && isLinear && gridCentering) {
    result.push({
      text: '',
      tickValue: '',
      value: 0
    });
  }

  if (ticks[0].value !== 0) {
    result.push({
      text: '',
      tickValue: '',
      value: 0
    });
  }

  result = result.concat(ticks);

  if (result[result.length - 1].value !== 1) {
    result.push({
      text: '',
      tickValue: '',
      value: 1
    });
  }

  return result;
}

function getDefaultValueFromPosition(position, val) {
  if (val === void 0) {
    val = 0;
  }

  if (position === 'middle') {
    val = 0.5;
  }

  if (position.includes('%')) {
    val = parseInt(position, 10) / 100;
  }

  return val;
}

var AxisController = /*#__PURE__*/function () {
  function AxisController(cfg) {
    this.visible = true;
    this.canvas = null;
    this.container = null;
    this.coord = null;
    this.options = null;
    this.axes = [];
    Util.mix(this, cfg);
  }

  var _proto = AxisController.prototype;

  _proto._isHide = function _isHide(field) {
    // 瀵瑰簲鐨勫潗鏍囪酱鏄惁闅愯棌
    var options = this.options;

    if (options && options[field] === false) {
      return true;
    }

    return false;
  };

  _proto._getMiddleValue = function _getMiddleValue(curValue, ticks, index, isLinear) {
    if (curValue === 0 && !isLinear) {
      return 0;
    }

    if (curValue === 1) {
      return 1;
    }

    var nextValue = ticks[index + 1].value;

    if (!isLinear && nextValue === 1) {
      return 1;
    }

    return (curValue + nextValue) / 2;
  };

  _proto._getLineRange = function _getLineRange(coord, scale, dimType, index) {
    var start;
    var end;
    var isVertical;
    var field = scale.field;
    var options = this.options;
    var position = '';

    if (options[field] && options[field].position) {
      position = options[field].position;
    } // TODO middle & percentage for position


    if (dimType === 'x') {
      // x杞寸殑鍧愭爣杞�,搴曢儴鐨勬í鍧愭爣
      var y = position === 'top' ? 1 : 0;
      y = getDefaultValueFromPosition(position, y);
      start = {
        x: 0,
        y: y
      };
      end = {
        x: 1,
        y: y
      };
      isVertical = false;
    } else {
      // y杞村潗鏍囪酱
      if (index) {
        // 澶氳酱鐨勬儏鍐�
        var x = position === 'left' ? 0 : 1;
        x = getDefaultValueFromPosition(position, x);
        start = {
          x: x,
          y: 0
        };
        end = {
          x: x,
          y: 1
        };
      } else {
        // 鍗曚釜y杞达紝鎴栬€呯涓€涓獃杞�
        var _x = position === 'right' ? 1 : 0;

        _x = getDefaultValueFromPosition(position, _x);
        start = {
          x: _x,
          y: 0
        };
        end = {
          x: _x,
          y: 1
        };
      }

      isVertical = true;
    }

    start = coord.convert(start);
    end = coord.convert(end);
    return {
      start: start,
      end: end,
      isVertical: isVertical
    };
  };

  _proto._getLineCfg = function _getLineCfg(coord, scale, dimType, index) {
    var factor;

    var range = this._getLineRange(coord, scale, dimType, index);

    var isVertical = range.isVertical; // 鏍囪瘑璇ュ潗鏍囪酱鏄惁鏄旱鍧愭爣

    var start = range.start;
    var end = range.end;
    var center = coord.center;

    if (coord.isTransposed) {
      isVertical = !isVertical;
    }

    if (isVertical && start.x > center.x || !isVertical && start.y > center.y) {
      factor = 1;
    } else {
      factor = -1;
    }

    return {
      isVertical: isVertical,
      factor: factor,
      start: start,
      end: end
    };
  } // 鑾峰彇鍦嗗姬鍧愭爣杞撮厤缃」淇℃伅
  ;

  _proto._getCircleCfg = function _getCircleCfg(coord) {
    var circleCfg = {};
    var rangeX = coord.x;
    var rangeY = coord.y;
    var isReflectY = rangeY.start > rangeY.end;
    var start;

    if (coord.isTransposed) {
      start = {
        x: isReflectY ? 0 : 1,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: isReflectY ? 0 : 1
      };
    }

    start = coord.convert(start);
    var center = coord.circleCentre;
    var startVector = [start.x - center.x, start.y - center.y];
    var normalVector = [1, 0];
    var startAngle;

    if (start.y > center.y) {
      startAngle = vec2.angle(startVector, normalVector);
    } else {
      startAngle = vec2.angle(startVector, normalVector) * -1;
    }

    var endAngle = startAngle + (rangeX.end - rangeX.start);
    circleCfg.startAngle = startAngle;
    circleCfg.endAngle = endAngle;
    circleCfg.center = center;
    circleCfg.radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
    circleCfg.inner = coord.innerRadius || 0;
    return circleCfg;
  };

  _proto._getRadiusCfg = function _getRadiusCfg(coord) {
    var startAngle = coord.x.start;
    var factor = startAngle < 0 ? -1 : 1;
    var start;
    var end;

    if (coord.isTransposed) {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
    }

    return {
      factor: factor,
      start: coord.convert(start),
      end: coord.convert(end)
    };
  } // 纭畾鍧愭爣杞寸殑浣嶇疆
  ;

  _proto._getAxisPosition = function _getAxisPosition(coord, dimType, index, field) {
    var position = ''; // 鐢ㄦ埛鑷繁瀹氫箟浜� position

    var options = this.options; // const VALID_POSITIONS = [
    //   'top',
    //   'left',
    //   'right',
    //   'bottom'
    // ];

    if (options[field] && options[field].position) {
      position = options[field].position; // if (VALID_POSITIONS.indexOf(position) > -1) {
      //   return position;
      // }
    } else {
      var coordType = coord.type;

      if (coord.isRect) {
        if (dimType === 'x') {
          position = 'bottom';
        } else if (dimType === 'y') {
          if (index) {
            position = 'right';
          } else {
            position = 'left';
          }
        }
      } else if (coordType === 'helix') {
        position = 'helix';
      } else if (dimType === 'x') {
        position = coord.isTransposed ? 'radius' : 'circle';
      } else {
        position = coord.isTransposed ? 'circle' : 'radius';
      }
    }

    return position;
  } // 鑾峰彇鍧愭爣杞存瀯鎴愮殑閰嶇疆淇℃伅
  ;

  _proto._getAxisDefaultCfg = function _getAxisDefaultCfg(coord, scale, type, position) {
    var self = this;
    var viewTheme = self.viewTheme;
    var cfg = {};
    var options = self.options;
    var field = scale.field;
    cfg = Util.deepMix({}, viewTheme.axis[position], cfg, options[field]);
    cfg.viewTheme = viewTheme;

    if (cfg.title) {
      var title = Util.isPlainObject(cfg.title) ? cfg.title : {};
      title.text = title.text || scale.alias || field;
      Util.deepMix(cfg, {
        title: title
      });
    }

    cfg.ticks = scale.getTicks();

    if (coord.isPolar && !scale.isCategory) {
      if (type === 'x' && Math.abs(coord.endAngle - coord.startAngle) === Math.PI * 2) {
        cfg.ticks.pop();
      }
    }

    cfg.coord = coord;

    if (cfg.label && Util.isNil(cfg.label.autoRotate)) {
      cfg.label.autoRotate = true; // 鍏佽鑷姩鏃嬭浆锛岄伩鍏嶉噸鍙�
    }

    if (options.hasOwnProperty('xField') && options.xField.hasOwnProperty('grid')) {
      if (cfg.position === 'left') {
        Util.deepMix(cfg, options.xField);
      }
    }

    return cfg;
  } // 纭畾鍧愭爣杞寸殑閰嶇疆淇℃伅
  ;

  _proto._getAxisCfg = function _getAxisCfg(coord, scale, verticalScale, dimType, index, viewId) {
    if (index === void 0) {
      index = '';
    }

    var self = this;

    var position = self._getAxisPosition(coord, dimType, index, scale.field);

    var cfg = self._getAxisDefaultCfg(coord, scale, dimType, position);

    if (!Util.isEmpty(cfg.grid) && verticalScale) {
      // 鐢熸垚 gridPoints
      var gridPoints = [];
      var tickValues = [];
      var verticalTicks = formatTicks(verticalScale.getTicks()); // 娌℃湁鍨傜洿鐨勫潗鏍囩偣鏃朵笉浼氬彧鏍呮牸

      if (verticalTicks.length) {
        var ticks = fillAxisTicks(cfg.ticks, scale.isLinear, cfg.grid.align === 'center');
        Util.each(ticks, function (tick, idx) {
          tickValues.push(tick.tickValue);
          var subPoints = [];
          var value = tick.value;

          if (cfg.grid.align === 'center') {
            value = self._getMiddleValue(value, ticks, idx, scale.isLinear);
          }

          if (!Util.isNil(value)) {
            var rangeX = coord.x;
            var rangeY = coord.y;
            Util.each(verticalTicks, function (verticalTick) {
              var x = dimType === 'x' ? value : verticalTick.value;
              var y = dimType === 'x' ? verticalTick.value : value;
              var point = coord.convert({
                x: x,
                y: y
              });

              if (coord.isPolar) {
                var center = coord.circleCentre;

                if (rangeY.start > rangeY.end) {
                  y = 1 - y;
                }

                point.flag = rangeX.start > rangeX.end ? 0 : 1;
                point.radius = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
              }

              subPoints.push(point);
            });
            gridPoints.push({
              _id: viewId + '-' + dimType + index + '-grid-' + tick.tickValue,
              points: subPoints
            });
          }
        });
      }

      cfg.grid.items = gridPoints;
      cfg.grid.tickValues = tickValues;
    }

    cfg.type = scale.type;
    return cfg;
  };

  _proto._getHelixCfg = function _getHelixCfg(coord) {
    var helixCfg = {};
    var a = coord.a;
    var startAngle = coord.startAngle;
    var endAngle = coord.endAngle;
    var index = 100;
    var crp = [];

    for (var i = 0; i <= index; i++) {
      var point = coord.convert({
        x: i / 100,
        y: 0
      });
      crp.push(point.x);
      crp.push(point.y);
    }

    var axisStart = coord.convert({
      x: 0,
      y: 0
    });
    helixCfg.a = a;
    helixCfg.startAngle = startAngle;
    helixCfg.endAngle = endAngle;
    helixCfg.crp = crp;
    helixCfg.axisStart = axisStart;
    helixCfg.center = coord.center;
    helixCfg.inner = coord.y.start; // 鍐呭崐寰�

    return helixCfg;
  };

  _proto._drawAxis = function _drawAxis(coord, scale, verticalScale, dimType, viewId, xAxis, index) {
    var container = this.container;
    var canvas = this.canvas;
    var C; // 鍧愭爣杞寸被

    var appendCfg; // 姣忎釜鍧愭爣杞� start end 绛夌粯鍒惰竟鐣岀殑淇℃伅

    if (coord.type === 'cartesian') {
      C = Axis.Line;
      appendCfg = this._getLineCfg(coord, scale, dimType, index);
    } else if (coord.type === 'helix' && dimType === 'x') {
      C = Axis.Helix;
      appendCfg = this._getHelixCfg(coord);
    } else if (dimType === 'x') {
      C = Axis.Circle;
      appendCfg = this._getCircleCfg(coord);
    } else {
      C = Axis.Line;
      appendCfg = this._getRadiusCfg(coord);
    }

    var cfg = this._getAxisCfg(coord, scale, verticalScale, dimType, index, viewId);

    cfg = Util.mix({}, cfg, appendCfg);

    if (dimType === 'y' && xAxis && xAxis.get('type') === 'circle') {
      cfg.circle = xAxis;
    }

    cfg._id = viewId + '-' + dimType;

    if (!Util.isNil(index)) {
      cfg._id = viewId + '-' + dimType + index;
    }

    Util.mix(cfg, {
      canvas: canvas,
      // 姣忎釜 axis 闇€瑕佸崟鐙殑 group锛�
      // 鍚﹀垯鎵€鏈夌殑 aixs 鐨勬枃鏈兘娣峰湪涓€璧蜂簡
      // 鍚屾椂鏃犳硶鐭ラ亾鏄摢涓潗鏍囪酱鐨勪簨浠�
      group: container.addGroup({
        viewId: viewId
      })
    });
    var axis = new C(cfg);
    axis.render();
    this.axes.push(axis);
    return axis;
  };

  _proto.createAxis = function createAxis(xScale, yScales, viewId) {
    var self = this;
    var coord = this.coord;
    var coordType = coord.type; // theta鍧愭爣绯婚粯璁や笉缁樺埗鍧愭爣杞�

    if (coordType !== 'theta' && !(coordType === 'polar' && coord.isTransposed)) {
      var xAxis;

      if (xScale && !self._isHide(xScale.field)) {
        xAxis = self._drawAxis(coord, xScale, yScales[0], 'x', viewId); // 缁樺埗 x 杞�
      }

      if (!Util.isEmpty(yScales) && coordType !== 'helix') {
        Util.each(yScales, function (yScale, index) {
          if (!self._isHide(yScale.field)) {
            self._drawAxis(coord, yScale, xScale, 'y', viewId, xAxis, index);
          }
        });
      }
    }
  };

  _proto.changeVisible = function changeVisible(visible) {
    var axes = this.axes;
    Util.each(axes, function (axis) {
      axis.set('visible', visible);
    });
  };

  _proto.clear = function clear() {
    var self = this;
    var axes = self.axes;
    Util.each(axes, function (axis) {
      axis.destroy();
    });
    self.axes = [];
  };

  return AxisController;
}();

module.exports = AxisController;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The controller of coordinate
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var Coord = __webpack_require__(268);

var CoordController = /*#__PURE__*/function () {
  function CoordController(option) {
    this.type = 'rect';
    this.actions = [];
    this.cfg = {};
    Util.mix(this, option);
    this.option = option || {};
  }

  var _proto = CoordController.prototype;

  _proto.reset = function reset(coordOption) {
    this.actions = coordOption.actions || [];
    this.type = coordOption.type;
    this.cfg = coordOption.cfg;
    this.option.actions = this.actions;
    this.option.type = this.type;
    this.option.cfg = this.cfg;
    return this;
  };

  _proto._execActions = function _execActions(coord) {
    var actions = this.actions;
    Util.each(actions, function (action) {
      var m = action[0];
      coord[m](action[1], action[2]);
    });
  };

  _proto.hasAction = function hasAction(actionName) {
    var actions = this.actions;
    var rst = false;
    Util.each(actions, function (action) {
      if (actionName === action[0]) {
        rst = true;
        return false;
      }
    });
    return rst;
  }
  /**
   * 鍒涘缓鍧愭爣绯诲璞�
   * @param  {Object} start 鍧愭爣绯昏捣濮嬬偣
   * @param  {Object} end   鍧愭爣绯荤粨鏉熺偣
   * @return {Function} 鍧愭爣绯荤殑鏋勯€犲嚱鏁�
   */
  ;

  _proto.createCoord = function createCoord(start, end) {
    var self = this;
    var type = self.type;
    var cfg = self.cfg;
    var C; // 鏋勯€犲嚱鏁�

    var coord;
    var coordCfg = Util.mix({
      start: start,
      end: end
    }, cfg);

    if (type === 'theta') {
      // definition of theta coord
      C = Coord.Polar;

      if (!self.hasAction('transpose')) {
        self.transpose(); // 鏋佸潗鏍囷紝鍚屾椂transpose
      }

      coord = new C(coordCfg);
      coord.type = type;
    } else {
      C = Coord[Util.upperFirst(type || '')] || Coord.Rect;
      coord = new C(coordCfg);
    }

    self._execActions(coord);

    return coord;
  };

  _proto.rotate = function rotate(angle) {
    angle = angle * Math.PI / 180;
    this.actions.push(['rotate', angle]);
    return this;
  };

  _proto.reflect = function reflect(dim) {
    this.actions.push(['reflect', dim]);
    return this;
  };

  _proto.scale = function scale(sx, sy) {
    this.actions.push(['scale', sx, sy]);
    return this;
  };

  _proto.transpose = function transpose() {
    this.actions.push(['transpose']);
    return this;
  };

  return CoordController;
}();

module.exports = CoordController;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The controller of chart's events
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

function isSameShape(shape1, shape2) {
  if (Util.isNil(shape1) || Util.isNil(shape2)) {
    return false;
  }

  var shape1Origin = shape1.get('origin');
  var shape2Origin = shape2.get('origin'); // hotfix: if both shapes have no data锛宩ust compare shapes.

  if (Util.isNil(shape1Origin) && Util.isNil(shape2Origin)) {
    return Util.isEqual(shape1, shape2);
  }

  return Util.isEqual(shape1Origin, shape2Origin);
}

function registerData(eventObj) {
  if (eventObj.shape && eventObj.shape.get('origin')) {
    eventObj.data = eventObj.shape.get('origin');
  }
}

var EventController = /*#__PURE__*/function () {
  function EventController(cfg) {
    this.view = null;
    this.canvas = null;
    Util.assign(this, cfg);

    this._init();
  }

  var _proto = EventController.prototype;

  _proto._init = function _init() {
    this.pixelRatio = this.canvas.get('pixelRatio');
  };

  _proto._getShapeEventObj = function _getShapeEventObj(ev) {
    return {
      x: ev.x / this.pixelRatio,
      y: ev.y / this.pixelRatio,
      target: ev.target,
      // canvas 鍏冪礌
      toElement: ev.event.toElement || ev.event.relatedTarget
    };
  };

  _proto._getShape = function _getShape(x, y) {
    var view = this.view;
    var container = view.get('canvas');
    return container.getShape(x, y);
  };

  _proto._getPointInfo = function _getPointInfo(ev) {
    var view = this.view;
    var point = {
      x: ev.x / this.pixelRatio,
      y: ev.y / this.pixelRatio
    };
    var views = view.getViewsByPoint(point);
    point.views = views;
    return point;
  };

  _proto._getEventObj = function _getEventObj(ev, point, views) {
    return {
      x: point.x,
      y: point.y,
      target: ev.target,
      // canvas 鍏冪礌
      toElement: ev.event.toElement || ev.event.relatedTarget,
      // 鐩爣鍏冪礌
      views: views
    };
  };

  _proto.bindEvents = function bindEvents() {
    var canvas = this.canvas;
    canvas.on('mousedown', Util.wrapBehavior(this, 'onDown'));
    canvas.on('mousemove', Util.wrapBehavior(this, 'onMove'));
    canvas.on('mouseleave', Util.wrapBehavior(this, 'onOut'));
    canvas.on('mouseup', Util.wrapBehavior(this, 'onUp'));
    canvas.on('click', Util.wrapBehavior(this, 'onClick'));
    canvas.on('dblclick', Util.wrapBehavior(this, 'onClick'));
    canvas.on('touchstart', Util.wrapBehavior(this, 'onTouchstart'));
    canvas.on('touchmove', Util.wrapBehavior(this, 'onTouchmove'));
    canvas.on('touchend', Util.wrapBehavior(this, 'onTouchend'));
  };

  _proto._triggerShapeEvent = function _triggerShapeEvent(shape, eventName, eventObj) {
    if (shape && shape.name && !shape.get('destroyed')) {
      var view = this.view;

      if (view.isShapeInView(shape)) {
        var name = shape.name + ':' + eventName;
        eventObj.view = view;
        eventObj.appendInfo = shape.get('appendInfo'); // appendInfo is defined by user

        view.emit(name, eventObj);
        var parent = view.get('parent');

        if (parent) {
          // chart 涓婁篃闇€瑕佹姏鍑鸿浜嬩欢锛屾湰鏈熷厛涓嶆姏鍑�
          parent.emit(name, eventObj);
        }
      }
    }
  };

  _proto.onDown = function onDown(ev) {
    var view = this.view;

    var eventObj = this._getShapeEventObj(ev);

    eventObj.shape = this.currentShape;
    registerData(eventObj);
    view.emit('mousedown', eventObj);

    this._triggerShapeEvent(this.currentShape, 'mousedown', eventObj);
  };

  _proto.onMove = function onMove(ev) {
    var self = this;
    var view = self.view;
    var currentShape = self.currentShape; // 濡傛灉鍥惧舰琚攢姣侊紝鍒欒缃綋鍓� shape 涓虹┖

    if (currentShape && currentShape.get('destroyed')) {
      currentShape = null;
      self.currentShape = null;
    }

    var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;

    var eventObj = self._getShapeEventObj(ev);

    eventObj.shape = shape;
    registerData(eventObj);
    view.emit('mousemove', eventObj);

    self._triggerShapeEvent(shape, 'mousemove', eventObj);

    if (currentShape && !isSameShape(currentShape, shape)) {
      var leaveObj = self._getShapeEventObj(ev);

      leaveObj.shape = currentShape;
      leaveObj.toShape = shape;
      registerData(leaveObj);

      self._triggerShapeEvent(currentShape, 'mouseleave', leaveObj);
    }

    if (shape && !isSameShape(currentShape, shape)) {
      var enterObj = self._getShapeEventObj(ev);

      enterObj.shape = shape;
      enterObj.fromShape = currentShape;
      registerData(enterObj);

      self._triggerShapeEvent(shape, 'mouseenter', enterObj);
    }

    self.currentShape = shape;

    var point = self._getPointInfo(ev);

    var preViews = self.curViews || [];

    if (preViews.length === 0 && point.views.length) {
      view.emit('plotenter', self._getEventObj(ev, point, point.views));
    } // point.views 鏄寚褰撳墠 view 鎴栬€呭瓙 view锛屼笉浼氬彇璺熷綋鍓� view 鍚屼竴灞傜骇鐨勫厔寮熷厓绱狅紙view)


    if (preViews.length && point.views.length === 0) {
      view.emit('plotleave', self._getEventObj(ev, point, preViews));
    }

    if (point.views.length) {
      eventObj = self._getEventObj(ev, point, point.views);
      eventObj.shape = shape;
      registerData(eventObj);
      view.emit('plotmove', eventObj);
    }

    self.curViews = point.views;
  };

  _proto.onOut = function onOut(ev) {
    var self = this;
    var view = self.view;

    var point = self._getPointInfo(ev);

    var preViews = self.curViews || [];

    var evtObj = self._getEventObj(ev, point, preViews); // 鍙湁娌℃湁padding 鏃讹紝褰撳墠渚濈劧鍦� view 鐨� plotRange 鎯呭喌涓嬫墠浼氬嚭鐜拌繖涓儏鍐碉紝淇濊瘉 plotleave 瑙﹀彂


    if (self.curViews && self.curViews.length !== 0 && (!evtObj.toElement || evtObj.toElement.tagName !== 'CANVAS')) {
      view.emit('plotleave', evtObj);
      self.curViews = []; // 娓呯┖
    }
  };

  _proto.onUp = function onUp(ev) {
    var view = this.view;

    var eventObj = this._getShapeEventObj(ev);

    eventObj.shape = this.currentShape;
    view.emit('mouseup', eventObj);

    this._triggerShapeEvent(this.currentShape, 'mouseup', eventObj);
  };

  _proto.onClick = function onClick(ev) {
    var self = this;
    var view = self.view;
    var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;

    var shapeEventObj = self._getShapeEventObj(ev);

    shapeEventObj.shape = shape;
    registerData(shapeEventObj);
    view.emit('click', shapeEventObj);

    self._triggerShapeEvent(shape, ev.type, shapeEventObj);

    self.currentShape = shape;

    var point = self._getPointInfo(ev);

    var views = point.views;

    if (!Util.isEmpty(views)) {
      var eventObj = self._getEventObj(ev, point, views);

      if (self.currentShape) {
        var _shape = self.currentShape;
        eventObj.shape = _shape;
        registerData(eventObj); // eventObj.data = shape.get('origin');
      }

      if (ev.type === 'dblclick') {
        view.emit('plotdblclick', eventObj);
        view.emit('dblclick', shapeEventObj);
      } else {
        view.emit('plotclick', eventObj);
      }
    }
  };

  _proto.onTouchstart = function onTouchstart(ev) {
    var view = this.view;
    var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;

    var eventObj = this._getShapeEventObj(ev);

    eventObj.shape = shape;
    registerData(eventObj);
    view.emit('touchstart', eventObj);

    this._triggerShapeEvent(shape, 'touchstart', eventObj);

    this.currentShape = shape;
  };

  _proto.onTouchmove = function onTouchmove(ev) {
    var view = this.view;
    var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;

    var eventObj = this._getShapeEventObj(ev);

    eventObj.shape = shape;
    registerData(eventObj);
    view.emit('touchmove', eventObj);

    this._triggerShapeEvent(shape, 'touchmove', eventObj);

    this.currentShape = shape;
  };

  _proto.onTouchend = function onTouchend(ev) {
    var view = this.view;

    var eventObj = this._getShapeEventObj(ev);

    eventObj.shape = this.currentShape;
    registerData(eventObj);
    view.emit('touchend', eventObj);

    this._triggerShapeEvent(this.currentShape, 'touchend', eventObj);
  };

  _proto.clearEvents = function clearEvents() {
    var canvas = this.canvas;
    canvas.off('mousemove', Util.getWrapBehavior(this, 'onMove'));
    canvas.off('mouseleave', Util.getWrapBehavior(this, 'onOut'));
    canvas.off('mousedown', Util.getWrapBehavior(this, 'onDown'));
    canvas.off('mouseup', Util.getWrapBehavior(this, 'onUp'));
    canvas.off('click', Util.getWrapBehavior(this, 'onClick'));
    canvas.off('dblclick', Util.getWrapBehavior(this, 'onClick'));
    canvas.off('touchstart', Util.getWrapBehavior(this, 'onTouchstart'));
    canvas.off('touchmove', Util.getWrapBehavior(this, 'onTouchmove'));
    canvas.off('touchend', Util.getWrapBehavior(this, 'onTouchend'));
  };

  return EventController;
}();

module.exports = EventController;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var Guide = __webpack_require__(280);

var GuideController = /*#__PURE__*/function () {
  function GuideController(cfg) {
    this.guides = [];
    this.options = [];
    this.xScales = null;
    this.yScales = null;
    this.view = null;
    this.viewTheme = null;
    this.frontGroup = null;
    this.backGroup = null;
    Util.mix(this, cfg);
  }

  var _proto = GuideController.prototype;

  _proto._creatGuides = function _creatGuides() {
    var self = this;
    var options = this.options;
    var xScales = this.xScales;
    var yScales = this.yScales;
    var view = this.view;
    var viewTheme = this.viewTheme; // @2019-01-18 by blue.lb 杩欓噷濡傛灉缁� backContainer 娣诲姞 group 鐨勮瘽锛屼細鐩存帴瀵艰嚧 BBoxOfBackPlot 鍑芥暟涓绠� element.getBBox() 鍑洪敊

    if (this.backContainer && view) {
      this.backGroup = this.backContainer.addGroup({
        viewId: view.get('_id')
      });
    }

    if (this.frontContainer && view) {
      this.frontGroup = this.frontContainer.addGroup({
        viewId: view.get('_id')
      });
    }

    options.forEach(function (option) {
      var type = option.type;
      var config = Util.deepMix({
        xScales: xScales,
        yScales: yScales,
        viewTheme: viewTheme
      }, viewTheme ? viewTheme.guide[type] : {}, option);
      type = Util.upperFirst(type);
      var guide = new Guide[type](config);
      self.guides.push(guide);
    });
    return self.guides;
  };

  _proto.line = function line(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'line'
    }, cfg));
    return this;
  };

  _proto.arc = function arc(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'arc'
    }, cfg));
    return this;
  };

  _proto.text = function text(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'text'
    }, cfg));
    return this;
  };

  _proto.image = function image(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'image'
    }, cfg));
    return this;
  };

  _proto.region = function region(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'region'
    }, cfg));
    return this;
  };

  _proto.regionFilter = function regionFilter(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'regionFilter'
    }, cfg));
    return this;
  };

  _proto.dataMarker = function dataMarker(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'dataMarker'
    }, cfg));
    return this;
  };

  _proto.dataRegion = function dataRegion(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'dataRegion'
    }, cfg));
    return this;
  };

  _proto.html = function html(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.options.push(Util.mix({
      type: 'html'
    }, cfg));
    return this;
  };

  _proto.render = function render(coord) {
    var self = this;
    var view = self.view;
    var viewData = view && view.get('data');

    var guides = self._creatGuides();

    Util.each(guides, function (guide) {
      var container;

      if (guide.get('top')) {
        // 榛樿 guide 缁樺埗鍒� backPlot锛岀敤鎴蜂篃鍙互澹版槑 top: true锛屾樉绀哄湪鏈€涓婂眰
        // @2019-01-18 by blue.lb 鐩存帴鐢ㄤ紶鍏ョ殑灏辫
        container = self.frontGroup || self.frontContainer; // container = self.frontContainer;
      } else {
        // @2019-01-18 by blue.lb 鐩存帴鐢ㄤ紶鍏ョ殑灏辫
        container = self.backGroup || self.backContainer; // container = self.backContainer;
      }

      guide.render(coord, container, viewData, view);
    });
  };

  _proto.clear = function clear() {
    this.options = [];
    this.reset();
  };

  _proto.changeVisible = function changeVisible(visible) {
    var guides = this.guides;
    Util.each(guides, function (guide) {
      guide.changeVisible(visible);
    });
  };

  _proto.reset = function reset() {
    var guides = this.guides;
    Util.each(guides, function (guide) {
      guide.clear();
    });
    this.guides = []; // @2019-01-18 by blue.lb 鍒犻櫎杩欓儴鍒�

    this.backGroup && this.backGroup.remove();
    this.frontGroup && this.frontGroup.remove();
  };

  return GuideController;
}();

module.exports = GuideController;

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Util = __webpack_require__(0);

var _require = __webpack_require__(30),
    Legend = _require.Legend;

var Tail = __webpack_require__(282);

var Shape = __webpack_require__(9);

var bboxOfBackPlot = __webpack_require__(122);

var plotRange2BBox = __webpack_require__(124);

var Global = __webpack_require__(5);

var FIELD_ORIGIN = '_origin';
var MARKER_SIZE = 4.5;
var requireAnimationFrameFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var STROKE_MARKERS = ['cross', 'tick', 'plus', 'hyphen', 'line', 'hollowCircle', 'hollowSquare', 'hollowDiamond', 'hollowTriangle', 'hollowTriangleDown', 'hollowHexagon', 'hollowBowtie'];

function _snapEqual(v1, v2, scale) {
  var isEqual;

  if (Util.isNil(scale)) {
    return false;
  }

  v1 = scale.translate(v1);
  v2 = scale.translate(v2);

  if (scale.isCategory) {
    isEqual = v1 === v2;
  } else {
    isEqual = Math.abs(v1 - v2) <= 1;
  }

  return isEqual;
}

function findGeom(geoms, value) {
  var rst;
  Util.each(geoms, function (geom) {
    if (geom.get('visible')) {
      var yScale = geom.getYScale();

      if (yScale.field === value) {
        rst = geom;
        return;
      }
    }
  });
  return rst;
}

var LegendController = /*#__PURE__*/function () {
  function LegendController(cfg) {
    var self = this;
    self.options = {};
    Util.mix(self, cfg);
    self.clear();
    var chart = self.chart;
    self.container = chart.get('frontPlot');
    self.plotRange = chart.get('plotRange');
  }

  var _proto = LegendController.prototype;

  _proto.clear = function clear() {
    var legends = this.legends;
    this.backRange = null;
    Util.each(legends, function (legendItems) {
      Util.each(legendItems, function (legend) {
        legend.destroy();
      });
    });
    this.legends = {};
  } // 鑾峰彇鍧愭爣杞寸瓑鑳屾櫙鍏冪礌鍗犵殑鑼冨洿锛岄槻姝㈤伄鎸″潗鏍囪酱
  ;

  _proto.getBackRange = function getBackRange() {
    var backRange = this.backRange;

    if (!backRange) {
      var backPlot = this.chart.get('backPlot');
      backRange = bboxOfBackPlot(backPlot, plotRange2BBox(this.chart.get('plotRange')));
      var plotRange = this.plotRange;

      if (backRange.maxX - backRange.minX < plotRange.br.x - plotRange.tl.x && backRange.maxY - backRange.minY < plotRange.br.y - plotRange.tl.y) {
        // 濡傛灉鑳屾櫙灏忎簬鍒欑洿鎺ヤ娇鐢� plotRange
        backRange = {
          minX: plotRange.tl.x,
          minY: plotRange.tl.y,
          maxX: plotRange.br.x,
          maxY: plotRange.br.y
        };
      }

      this.backRange = backRange;
    }

    return backRange;
  };

  _proto._isFieldInView = function _isFieldInView(field, value, view) {
    var flag = false;
    var scales = view.get('scales');
    var fieldScale = scales[field];

    if (fieldScale && fieldScale.values) {
      flag = Util.inArray(fieldScale.values, value);
    }

    return flag;
  };

  _proto._bindClickEvent = function _bindClickEvent(legend, scale, filterVals) {
    var self = this;
    var chart = self.chart;
    var views = chart.get('views');
    var field = scale.field;
    var options = self.options;
    legend.on('itemclick', function (ev) {
      if (options.onClick && options.defaultClickHandlerEnabled !== true) {
        options.onClick(ev);
      } else {
        // if 'defaultClickHandlerEnabled' is true the default click behavior would be worked.
        var item = ev.item;
        var checked = ev.checked;
        var isSingleSelected = legend.get('selectedMode') === 'single'; // 鍥句緥鐨勯€変腑妯″紡

        var clickedValue = item.dataValue; // import: 闇€瑕佸彇璇ュ浘渚嬮」鍘熷鐨勬暟鍊�

        if (checked) {
          Util.Array.remove(filterVals, clickedValue);

          if (self._isFieldInView(field, clickedValue, chart)) {
            chart.filter(field, function (field) {
              return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);
            });
          }

          Util.each(views, function (view) {
            if (self._isFieldInView(field, clickedValue, view)) {
              view.filter(field, function (field) {
                return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);
              });
            }
          });
        } else if (!isSingleSelected) {
          filterVals.push(clickedValue);

          if (self._isFieldInView(field, clickedValue, chart)) {
            chart.filter(field, function (field) {
              return !Util.inArray(filterVals, field);
            });
          }

          Util.each(views, function (view) {
            if (self._isFieldInView(field, clickedValue, view)) {
              view.filter(field, function (field) {
                return !Util.inArray(filterVals, field);
              });
            }
          });
        }

        if (options.onClick) {
          options.onClick(ev);
        }

        chart.set('keepLegend', true); // 鍥句緥涓嶉噸鏂版覆鏌�

        chart.set('keepPadding', true); // 杈规涓嶉噸鏂拌绠�

        chart.repaint();
        chart.set('keepPadding', false);
        chart.set('keepLegend', false);
      }
    });
  };

  _proto._bindClickEventForMix = function _bindClickEventForMix(legend) {
    var self = this;
    var chart = self.chart;
    var geoms = chart.getAllGeoms();
    legend.on('itemclick', function (ev) {
      var itemField = ev.item.field;
      var checked = ev.checked;

      if (checked) {
        Util.each(geoms, function (geom) {
          var field = geom.getYScale().field;

          if (field === itemField) {
            geom.show();
          }
        });
      } else {
        Util.each(geoms, function (geom) {
          var field = geom.getYScale().field;

          if (field === itemField) {
            geom.hide();
          }
        });
      }
    });
  };

  _proto._filterLabels = function _filterLabels(shape, geom, visible) {
    if (shape.get('gLabel')) {
      shape.get('gLabel').set('visible', visible);
    } else {
      var labelCfg = geom.get('labelCfg');

      if (labelCfg && labelCfg.fields && labelCfg.fields.length > 0) {
        var xScale = geom.getXScale();
        var yScale = geom.getYScale();
        var xField = xScale.field;
        var yField = yScale.field;

        var shapeData = shape.get('origin')._origin;

        var labelContainer = geom.get('labelContainer');
        var labels = labelContainer.get('labelsGroup').get('children');
        Util.each(labels, function (label) {
          var labelData = label.get('origin') || [];

          if (labelData[xField] === shapeData[xField] && labelData[yField] === shapeData[yField]) {
            label.set('visible', visible);
            shape.set('gLabel', label);
          }
        });
      }
    }
  };

  _proto._bindFilterEvent = function _bindFilterEvent(legend, scale) {
    var self = this;
    var chart = this.chart;
    var field = scale.field;
    legend.on('itemfilter', function (ev) {
      var range = ev.range;
      chart.filterShape(function (obj, shape, geom) {
        // @2018-12-21 by blue.lb 鐢变簬鏁板€�0鐩存帴琚被鍨嬭浆鎹负false锛岃繖閲岄渶瑕佸仛鏇寸簿纭竴鐐圭殑鍒ゆ柇
        if (!Util.isNil(obj[field])) {
          var filtered = obj[field] >= range[0] && obj[field] <= range[1]; // shape 甯� label锛屽垯杩橀渶瑕侀殣钘� label

          self._filterLabels(shape, geom, filtered);

          return filtered;
        }

        return true;
      });
      var geoms = chart.getAllGeoms() || [];

      var _loop = function _loop(i) {
        var geom = geoms[i];

        if (geom.get('type') === 'heatmap') {
          requireAnimationFrameFn(function () {
            geom.drawWithRange(range);
          });
        }
      };

      for (var i = 0; i < geoms.length; i++) {
        _loop(i);
      }
    });
  };

  _proto._getShapeData = function _getShapeData(shape) {
    var originData = shape.get('origin');

    if (Util.isArray(originData)) {
      originData = originData[0];
    }

    return originData[FIELD_ORIGIN];
  };

  _proto._bindHoverEvent = function _bindHoverEvent(legend, field) {
    var self = this;
    var chart = self.chart;
    var geoms = chart.getAllGeoms();
    var options = self.options;
    var canvas = chart.get('canvas');
    legend.on('itemhover', function (ev) {
      var value = ev.item.value;
      var pre = self.pre;

      if (!pre) {
        Util.each(geoms, function (geom) {
          var shapeContainer = geom.get('shapeContainer');
          var shapes = geom.getShapes();
          var activeShapes = [];

          if (field) {
            var scale = geom.get('scales')[field];
            Util.each(shapes, function (shape) {
              var origin = self._getShapeData(shape);

              if (origin && _snapEqual(origin[field], value, scale)) {
                activeShapes.push(shape);
              }
            });
          } else if (geom.getYScale().field === value) {
            activeShapes = shapes;
          }

          if (!Util.isEmpty(activeShapes)) {
            ev.shapes = activeShapes;
            ev.geom = geom;

            if (options.onHover) {
              options.onHover(ev);
              shapeContainer.sort();
              canvas.draw();
            } else {
              geom.setShapesActived(activeShapes);
            }
          }
        });
        self.pre = value;
      } else if (pre === value) {
        return;
      }
    });
    legend.on('itemunhover', function (ev) {
      self.pre = null;

      if (options.onUnhover) {
        options.onUnhover(ev);
      }

      Util.each(geoms, function (geom) {
        if (geom.get('activeShapes')) {
          geom.clearActivedShapes();
          canvas.draw();
        }
      });
    });
  };

  _proto._isFiltered = function _isFiltered(scale, filterVals, scaleValue) {
    if (!scale.isCategory) {
      return true;
    }

    var rst = true;
    scaleValue = scale.invert(scaleValue);
    Util.each(filterVals, function (val) {
      if (scale.getText(val) === scale.getText(scaleValue)) {
        rst = false;
        return false;
      }
    });
    return rst;
  };

  _proto._alignLegend = function _alignLegend(legend, pre, region, position) {
    var self = this;
    var viewTheme = self.viewTheme;
    var container = self.container;
    var canvas = container.get('canvas');
    var width = canvas.get('width');
    var height = canvas.get('height');
    var totalRegion = self.totalRegion;
    var plotRange = self.plotRange;
    var backRange = self.getBackRange(); // 鑳屾櫙鍗犲緱鑼冨洿

    var offsetX = legend.get('offset')[0] || 0;
    var offsetY = legend.get('offset')[1] || 0; // const offset = Util.isNil(legend.get('offset')) ? MARGIN : legend.get('offset');

    var legendHeight = legend.getHeight();
    var legendWidth = legend.getWidth();
    var borderMargin = viewTheme.legend.margin;
    var innerMargin = viewTheme.legend.legendMargin;
    var legendNum = self.legends[position].length;
    var posArray = position.split('-');
    var x = 0;
    var y = 0;
    var tempoRegion = legendNum > 1 ? totalRegion : region;

    if (posArray[0] === 'left' || posArray[0] === 'right') {
      height = plotRange.br.y;
      x = self._getXAlign(posArray[0], width, region, backRange, legendWidth, borderMargin);

      if (pre) {
        // @2018-10-19 by blue.lb 鐢变簬legend涓苟涓嶅瓨鍦▂灞炴€э紝杩欓噷闇€瑕佸厛鑾峰彇group鍐嶈幏鍙杫鍊�
        // @2019-03-21 by blue.lb 鐢变簬鍐呴儴瀹炵幇闂锛寀sehtml閮ㄥ垎鐨勫疄渚嬪彲浠ョ洿鎺ヨ幏鍙杧銆亂鐨�
        y = (pre.get('y') || pre.get('group').get('y')) + pre.getHeight() + innerMargin;
      } else {
        y = self._getYAlignVertical(posArray[1], height, tempoRegion, backRange, 0, borderMargin, canvas.get('height'));
      }
    } else if (posArray[0] === 'top' || posArray[0] === 'bottom') {
      y = self._getYAlignHorizontal(posArray[0], height, region, backRange, legendHeight, borderMargin);

      if (pre) {
        var preWidth = pre.getWidth(); // @2018-10-19 by blue.lb 鐢变簬legend涓苟涓嶅瓨鍦▁灞炴€э紝杩欓噷闇€瑕佸厛鑾峰彇group鍐嶈幏鍙杧鍊�
        // @2019-03-21 by blue.lb 鐢变簬鍐呴儴瀹炵幇闂锛寀sehtml閮ㄥ垎鐨勫疄渚嬪彲浠ョ洿鎺ヨ幏鍙杧銆亂鐨�

        x = (pre.get('x') || pre.get('group').get('x')) + preWidth + innerMargin;
      } else {
        x = self._getXAlign(posArray[1], width, tempoRegion, backRange, 0, borderMargin);
        if (posArray[1] === 'right') x = plotRange.br.x - tempoRegion.totalWidth;
      }
    }

    legend.move(x + offsetX, y + offsetY);
  };

  _proto._getXAlign = function _getXAlign(pos, width, region, backRange, legendWidth, borderMargin) {
    var leftPos = backRange.minX - legendWidth - borderMargin[3] < 0 ? 0 : backRange.minX - legendWidth - borderMargin[3];
    var x = pos === 'left' ? leftPos : backRange.maxX + borderMargin[1];

    if (pos === 'center') {
      x = (width - region.totalWidth) / 2;
    }

    return x;
  };

  _proto._getYAlignHorizontal = function _getYAlignHorizontal(pos, height, region, backRange, legendHeight, borderMargin) {
    var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : backRange.maxY + borderMargin[2];
    return y;
  };

  _proto._getYAlignVertical = function _getYAlignVertical(pos, height, region, backRange, legendHeight, borderMargin, canvasHeight) {
    var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : height - region.totalHeight;

    if (pos === 'center') {
      y = (canvasHeight - region.totalHeight) / 2;
    }

    return y;
  };

  _proto._getSubRegion = function _getSubRegion(legends) {
    var maxWidth = 0;
    var maxHeight = 0;
    var totalWidth = 0;
    var totalHeight = 0;
    Util.each(legends, function (legend) {
      var width = legend.getWidth();
      var height = legend.getHeight();

      if (maxWidth < width) {
        maxWidth = width;
      }

      totalWidth += width;

      if (maxHeight < height) {
        maxHeight = height;
      }

      totalHeight += height;
    });
    return {
      maxWidth: maxWidth,
      totalWidth: totalWidth,
      maxHeight: maxHeight,
      totalHeight: totalHeight
    };
  };

  _proto._getRegion = function _getRegion() {
    var self = this;
    var viewTheme = self.viewTheme;
    var legends = self.legends;
    var innerMargin = viewTheme.legend.legendMargin;
    var subs = [];
    var totalWidth = 0;
    var totalHeight = 0;
    Util.each(legends, function (legendItems) {
      var subRegion = self._getSubRegion(legendItems);

      subs.push(subRegion);
      totalWidth += subRegion.totalWidth + innerMargin;
      totalHeight += subRegion.totalHeight + innerMargin;
    });
    return {
      totalWidth: totalWidth,
      totalHeight: totalHeight,
      subs: subs
    };
  };

  _proto._addCategoryLegend = function _addCategoryLegend(scale, attr, geom, filterVals, position) {
    var self = this;
    var field = scale.field;
    var legendOptions = self.options;
    var fieldOption = legendOptions[field];

    if (fieldOption) {
      legendOptions = fieldOption;
    }

    var legends = self.legends;
    legends[position] = legends[position] || [];
    var container = self.container;
    var items = [];
    var ticks = scale.getTicks();
    var isByAttr = true;
    var shapeType = geom.get('shapeType') || 'point';
    var shape = geom.getDefaultValue('shape') || 'circle';

    if (legendOptions[field] && legendOptions[field].marker) {
      // 鐢ㄦ埛涓� field 瀵瑰簲鐨勫浘渚嬪畾涔変簡 marker
      shape = legendOptions[field].marker;
      shapeType = 'point';
      isByAttr = false;
    } else if (legendOptions.marker) {
      shape = legendOptions.marker;
      shapeType = 'point';
      isByAttr = false;
    }

    var chart = self.chart;
    var viewTheme = self.viewTheme;
    var canvas = chart.get('canvas');
    var plotRange = self.plotRange;
    var posArray = position.split('-');
    var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');
    Util.each(ticks, function (tick) {
      var text = tick.text;
      var name = text;
      var scaleValue = tick.value;
      var value = scale.invert(scaleValue);
      var cfg = {
        isInCircle: geom.isInCircle()
      };
      var checked = filterVals ? self._isFiltered(scale, filterVals, scaleValue) : true;
      var colorAttr = geom.getAttr('color');
      var shapeAttr = geom.getAttr('shape');

      if (colorAttr) {
        // 瀛樺湪棰滆壊鏄犲皠
        if (colorAttr.callback && colorAttr.callback.length > 1) {
          // 澶氬弬鏁版槧灏勶紝闃绘绋嬪簭鎶ラ敊
          var restArgs = Array(colorAttr.callback.length - 1).fill('');
          cfg.color = colorAttr.mapping.apply(colorAttr, [value].concat(restArgs)).join('') || viewTheme.defaultColor;
        } else {
          cfg.color = colorAttr.mapping(value).join('') || viewTheme.defaultColor;
        }
      }

      if (isByAttr && shapeAttr) {
        // 瀛樺湪褰㈢姸鏄犲皠
        if (shapeAttr.callback && shapeAttr.callback.length > 1) {
          // 澶氬弬鏁版槧灏勶紝闃绘绋嬪簭鎶ラ敊
          var _restArgs = Array(shapeAttr.callback.length - 1).fill('');

          shape = shapeAttr.mapping.apply(shapeAttr, [value].concat(_restArgs)).join('');
        } else {
          shape = shapeAttr.mapping(value).join('');
        }
      }

      var shapeObject = Shape.getShapeFactory(shapeType);
      var marker = shapeObject.getMarkerCfg(shape, cfg);

      if (Global.legendMarkerRadius) {
        marker.radius = Global.legendMarkerRadius;
      }

      if (Util.isFunction(shape)) {
        marker.symbol = shape;
      }

      items.push({
        value: name,
        // 鍥句緥椤规樉绀烘枃鏈殑鍐呭
        dataValue: value,
        // 鍥句緥椤瑰搴斿師濮嬫暟鎹腑鐨勬暟鍊�
        checked: checked,
        marker: marker
      });
    });
    var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions[field] || legendOptions, {
      viewId: chart.get('_id'),
      maxLength: maxLength,
      items: items,
      container: container,
      position: [0, 0]
    });

    if (legendCfg.title) {
      Util.deepMix(legendCfg, {
        title: {
          text: scale.alias || scale.field
        }
      });
    }

    var legend;

    if (self._isTailLegend(legendOptions, geom)) {
      legendCfg.chart = self.chart;
      legendCfg.geom = geom;
      legend = new Tail(legendCfg);
    } else {
      if (legendOptions.useHtml) {
        var canvasEle = container.get('canvas').get('el');
        container = legendOptions.container;

        if (Util.isString(container) && /^\#/.test(container)) {
          // 濡傛灉浼犲叆 dom 鑺傜偣鐨� id
          var id = container.replace('#', '');
          container = document.getElementById(id);
        }

        if (!container) {
          container = canvasEle.parentNode;
        }

        legendCfg.container = container;
        if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};
        legendCfg.legendStyle.CONTAINER_CLASS = _extends({}, legendCfg.legendStyle.CONTAINER_CLASS, {
          position: 'absolute',
          overflow: 'auto',
          'z-index': canvasEle.style.zIndex === '' ? 1 : parseInt(canvasEle.style.zIndex, 10) + 1
        });

        if (legendOptions.flipPage) {
          legendCfg.legendStyle.CONTAINER_CLASS.height = posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto';
          legendCfg.legendStyle.CONTAINER_CLASS.width = !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto';
          legend = new Legend.CatPageHtml(legendCfg);
        } else {
          legend = new Legend.CatHtml(legendCfg);
        }
      } else {
        legend = new Legend.Category(legendCfg);
      }
    }

    self._bindClickEvent(legend, scale, filterVals);

    legends[position].push(legend);
    return legend;
  };

  _proto._bindChartMove = function _bindChartMove(scale) {
    var chart = this.chart;
    var legends = this.legends;
    chart.on('plotmove', function (ev) {
      var selected = false;

      if (ev.target) {
        var origin = ev.target.get('origin');

        if (origin) {
          var data = origin[FIELD_ORIGIN] || origin[0][FIELD_ORIGIN];
          var field = scale.field;

          if (data) {
            var value = data[field];
            Util.each(legends, function (legendItems) {
              Util.each(legendItems, function (legend) {
                selected = true;
                !legend.destroyed && legend.activate(value);
              });
            });
          }
        }
      }

      if (!selected) {
        Util.each(legends, function (legendItems) {
          Util.each(legendItems, function (legend) {
            !legend.destroyed && legend.deactivate();
          });
        });
      }
    });
  };

  _proto._addContinuousLegend = function _addContinuousLegend(scale, attr, position) {
    var self = this;
    var legends = self.legends;
    legends[position] = legends[position] || [];
    var container = self.container;
    var field = scale.field;
    var ticks = scale.getTicks();
    var items = [];
    var legend;
    var minValue;
    var maxValue;
    var viewTheme = self.viewTheme;
    Util.each(ticks, function (tick) {
      var scaleValue = tick.value;
      var invertValue = scale.invert(scaleValue);
      var attrValue = attr.mapping(invertValue).join('');
      items.push({
        value: tick.tickValue,
        // tick.text
        attrValue: attrValue,
        color: attrValue,
        scaleValue: scaleValue
      });

      if (scaleValue === 0) {
        minValue = true;
      }

      if (scaleValue === 1) {
        maxValue = true;
      }
    });

    if (!minValue) {
      items.push({
        value: scale.min,
        attrValue: attr.mapping(0).join(''),
        color: attr.mapping(0).join(''),
        scaleValue: 0
      });
    }

    if (!maxValue) {
      items.push({
        value: scale.max,
        attrValue: attr.mapping(1).join(''),
        color: attr.mapping(1).join(''),
        scaleValue: 1
      });
    }

    var options = self.options;
    var posArray = position.split('-');
    var defaultCfg = viewTheme.legend[posArray[0]];

    if (options && options.slidable === false || options[field] && options[field].slidable === false) {
      defaultCfg = Util.mix({}, defaultCfg, viewTheme.legend.gradient);
    }

    var legendCfg = Util.deepMix({}, defaultCfg, options[field] || options, {
      items: items,
      attr: attr,
      formatter: scale.formatter,
      container: container,
      position: [0, 0]
    });

    if (legendCfg.title) {
      Util.deepMix(legendCfg, {
        title: {
          text: scale.alias || scale.field
        }
      });
    }

    if (attr.type === 'color') {
      legend = new Legend.Color(legendCfg);
    } else if (attr.type === 'size') {
      if (options && options.sizeType === 'circle') legend = new Legend.CircleSize(legendCfg);else legend = new Legend.Size(legendCfg);
    } else {
      return;
    }

    self._bindFilterEvent(legend, scale);

    legends[position].push(legend);
    return legend;
  };

  _proto._isTailLegend = function _isTailLegend(opt, geom) {
    if (opt.hasOwnProperty('attachLast') && opt.attachLast) {
      var geomType = geom.get('type');
      if (geomType === 'line' || geomType === 'lineStack' || geomType === 'area' || geomType === 'areaStack') return true;
    }

    return false;
  };

  _proto._adjustPosition = function _adjustPosition(position, isTailLegend) {
    var pos;

    if (isTailLegend) {
      pos = 'right-top';
    } else if (Util.isArray(position)) {
      pos = String(position[0]) + '-' + String(position[1]);
    } else {
      var posArr = position.split('-');

      if (posArr.length === 1) {
        // 鍙敤浜唋eft/right/bottom/top涓€涓綅缃畾浣�
        if (posArr[0] === 'left') pos = 'left-bottom';
        if (posArr[0] === 'right') pos = 'right-bottom';
        if (posArr[0] === 'top') pos = 'top-center';
        if (posArr[0] === 'bottom') pos = 'bottom-center';
      } else {
        pos = position;
      }
    }

    return pos;
  };

  _proto.addLegend = function addLegend(scale, attr, geom, filterVals) {
    var self = this;
    var legendOptions = self.options;
    var field = scale.field;
    var fieldOption = legendOptions[field];
    var viewTheme = self.viewTheme;

    if (fieldOption === false) {
      // 濡傛灉涓嶆樉绀烘鍥句緥
      return null;
    }

    if (fieldOption && fieldOption.custom) {
      self.addCustomLegend(field);
    } else {
      var position = legendOptions.position || viewTheme.defaultLegendPosition;
      position = self._adjustPosition(position, self._isTailLegend(legendOptions, geom));

      if (fieldOption && fieldOption.position) {
        // 濡傛灉瀵规煇涓浘渚嬪崟鐙缃� position锛屽垯瀵� position 閲嶆柊璧嬪€�
        position = self._adjustPosition(fieldOption.position, self._isTailLegend(fieldOption, geom));
      }

      var legend;

      if (scale.isLinear) {
        legend = self._addContinuousLegend(scale, attr, position);
      } else {
        legend = self._addCategoryLegend(scale, attr, geom, filterVals, position);
      }

      if (legend) {
        self._bindHoverEvent(legend, field);

        legendOptions.reactive && self._bindChartMove(scale);
      }
    }
  }
  /**
   * 鑷畾涔夊浘渚�
   * @param {string} field 鑷畾涔夊浘渚嬬殑鏁版嵁瀛楁鍚嶏紝鍙互涓虹┖
   * @return {object} legend 鑷畾涔夊浘渚嬪疄渚�
   */
  ;

  _proto.addCustomLegend = function addCustomLegend(field) {
    var self = this;
    var chart = self.chart;
    var viewTheme = self.viewTheme;
    var container = self.container;
    var legendOptions = self.options;

    if (field) {
      legendOptions = legendOptions[field];
    }

    var position = legendOptions.position || viewTheme.defaultLegendPosition;
    position = self._adjustPosition(position);
    var legends = self.legends;
    legends[position] = legends[position] || [];
    var items = legendOptions.items;

    if (!items) {
      return;
    }

    var geoms = chart.getAllGeoms();
    Util.each(items, function (item) {
      var geom = findGeom(geoms, item.value);

      if (!Util.isPlainObject(item.marker)) {
        // 鐩存帴浼犲叆瀛楃涓叉垨鑰呭洖璋冨嚱鏁版椂杞崲涓哄璞★紝濡� item.marker = 'circle'
        item.marker = {
          symbol: item.marker || 'circle',
          radius: Global.legendMarkerRadius || MARKER_SIZE
        };

        if (Util.indexOf(STROKE_MARKERS, item.marker.symbol) !== -1) {
          item.marker.stroke = item.fill;
        } else {
          item.marker.fill = item.fill;
        }
      } else {
        // 鐢ㄦ埛浼犲叆瀵硅薄 item.marker = { symbol: 'circle', fill: 'red', radius: 3 }
        item.marker.radius = item.marker.radius || Global.legendMarkerRadius || MARKER_SIZE;
      }

      var symbol = item.marker.symbol;

      if (Util.isString(symbol) && symbol.indexOf('hollow') !== -1) {
        item.marker.symbol = Util.lowerFirst(symbol.substr(6));
      }

      item.checked = Util.isNil(item.checked) ? true : item.checked;
      item.geom = geom;
    });
    var canvas = chart.get('canvas');
    var plotRange = self.plotRange;
    var posArray = position.split('-');
    var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');
    var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions, {
      maxLength: maxLength,
      items: items,
      container: container,
      position: [0, 0]
    });
    var legend;

    if (legendOptions.useHtml) {
      var htmlContainer = legendOptions.container;

      if (/^\#/.test(container)) {
        // 濡傛灉浼犲叆 dom 鑺傜偣鐨� id
        var id = htmlContainer.replace('#', '');
        htmlContainer = document.getElementById(id);
      } else if (!htmlContainer) {
        htmlContainer = container.get('canvas').get('el').parentNode;
      }

      legendCfg.container = htmlContainer;
      if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};

      if (!legendCfg.legendStyle.CONTAINER_CLASS) {
        legendCfg.legendStyle.CONTAINER_CLASS = {
          height: posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto',
          width: !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto',
          position: 'absolute',
          overflow: 'auto'
        };
      }

      if (legendOptions.flipPage) legend = new Legend.CatPageHtml(legendCfg);else legend = new Legend.CatHtml(legendCfg);
    } else legend = new Legend.Category(legendCfg);

    legends[position].push(legend);
    legend.on('itemclick', function (ev) {
      if (legendOptions.onClick) {
        // 鐢ㄦ埛鑷畾涔変簡鍥句緥鐐瑰嚮浜嬩欢
        legendOptions.onClick(ev);
      }
    });

    self._bindHoverEvent(legend);

    return legend;
  };

  _proto.addMixedLegend = function addMixedLegend(scales, geoms) {
    var self = this;
    var legendOptions = self.options;
    var items = [];
    Util.each(scales, function (scale) {
      var value = scale.alias || scale.field;
      var fieldLegendOptions = legendOptions[scale.field];
      Util.each(geoms, function (geom) {
        if (geom.getYScale() === scale && scale.values && scale.values.length > 0 && fieldLegendOptions !== false) {
          var shapeType = geom.get('shapeType') || 'point';
          var shape = geom.getDefaultValue('shape') || 'circle';
          var shapeObject = Shape.getShapeFactory(shapeType);
          var cfg = {
            color: geom.getDefaultValue('color')
          };
          var marker = shapeObject.getMarkerCfg(shape, cfg);

          if (Global.legendMarkerRadius) {
            marker.radius = Global.legendMarkerRadius;
          }

          var item = {
            value: value,
            marker: marker,
            field: scale.field
          };
          items.push(item);
        }
      }); // end of geom loop
    }); // end of scale loop

    var options = {
      custom: true,
      items: items
    };
    self.options = Util.deepMix({}, options, self.options);
    var legend = self.addCustomLegend();

    self._bindClickEventForMix(legend);
  };

  _proto.alignLegends = function alignLegends() {
    var self = this;
    var legends = self.legends;

    var totalRegion = self._getRegion(legends);

    self.totalRegion = totalRegion;
    var i = 0;
    Util.each(legends, function (legendItems, position) {
      var region =
      /* self._getRegion(legendItems)*/
      totalRegion.subs[i];
      Util.each(legendItems, function (legend, index) {
        var pre = legendItems[index - 1];

        if (!(legend.get('useHtml') && !legend.get('autoPosition'))) {
          self._alignLegend(legend, pre, region, position);
        }
      });
      i++;
    });
    return this;
  };

  return LegendController;
}();

module.exports = LegendController;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 搴﹂噺鐨勬帶鍒跺櫒
 * @author dxq613@gmail.com
 */
var Scale = __webpack_require__(154);

var Util = __webpack_require__(0);

var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
var TYPES = {
  LINEAR: 'linear',
  CAT: 'cat',
  TIME: 'time'
};

var ScaleController = /*#__PURE__*/function () {
  function ScaleController(cfg) {
    // defs 鍒楀畾涔�
    this.defs = {};
    this.viewTheme = {
      scales: {}
    }; // filtered fields

    this.filters = {};
    Util.assign(this, cfg);
  }

  var _proto = ScaleController.prototype;

  _proto._getDef = function _getDef(field) {
    var defs = this.defs;
    var viewTheme = this.viewTheme;
    var def = null;

    if (viewTheme.scales[field] || defs[field]) {
      def = Util.mix({}, viewTheme.scales[field]); // 澶勭悊瑕嗙洊灞炴€х殑闂

      Util.each(defs[field], function (v, k) {
        if (Util.isNil(v)) {
          delete def[k];
        } else {
          def[k] = v;
        }
      });

      if (this.filters[field]) {
        delete def.min;
        delete def.max;
      }
    }

    return def;
  };

  _proto._getDefaultType = function _getDefaultType(field, data) {
    var type = TYPES.LINEAR;
    var value = Util.Array.firstValue(data, field);

    if (Util.isArray(value)) {
      value = value[0];
    }

    if (dateRegex.test(value)) {
      type = TYPES.TIME;
    } else if (Util.isString(value)) {
      type = TYPES.CAT;
    }

    return type;
  };

  _proto._getScaleCfg = function _getScaleCfg(type, field, data) {
    var cfg = {
      field: field
    };
    var values = Util.Array.values(data, field);
    cfg.values = values;

    if (!Scale.isCategory(type) && type !== 'time') {
      var range = Util.Array.getRange(values);
      cfg.min = range.min;
      cfg.max = range.max;
      cfg.nice = true;
    }

    if (type === 'time') {
      cfg.nice = false;
    }

    return cfg;
  };

  _proto.createScale = function createScale(field, data) {
    var self = this;

    var def = self._getDef(field);

    var scale;
    var validData = data || [];
    var firstValue = Util.Array.firstValue(validData, field);

    if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {
      scale = Scale.identity({
        value: field,
        field: field.toString(),
        values: [field]
      });
    } else {
      // 濡傛灉宸茬粡瀹氫箟杩囪繖涓害閲�
      var type;

      if (def) {
        type = def.type;
      }

      type = type || self._getDefaultType(field, validData);

      var cfg = self._getScaleCfg(type, field, validData);

      if (def) {
        Util.mix(cfg, def);
      }

      scale = Scale[type](cfg);
    }

    return scale;
  };

  return ScaleController;
}();

module.exports = ScaleController;

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * @fileOverview The controller of tooltip
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var _require = __webpack_require__(30),
    Tooltip = _require.Tooltip;

var MatrixUtil = Util.MatrixUtil;
var Vector2 = MatrixUtil.vec2;
var TYPE_SHOW_MARKERS = ['line', 'area', 'path', 'areaStack']; // 榛樿灞曠ず tooltip marker 鐨勫嚑浣曞浘褰�

var TYPE_SHOW_CROSSHAIRS = ['line', 'area']; // 榛樿灞曠ず鍗佸瓧鐬勫噯绾跨殑鍑犱綍鍥惧舰
// TODO FIXME this is HARD CODING

var IGNORE_TOOLTIP_ITEM_PROPERTIES = ['marker', 'showMarker'];

function _indexOfArray(items, item) {
  var rst = -1;
  Util.each(items, function (sub, index) {
    var isEqual = true;

    for (var key in item) {
      if (item.hasOwnProperty(key) && !IGNORE_TOOLTIP_ITEM_PROPERTIES.includes(key)) {
        if (!Util.isObject(item[key]) && item[key] !== sub[key]) {
          isEqual = false;
          break;
        }
      }
    }

    if (isEqual) {
      rst = index;
      return false;
    }
  });
  return rst;
} // 鍒ゆ柇鏄惁鏈夋牱寮�


function _hasClass(dom, className) {
  if (!dom) {
    return false;
  }

  var cls = '';
  if (!dom.className) return false;

  if (!Util.isNil(dom.className.baseVal)) {
    cls = dom.className.baseVal;
  } else {
    cls = dom.className;
  }

  return cls.includes(className);
}

function _isParent(dom, cls) {
  var parent = dom.parentNode;
  var rst = false;

  while (parent && parent !== document.body) {
    if (_hasClass(parent, cls)) {
      rst = true;
      break;
    }

    parent = parent.parentNode;
  }

  return rst;
} // 鍘婚櫎閲嶅鐨勫€�, 鍘婚櫎涓嶅悓鍥惧舰鐩稿悓鏁版嵁锛屽彧灞曠ず涓€浠藉嵆鍙�


function _uniqItems(items) {
  var tmp = [];
  Util.each(items, function (item) {
    var index = _indexOfArray(tmp, item);

    if (index === -1) {
      tmp.push(item);
    } else {
      tmp[index] = item;
    }
  });
  return tmp;
}

var TooltipController = /*#__PURE__*/function () {
  function TooltipController(cfg) {
    Util.assign(this, cfg);
    this.timeStamp = 0; // tooltip 閿佸畾涓嶈兘绉诲姩

    this.locked = false;
  }

  var _proto = TooltipController.prototype;

  _proto._normalizeEvent = function _normalizeEvent(event) {
    var chart = this.chart;

    var canvas = this._getCanvas();

    var point = canvas.getPointByClient(event.clientX, event.clientY);
    var pixelRatio = canvas.get('pixelRatio');
    point.x = point.x / pixelRatio;
    point.y = point.y / pixelRatio;
    var views = chart.getViewsByPoint(point);
    point.views = views;
    return point;
  };

  _proto._getCanvas = function _getCanvas() {
    return this.chart.get('canvas');
  };

  _proto._getTriggerEvent = function _getTriggerEvent() {
    var options = this.options;
    var triggerOn = options.triggerOn;
    var eventName;

    if (!triggerOn || triggerOn === 'mousemove') {
      eventName = 'plotmove';
    } else if (triggerOn === 'click') {
      eventName = 'plotclick';
    } else if (triggerOn === 'none') {
      eventName = null;
    }

    return eventName;
  };

  _proto._getDefaultTooltipCfg = function _getDefaultTooltipCfg() {
    var self = this;
    var chart = self.chart;
    var viewTheme = self.viewTheme;
    var options = self.options;
    var defaultCfg = Util.mix({}, viewTheme.tooltip);
    var geoms = chart.getAllGeoms().filter(function (geom) {
      return geom.get('visible');
    });
    var shapes = [];
    Util.each(geoms, function (geom) {
      var type = geom.get('type');
      var adjusts = geom.get('adjusts');
      var isSymmetric = false;

      if (adjusts) {
        Util.each(adjusts, function (adjust) {
          if (adjust.type === 'symmetric' || adjust.type === 'Symmetric') {
            isSymmetric = true;
            return false;
          }
        });
      }

      if (Util.indexOf(shapes, type) === -1 && !isSymmetric) {
        shapes.push(type);
      }
    });
    var isTransposed = geoms.length && geoms[0].get('coord') ? geoms[0].get('coord').isTransposed : false;
    var crosshairsCfg;

    if (geoms.length && geoms[0].get('coord') && geoms[0].get('coord').type === 'cartesian') {
      if (shapes[0] === 'interval' && options.shared !== false) {
        // 鐩磋鍧愭爣绯讳笅 interval 鐨� crosshair 涓虹煩褰㈣儗鏅
        var crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsRect);
        crosshairs.isTransposed = isTransposed;
        crosshairsCfg = {
          zIndex: 0,
          // 鐭╁舰鑳屾櫙妗嗕笉鍙鐩� geom
          crosshairs: crosshairs
        };
      } else if (Util.indexOf(TYPE_SHOW_CROSSHAIRS, shapes[0]) > -1) {
        var _crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsLine);

        _crosshairs.isTransposed = isTransposed;
        crosshairsCfg = {
          crosshairs: _crosshairs
        };
      }
    }

    return Util.mix(defaultCfg, crosshairsCfg, {});
  };

  _proto._bindEvent = function _bindEvent() {
    var chart = this.chart;

    var triggerEvent = this._getTriggerEvent();

    if (triggerEvent) {
      chart.on(triggerEvent, Util.wrapBehavior(this, 'onMouseMove'));
      chart.on('plotleave', Util.wrapBehavior(this, 'onMouseOut'));
    }
  };

  _proto._offEvent = function _offEvent() {
    var chart = this.chart;

    var triggerEvent = this._getTriggerEvent();

    if (triggerEvent) {
      chart.off(triggerEvent, Util.getWrapBehavior(this, 'onMouseMove'));
      chart.off('plotleave', Util.getWrapBehavior(this, 'onMouseOut'));
    }
  };

  _proto._setTooltip = function _setTooltip(point, items, markersItems, target) {
    var self = this;
    var tooltip = self.tooltip;
    var prePoint = self.prePoint;

    if (!prePoint || prePoint.x !== point.x || prePoint.y !== point.y) {
      items = _uniqItems(items);
      self.prePoint = point;
      var chart = self.chart;
      var viewTheme = self.viewTheme;
      var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
      var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;

      if (!tooltip.get('visible')) {
        chart.emit('tooltip:show', {
          x: x,
          y: y,
          tooltip: tooltip
        });
      }

      var first = items[0];
      var title = first.title || first.name;

      if (tooltip.isContentChange(title, items)) {
        chart.emit('tooltip:change', {
          tooltip: tooltip,
          x: x,
          y: y,
          items: items
        }); // bugfix: when set the title in the tooltip:change event does not take effect.

        title = items[0].title || items[0].name;
        tooltip.setContent(title, items);

        if (!Util.isEmpty(markersItems)) {
          if (self.options.hideMarkers === true) {
            // 涓嶅睍绀� tooltip marker
            tooltip.set('markerItems', markersItems); // 鐢ㄤ簬 tooltip 杈呭姪绾跨殑瀹氫綅
          } else {
            tooltip.setMarkers(markersItems, viewTheme.tooltipMarker);
          }
        } else {
          tooltip.clearMarkers(); // clearMarkers 鍙細灏� markerItems 浠� markerGroup 涓Щ闄�
          // 鎵€浠ユ垜浠繕瑕佸皢 markerItems 浠� tooltip 涓Щ闄�
          // 杩欎箞鍋氭槸涓轰簡闃叉涓婁竴娆¤缃� marker 鏃剁殑 markerItems 褰卞搷姝ゆ tooltip 杈呭姪绾跨殑瀹氫綅

          tooltip.set('markerItems', []);
        }
      }

      var canvas = this._getCanvas();

      if (target === canvas && tooltip.get('type') === 'mini') {
        // filter mini tooltip
        tooltip.hide();
      } else {
        tooltip.setPosition(x, y, target);
        tooltip.show();
      }
    }
  };

  _proto.hideTooltip = function hideTooltip() {
    var tooltip = this.tooltip;
    var chart = this.chart;

    var canvas = this._getCanvas();

    this.prePoint = null;
    tooltip.hide();
    chart.emit('tooltip:hide', {
      tooltip: tooltip
    });
    canvas.draw();
  };

  _proto.onMouseMove = function onMouseMove(ev) {
    // 閿佸畾鏃朵笉绉诲姩 tooltip
    if (Util.isEmpty(ev.views) || this.locked) {
      return;
    }

    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var point = {
      x: ev.x,
      y: ev.y
    };

    if (timeStamp - lastTimeStamp > 16 && !this.chart.get('stopTooltip')) {
      this.showTooltip(point, ev.views, ev.shape);
      this.timeStamp = timeStamp;
    }
  };

  _proto.onMouseOut = function onMouseOut(ev) {
    var tooltip = this.tooltip; // 閿佸畾 tooltip 鏃朵笉闅愯棌

    if (!tooltip.get('visible') || !tooltip.get('follow') || this.locked) {
      return;
    } // 闄ら潪绂诲紑 plot 鏃堕紶鏍囦緷鐒跺湪鍥惧舰涓婏紝杩欐閫昏緫娌℃湁鎰忎箟
    // if (ev && ev.target !== canvas) {
    //   return;
    // }


    if (ev && ev.toElement && (_hasClass(ev.toElement, 'g2-tooltip') || _isParent(ev.toElement, 'g2-tooltip'))) {
      return;
    }

    this.hideTooltip();
  };

  _proto.renderTooltip = function renderTooltip() {
    var self = this;

    if (self.tooltip) {
      // tooltip 瀵硅薄宸茬粡鍒涘缓
      return;
    }

    var chart = self.chart;
    var viewTheme = self.viewTheme;

    var canvas = self._getCanvas();

    var defaultCfg = self._getDefaultTooltipCfg();

    var options = self.options;
    options = Util.deepMix({
      plotRange: chart.get('plotRange'),
      capture: false,
      canvas: canvas,
      frontPlot: chart.get('frontPlot'),
      viewTheme: viewTheme.tooltip,
      backPlot: chart.get('backPlot')
    }, defaultCfg, options);

    if (options.crosshairs && options.crosshairs.type === 'rect') {
      options.zIndex = 0; // toolip 鑳屾櫙妗嗕笉鍙伄鐩栦綇 geom锛岄槻姝㈢敤鎴烽厤缃簡 crosshairs
    }

    options.visible = false; // @2018-09-13 by blue.lb 濡傛灉璁剧疆shared涓篺alse涓嶉渶瑕佹寚瀹歱osition
    // if (options.shared === false && Util.isNil(options.position)) {
    //   options.position = 'top';
    // }

    var tooltip;

    if (options.type === 'mini') {
      options.crosshairs = false; // this.options.shared = false;

      options.position = 'top';
      tooltip = new Tooltip.Mini(options);
    } else if (options.useHtml) {
      tooltip = new Tooltip.Html(options);
    } else {
      tooltip = new Tooltip.Canvas(options);
    }

    self.tooltip = tooltip;

    var triggerEvent = self._getTriggerEvent();

    var tooltipContainer = tooltip.get('container');

    if (!tooltip.get('enterable') && triggerEvent === 'plotmove') {
      // 榧犳爣涓嶅厑璁歌繘鍏� tooltip 瀹瑰櫒
      if (tooltipContainer) {
        tooltipContainer.onmousemove = function (e) {
          // 閬垮厤 tooltip 棰戠箒闂儊
          var eventObj = self._normalizeEvent(e);

          chart.emit(triggerEvent, eventObj);
        };
      }
    } // 浼樺寲锛氶紶鏍囩Щ鍏� tooltipContainer 鐒跺悗鍐嶇Щ鍑烘椂锛岄渶瑕侀殣钘� tooltip


    if (tooltipContainer) {
      tooltipContainer.onmouseleave = function () {
        if (!self.locked) {
          self.hideTooltip();
        }
      };
    }

    self._bindEvent();
  };

  _proto._formatMarkerOfItem = function _formatMarkerOfItem(coord, geom, item) {
    var self = this;
    var options = self.options;
    var point = item.point;

    if (point && point.x && point.y) {
      // hotfix: make sure there is no null value
      var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
      var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
      point = coord.applyMatrix(x, y, 1);
      item.x = point[0];
      item.y = point[1];
      item.showMarker = true; // bugfix
      // 鐢变簬tooltip鏄疍OM鑰屼笉鏄疌anvas锛岃缃笎鍙樿壊鏃讹紝marker鏃犳硶姝ｅ父鏄剧ず
      // 濡傛灉锛岃缃殑棰滆壊鏄笎鍙樿壊骞朵笖璁剧疆浜唗ooltip浣跨敤html鏂瑰紡娓叉煋锛屽垯鍙栨笎鍙樿壊鐨勮捣濮嬮鑹蹭綔涓簃arker鐨勯鑹诧紝鏆傛椂瑙ｅ喅杩欎釜闂

      if (item.color.substring(0, 2) === 'l(' && (!options.hasOwnProperty('useHtml') || options.useHtml)) {
        item.color = item.color.split(' ')[1].substring(2);
      }

      var itemMarker = self._getItemMarker(geom, item);

      item.marker = itemMarker;

      if (Util.indexOf(TYPE_SHOW_MARKERS, geom.get('type')) !== -1) {
        return item;
      }
    }

    return null;
  };

  _proto.lockTooltip = function lockTooltip() {
    this.locked = true;
  };

  _proto.unlockTooltip = function unlockTooltip() {
    this.locked = false;
  };

  _proto.showTooltip = function showTooltip(point, views, target) {
    var _this = this;

    var self = this;

    if (Util.isEmpty(views) || !point) {
      return;
    }

    if (!this.tooltip) {
      this.renderTooltip(); // 濡傛灉涓€寮€濮� tooltip 鍏抽棴锛岀敤鎴烽噸鏂拌皟鐢ㄧ殑鏃跺€欓渶瑕佸厛鐢熸垚 tooltip
    }

    var options = self.options;
    var markersItems = [];
    var items = [];
    Util.each(views, function (view) {
      if (!view.get('tooltipEnable')) {
        // 濡傛灉涓嶆樉绀簍ooltip锛屽垯璺宠繃
        return true;
      }

      var geoms = view.get('geoms');
      var coord = view.get('coord');
      Util.each(geoms, function (geom) {
        var type = geom.get('type');

        if (geom.get('visible') && geom.get('tooltipCfg') !== false) {
          var dataArray = geom.get('dataArray');

          if (geom.isShareTooltip() || options.shared === false && Util.inArray(['area', 'line', 'path', 'polygon'], type)) {
            // 鎵撹ˉ涓佽В鍐� bug: https://github.com/antvis/g2/issues/1248
            // 褰� interval 瀵瑰簲鐨� color 鍜� x 瀛楁鐩稿悓鐨勬椂鍊欙紝骞朵笖鍖呭惈 dodge锛宨tems 鍙栧€奸€昏緫涓嶄竴鏍�
            // 杩欑鎯呭喌涓嬶紝姣忎竴涓� x 瀛楁鍒嗘垚涓€缁�
            var xScale = geom.getXScale();
            var colorAttr = geom.getAttr('color');
            var colorField = colorAttr ? colorAttr.field : undefined;

            if (type === 'interval' && xScale.field === colorField && geom.hasAdjust('dodge')) {
              // 鎵句笉鍒颁笉涓虹┖鐨�
              var points = Util.find(dataArray, function (obj) {
                return !!geom.findPoint(point, obj);
              }); // 杞负 tooltip items

              Util.each(points, function (tmpPoint) {
                var subItems = geom.getTipItems(tmpPoint, options.title);
                Util.each(subItems, function (v) {
                  var markerItem = self._formatMarkerOfItem(coord, geom, v);

                  if (markerItem) {
                    markersItems.push(markerItem);
                  }
                });
                items = items.concat(subItems);
              });
            } else {
              Util.each(dataArray, function (obj) {
                var tmpPoint = geom.findPoint(point, obj);

                if (tmpPoint) {
                  var subItems = geom.getTipItems(tmpPoint, options.title);
                  Util.each(subItems, function (v) {
                    var markerItem = self._formatMarkerOfItem(coord, geom, v);

                    if (markerItem) {
                      markersItems.push(markerItem);
                    }
                  });
                  items = items.concat(subItems);
                }
              });
            }
          } else {
            var geomContainer = geom.get('shapeContainer');
            var canvas = geomContainer.get('canvas');
            var pixelRatio = canvas.get('pixelRatio');
            var shape = geomContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);

            if (shape && shape.get('visible') && shape.get('origin')) {
              items = geom.getTipItems(shape.get('origin'), options.title);
            }

            Util.each(items, function (v) {
              var markerItem = _this._formatMarkerOfItem(coord, geom, v);

              if (markerItem) {
                markersItems.push(markerItem);
              }
            });
          }
        }
      });
      Util.each(items, function (item) {
        var point = item.point;
        var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;
        var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;
        point = coord.applyMatrix(x, y, 1);
        item.x = point[0];
        item.y = point[1];
      });
    });

    if (items.length) {
      var first = items[0]; // bugfix: multiple tooltip items with different titles

      if (!items.every(function (item) {
        return item.title === first.title;
      })) {
        var nearestItem = first;
        var nearestDistance = Infinity;
        items.forEach(function (item) {
          var distance = Vector2.distance([point.x, point.y], [item.x, item.y]);

          if (distance < nearestDistance) {
            nearestDistance = distance;
            nearestItem = item;
          }
        });
        items = items.filter(function (item) {
          return item.title === nearestItem.title;
        });
        markersItems = markersItems.filter(function (item) {
          return item.title === nearestItem.title;
        });
      }

      if (options.shared === false && items.length > 1) {
        var snapItem = items[0];
        var min = Math.abs(point.y - snapItem.y);
        Util.each(items, function (aItem) {
          if (Math.abs(point.y - aItem.y) <= min) {
            snapItem = aItem;
            min = Math.abs(point.y - aItem.y);
          }
        });

        if (snapItem && snapItem.x && snapItem.y) {
          markersItems = [snapItem];
        }

        items = [snapItem];
      } // 3.0 閲囩敤褰撳墠榧犳爣浣嶇疆浣滀负 tooltip 鐨勫弬鑰冪偣
      // if (!Util.isEmpty(markersItems)) {
      //   point = markersItems[0];
      // }


      self._setTooltip(point, items, markersItems, target);
    } else {
      self.hideTooltip();
    }
  };

  _proto.clear = function clear() {
    var tooltip = this.tooltip;
    tooltip && tooltip.destroy();
    this.tooltip = null;
    this.prePoint = null;

    this._offEvent();
  };

  _proto._getItemMarker = function _getItemMarker(geom, item) {
    var options = this.options;
    var markerOption = options.marker || this.viewTheme.tooltip.marker;

    if (Util.isFunction(markerOption)) {
      var shapeType = geom.get('shapeType') || 'point';
      var shape = geom.getDefaultValue('shape') || 'circle';
      var shapeObject = Shape.getShapeFactory(shapeType);
      var cfg = {
        color: item.color
      };
      var marker = shapeObject.getMarkerCfg(shape, cfg);
      return markerOption(marker, item);
    }

    return _extends({
      fill: item.color
    }, markerOption);
  };

  return TooltipController;
}();

module.exports = TooltipController;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview view
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(120);

var Geom = __webpack_require__(8);

var Util = __webpack_require__(0);

var Controller = __webpack_require__(121);

var Global = __webpack_require__(5);

var Theme = __webpack_require__(132);

var FIELD_ORIGIN = '_origin';

var Animate = __webpack_require__(271);

function isFullCircle(coord) {
  var startAngle = coord.startAngle;
  var endAngle = coord.endAngle;

  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {
    return false;
  }

  return true;
}

function isBetween(value, start, end) {
  var tmp = (value - start) / (end - start);
  return tmp >= 0 && tmp <= 1;
}

function isPointInCoord(coord, point) {
  var result = false;

  if (coord) {
    var type = coord.type;

    if (type === 'theta') {
      var start = coord.start;
      var end = coord.end;
      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);
    } else {
      var invertPoint = coord.invert(point);
      result = invertPoint.x >= 0 && invertPoint.y >= 0 && invertPoint.x <= 1 && invertPoint.y <= 1;
    }
  }

  return result;
}

var ViewGeoms = {};
Util.each(Geom, function (geomConstructor, className) {
  var methodName = Util.lowerFirst(className);

  ViewGeoms[methodName] = function (cfg) {
    var geom = new geomConstructor(cfg);
    this.addGeom(geom);
    return geom;
  };
});
/**
 * 鍥捐〃涓殑瑙嗗浘
 * @class View
 */

var View = /*#__PURE__*/function (_Base) {
  _inheritsLoose(View, _Base);

  var _proto = View.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      viewContainer: null,
      coord: null,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 1,
        y: 1
      },
      geoms: [],
      scales: {},
      options: {},
      scaleController: null,
      padding: 0,
      theme: null,
      parent: null,
      tooltipEnable: true,
      // 鏄惁灞曠ず tooltip
      animate: Global.animate,
      visible: true
    };
  };

  function View(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;

    var self = _assertThisInitialized(_this);

    self._setTheme();

    Util.each(Geom, function (GeomConstructor, className) {
      var methodName = Util.lowerFirst(className);

      self[methodName] = function (cfg) {
        if (cfg === void 0) {
          cfg = {};
        }

        cfg.viewTheme = self.get('viewTheme');
        var geom = new GeomConstructor(cfg);
        self.addGeom(geom);
        return geom;
      };
    }); // Util.mix(this, ViewGeoms);

    self.init();
    return _this;
  }

  _proto._setTheme = function _setTheme() {
    var self = this;
    var theme = self.get('theme');
    var viewTheme = {};
    var newTheme = {};

    if (Util.isObject(theme)) {
      newTheme = theme;
    } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {
      newTheme = Theme[theme];
    }

    Util.deepMix(viewTheme, Global, newTheme);
    self.set('viewTheme', viewTheme);
  }
  /**
   * @protected
   * 鍒濆鍖�
   */
  ;

  _proto.init = function init() {
    this._initViewPlot(); // 鍏堝垱寤哄鍣�


    if (this.get('data')) {
      this._initData(this.get('data'));
    }

    this._initOptions();

    this._initControllers();

    this._bindEvents();
  } // 鍒濆鍖栭厤缃」
  ;

  _proto._initOptions = function _initOptions() {
    var self = this;
    var options = Util.mix({}, self.get('options')); // 闃叉淇敼鍘熷鍊�

    if (!options.scales) {
      options.scales = {};
    }

    if (!options.coord) {
      options.coord = {};
    }

    if (options.animate === false) {
      this.set('animate', false);
    }

    if (options.tooltip === false || Util.isNull(options.tooltip)) {
      // 閰嶇疆椤规柟寮忓叧闂� tooltip
      this.set('tooltipEnable', false);
    }

    if (options.geoms && options.geoms.length) {
      Util.each(options.geoms, function (geomOption) {
        self._createGeom(geomOption);
      });
    }

    var scaleController = self.get('scaleController');

    if (scaleController) {
      scaleController.defs = options.scales;
    }

    var coordController = self.get('coordController');

    if (coordController) {
      coordController.reset(options.coord);
    }

    this.set('options', options);
  };

  _proto._createGeom = function _createGeom(cfg) {
    var type = cfg.type;
    var geom;

    if (this[type]) {
      geom = this[type]();
      Util.each(cfg, function (v, k) {
        if (geom[k]) {
          if (Util.isObject(v) && v.field) {
            // 閰嶇疆椤逛紶鍏�
            if (v === 'label') {
              geom[k](v.field, v.callback, v.cfg);
            } else {
              var _cfg;

              Util.each(v, function (value, key) {
                if (key !== 'field') {
                  _cfg = value;
                }
              });
              geom[k](v.field, _cfg);
            }
          } else {
            geom[k](v);
          }
        }
      });
    }
  } // 鍒濆鍖栨墍鏈夌殑鎺у埗鍣�
  ;

  _proto._initControllers = function _initControllers() {
    var self = this;
    var options = self.get('options');
    var viewTheme = self.get('viewTheme');
    var canvas = self.get('canvas');
    var scaleController = new Controller.Scale({
      viewTheme: viewTheme,
      defs: options.scales
    });
    var coordController = new Controller.Coord(options.coord);
    this.set('scaleController', scaleController);
    this.set('coordController', coordController);
    var axisController = new Controller.Axis({
      canvas: canvas,
      viewTheme: viewTheme
    });
    this.set('axisController', axisController);
    var guideController = new Controller.Guide({
      viewTheme: viewTheme,
      options: options.guides || []
    });
    this.set('guideController', guideController);
  };

  _proto._initViewPlot = function _initViewPlot() {
    if (!this.get('viewContainer')) {
      // 鐢ㄤ簬 geom 鐨勭粯鍒�
      this.set('viewContainer', this.get('middlePlot'));
    }
  };

  _proto._initGeoms = function _initGeoms() {
    var geoms = this.get('geoms');
    var filteredData = this.get('filteredData');
    var coord = this.get('coord');
    var viewId = this.get('_id');

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];
      geom.set('data', filteredData);
      geom.set('coord', coord);
      geom.set('_id', viewId + '-geom' + i);
      geom.set('keyFields', this.get('keyFields'));
      geom.init();
    }
  };

  _proto._clearGeoms = function _clearGeoms() {
    var self = this;
    var geoms = self.get('geoms');

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];
      geom.clear();
    }
  };

  _proto._removeGeoms = function _removeGeoms() {
    var self = this;
    var geoms = self.get('geoms');

    while (geoms.length > 0) {
      var geom = geoms.shift();
      geom.destroy();
    }
  };

  _proto._drawGeoms = function _drawGeoms() {
    this.emit('beforedrawgeoms');
    var geoms = this.get('geoms');
    var coord = this.get('coord');

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];
      geom.setCoord(coord);
      geom.paint();
    }

    this.emit('afterdrawgeoms');
  };

  _proto.isShapeInView = function isShapeInView(shape) {
    var id = this.get('_id');
    var shapeId = shape._id;

    if (shapeId) {
      return shapeId.split('-')[0] === id;
    }

    var parent = shape;

    while (parent) {
      if (parent.get('viewId') === id) {
        return true;
      }

      parent = parent.get('parent');
    }

    return false;
  }
  /**
   * View 鎵€鍦ㄧ殑鑼冨洿
   * @protected
   * @return {Object} View 鎵€鍦ㄧ殑鑼冨洿
   */
  ;

  _proto.getViewRegion = function getViewRegion() {
    var self = this;
    var parent = self.get('parent');
    var start;
    var end;

    if (parent) {
      var region = parent.getViewRegion();

      var viewRegion = self._getViewRegion(region.start, region.end);

      start = viewRegion.start;
      end = viewRegion.end;
    } else {
      start = self.get('start');
      end = self.get('end');
    }

    return {
      start: start,
      end: end
    };
  } // 鑾峰彇 range 鎵€鍦ㄧ殑鑼冨洿
  ;

  _proto._getViewRegion = function _getViewRegion(plotStart, plotEnd) {
    var start = this.get('start');
    var end = this.get('end');
    var startX = start.x;
    var startY = 1 - end.y;
    var endX = end.x;
    var endY = 1 - start.y;
    var padding = this.get('padding'); // 杞崲鎴� 涓娿€佸彸銆佷笅銆佸乏鐨勬ā寮�

    var allPadding = Util.toAllPadding(padding);
    var top = allPadding[0];
    var right = allPadding[1];
    var bottom = allPadding[2];
    var left = allPadding[3];
    var startPoint = {
      x: startX * (plotEnd.x - plotStart.x) + plotStart.x + left,
      y: startY * (plotEnd.y - plotStart.y) + plotStart.y - bottom
    };
    var endPoint = {
      x: endX * (plotEnd.x - plotStart.x) + plotStart.x - right,
      y: endY * (plotEnd.y - plotStart.y) + plotStart.y + top
    };
    return {
      start: startPoint,
      end: endPoint
    };
  };

  _proto._createCoord = function _createCoord() {
    var coordController = this.get('coordController');
    var region = this.getViewRegion();
    var coord = coordController.createCoord(region.start, region.end);
    this.set('coord', coord);
  };

  _proto._renderAxes = function _renderAxes() {
    var options = this.get('options');
    var axesOptions = options.axes;

    if (axesOptions === false) {
      // 涓嶆覆鏌撳潗鏍囪酱
      return;
    }

    var axisController = this.get('axisController');
    axisController.container = this.get('backPlot');
    axisController.coord = this.get('coord');
    axisController.options = axesOptions || {};
    var xScale = this.getXScale();
    var yScales = this.getYScales();
    var viewId = this.get('_id');
    axisController.createAxis(xScale, yScales, viewId);
  };

  _proto._renderGuides = function _renderGuides() {
    var guideController = this.get('guideController');

    if (!Util.isEmpty(guideController.options)) {
      var coord = this.get('coord');
      guideController.view = this;
      guideController.backContainer = this.get('backPlot');
      guideController.frontContainer = this.get('frontPlot');
      guideController.xScales = this._getScales('x');
      guideController.yScales = this._getScales('y');
      guideController.render(coord);
    }
  } // 娉ㄥ唽浜嬩欢
  ;

  _proto._bindEvents = function _bindEvents() {
    var eventController = new Controller.Event({
      view: this,
      canvas: this.get('canvas')
    });
    eventController.bindEvents();
    this.set('eventController', eventController);
  } // 娓呯悊鏃堕棿
  ;

  _proto._clearEvents = function _clearEvents() {
    var eventController = this.get('eventController');
    eventController && eventController.clearEvents();
  };

  _proto._getScales = function _getScales(dimType) {
    var geoms = this.get('geoms');
    var result = {};

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];
      var scale = dimType === 'x' ? geom.getXScale() : geom.getYScale();

      if (scale && !result[scale.field]) {
        result[scale.field] = scale;
      }
    }

    return result;
  };

  _proto._adjustScale = function _adjustScale() {
    this._setCatScalesRange();

    var geoms = this.get('geoms');
    var scaleController = this.get('scaleController');
    var colDefs = scaleController.defs;

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];

      if (geom.get('type') === 'interval') {
        var yScale = geom.getYScale();
        var field = yScale.field,
            min = yScale.min,
            max = yScale.max,
            type = yScale.type;

        if (!(colDefs[field] && colDefs[field].min) && type !== 'time') {
          if (min > 0) {
            yScale.change({
              min: 0
            });
          } else if (max <= 0) {
            // 褰撴煴鐘跺浘鍏ㄤ负璐熷€兼椂涔熼渶瑕佷粠 0 寮€濮嬬敓闀�
            yScale.change({
              max: 0
            });
          }
        }
      }
    }
  };

  _proto._setCatScalesRange = function _setCatScalesRange() {
    var self = this;
    var coord = self.get('coord');
    var viewTheme = self.get('viewTheme');
    var xScale = self.getXScale();
    var yScales = self.getYScales();
    var scales = [];
    xScale && scales.push(xScale);
    scales = scales.concat(yScales);
    var inFullCircle = coord.isPolar && isFullCircle(coord);
    var scaleController = self.get('scaleController');
    var colDefs = scaleController.defs;
    Util.each(scales, function (scale) {
      if ((scale.isCategory || scale.isIdentity) && scale.values && !(colDefs[scale.field] && colDefs[scale.field].range)) {
        var count = scale.values.length;
        var range;

        if (count === 1) {
          range = [0.5, 1]; // 鍙湁涓€涓垎绫绘椂,闃叉璁＄畻鍑虹幇 [0.5,0.5]鐨勭姸鎬�
        } else {
          var widthRatio = 1;
          var offset = 0;

          if (inFullCircle) {
            if (!coord.isTransposed) {
              range = [0, 1 - 1 / count];
            } else {
              widthRatio = viewTheme.widthRatio.multiplePie;
              offset = 1 / count * widthRatio;
              range = [offset / 2, 1 - offset / 2];
            }
          } else {
            offset = 1 / count * 1 / 2; // 涓よ竟鐣欎笅鍒嗙被绌洪棿鐨勪竴鍗�

            range = [offset, 1 - offset]; // 鍧愭爣杞存渶鍓嶉潰鍜屾渶鍚庨潰鐣欎笅绌虹櫧闃叉缁樺埗鏌辩姸鍥炬椂
          }
        }

        scale.range = range;
      }
    });
  };

  _proto.getXScale = function getXScale() {
    var geoms = this.get('geoms'); // 濡傛灉杩涜杩囨护锛岄偅涔� geom 榛樿闅愯棌鏃朵細鍑虹幇涓嶄竴鑷�
    // 榛樿闅愯棌鏃跺潗鏍囪酱涓嶇粯鍒讹紝浣嗘槸璋冪敤浜� geom.show() 鍚庯紝鍒欏浘褰㈡樉绀轰簡锛屽潗鏍囪酱渚濈劧涓嶈

    /* .filter(function(geom) {
      return geom.get('visible');
    }); */

    var xScale = null;

    if (!Util.isEmpty(geoms)) {
      xScale = geoms[0].getXScale();
    }

    return xScale;
  };

  _proto.getYScales = function getYScales() {
    var geoms = this.get('geoms');
    /* .filter(function(geom) {
      return geom.get('visible');
    }); */

    var rst = [];

    for (var i = 0; i < geoms.length; i++) {
      var geom = geoms[i];
      var yScale = geom.getYScale();

      if (yScale && Util.indexOf(rst, yScale) === -1) {
        rst.push(yScale);
      }
    }

    return rst;
  }
  /**
   * 鑾峰彇鏁版嵁瀵瑰簲鍦ㄧ敾甯冪┖闂寸殑鍧愭爣
   * @param  {Object} item 鍘熷鏁版嵁
   * @return {Object}      杩斿洖瀵瑰簲鐨勭敾甯冧笂鐨勫潗鏍囩偣
   */
  ;

  _proto.getXY = function getXY(item) {
    var self = this;
    var coord = self.get('coord');

    var xScales = self._getScales('x');

    var yScales = self._getScales('y');

    var x;
    var y;

    for (var field in item) {
      if (xScales[field]) {
        x = xScales[field].scale(item[field]);
      }

      if (yScales[field]) {
        y = yScales[field].scale(item[field]);
      }
    }

    if (!Util.isNil(x) && !Util.isNil(y)) {
      return coord.convert({
        x: x,
        y: y
      });
    }

    return null;
  }
  /**
   * 鑾峰彇閫艰繎鐨勭偣鐨勬暟鎹泦鍚�
   * @param  {Object} point 鐢诲竷涓婄殑鍍忕礌鐐�
   * @return {Array} 鏁版嵁
   */
  ;

  _proto.getSnapRecords = function getSnapRecords(point) {
    var self = this;
    var geoms = self.get('geoms');
    var rst = [];
    Util.each(geoms, function (geom) {
      var dataArray = geom.get('dataArray');
      var record;
      Util.each(dataArray, function (data) {
        record = geom.findPoint(point, data);
        record && rst.push(record);
      });
    });
    return rst;
  }
  /**
   * @protected
   * 娣诲姞鍑犱綍鏍囪
   * @param {Geom} geom 鍑犱綍鏍囪
   */
  ;

  _proto.addGeom = function addGeom(geom) {
    var self = this;
    var geoms = self.get('geoms');
    geoms.push(geom);
    geom.set('view', self);
    var container = self.get('viewContainer');
    geom.set('container', container);
    geom.set('animate', self.get('animate'));
    geom.bindEvents();
  }
  /**
   * @protected
   * 绉婚櫎鍑犱綍鏍囪
   * @param {Geom} geom 鍑犱綍鏍囪
   */
  ;

  _proto.removeGeom = function removeGeom(geom) {
    var geoms = this.get('geoms');
    Util.Array.remove(geoms, geom);
    geom.destroy();
  };

  _proto.createScale = function createScale(field, data) {
    var scales = this.get('scales');
    var parent = this.get('parent');
    var scale = scales[field]; // const filters = this._getFilters();

    if (!data) {
      var filteredData = this.get('filteredData');

      var legendFields = this._getFieldsForLegend(); // 杩囨护瀵艰嚧鏁版嵁涓虹┖鏃讹紝闇€瑕佷娇鐢ㄥ叏灞€鏁版嵁
      // 鍙備笌杩囨护鐨勫瓧娈电殑搴﹂噺涔熸牴鎹叏灞€鏁版嵁鏉ョ敓鎴�


      if (filteredData.length && !legendFields.includes(field)) {
        data = filteredData;
      } else {
        data = this.get('data');
      }
    }

    var scaleController = this.get('scaleController');

    if (!scale) {
      scale = scaleController.createScale(field, data);

      if (scale.sync && parent) {
        var parentScale = parent.createScale(field, data);
        scale = this._getSyncScale(parentScale, scale);
      }

      scales[field] = scale;
    } else if (scale.sync) {
      // 闃叉 view 鍐呴儴鍒涘缓鐨剆cale锛孋hart 涓婄殑scale 鑼冨洿鏇村ぇ
      var newScale = scaleController.createScale(field, data);

      this._syncScale(scale, newScale);
    }

    return scale;
  };

  _proto._getFieldsForLegend = function _getFieldsForLegend() {
    var fields = [];
    var geoms = this.get('geoms');
    Util.each(geoms, function (geom) {
      var geomFields = geom.getFieldsForLegend();
      fields = fields.concat(geomFields);
    });
    return Util.uniq(fields);
  } // 濡傛灉闇€瑕佸悓姝ュ害閲忥紝鍒欎娇寰� values,min,max鐨勮寖鍥存渶澶�
  ;

  _proto._getSyncScale = function _getSyncScale(parentScale, scale) {
    if (parentScale.type !== scale.type) {
      return scale;
    }

    this._syncScale(parentScale, scale);

    return parentScale;
  };

  _proto._syncScale = function _syncScale(distScale, sourceScale) {
    var mergeValues = Util.union(distScale.values, sourceScale.values);

    if (sourceScale.isLinear) {
      var max = Math.max(distScale.max, sourceScale.max);
      var min = Math.min(distScale.min, sourceScale.min);

      if (distScale.max !== max || distScale.min !== min) {
        distScale.change({
          min: min,
          max: max,
          values: mergeValues
        });
      }
    }

    if (mergeValues.length !== distScale.values.length) {
      distScale.change({
        values: mergeValues
      });
    }
  }
  /**
   * @protected
   * 鑾峰彇杩囨护鍚庣殑鍊硷紙闇€瑕佹樉绀虹殑鍊硷級
   * @param {String} field 搴﹂噺
   * @return {Array.<String>} 婊ゅ悗鐨勫€�
   */
  ;

  _proto.getFilteredValues = function getFilteredValues(field) {
    var scale = this.get('scales')[field];
    var values = scale.values;

    var filters = this._getFilters();

    var rst;

    if (filters && filters[field]) {
      rst = values.filter(filters[field]);
    } else {
      rst = values.slice(0);
    }

    return rst;
  }
  /**
   * @protected
   * 鑾峰彇琚繃婊ょ殑鍊硷紙涓嶉渶鏄剧ず鐨勫€硷級
   * @param {String} field 搴﹂噺
   * @return {Array.<String>} 婊ゅ嚭鐨勫€�
   */
  ;

  _proto.getFilteredOutValues = function getFilteredOutValues(field) {
    var scale = this.get('scales')[field];
    var values = scale.values;

    var filters = this._getFilters();

    var rst;

    if (filters && filters[field]) {
      rst = values.filter(function () {
        return !filters[field].apply(filters, arguments);
      });
    } else {
      rst = [];
    }

    return rst;
  };

  _proto.filter = function filter(field, condition) {
    var options = this.get('options');

    if (!options.filters) {
      options.filters = {};
    }

    options.filters[field] = condition;
    this.get('scaleController').filters = options.filters;
  } // 鑾峰彇 filters
  ;

  _proto._getFilters = function _getFilters() {
    var options = this.get('options');
    return options.filters;
  } // 鎵ц filter 鏁版嵁
  ;

  _proto.execFilter = function execFilter(data) {
    var self = this;

    var filters = self._getFilters();

    if (filters) {
      data = data.filter(function (obj) {
        var rst = true;
        Util.each(filters, function (fn, k) {
          if (fn) {
            rst = fn(obj[k], obj);

            if (!rst) {
              return false;
            }
          }
        });
        return rst;
      });
    }

    return data;
  };

  _proto.axis = function axis(field, cfg) {
    var options = this.get('options');

    if (field === false) {
      options.axes = false;
    } else {
      if (!options.axes) {
        options.axes = {};
      }

      var axisOptions = options.axes;
      axisOptions[field] = cfg;
    }

    return this;
  };

  _proto.guide = function guide() {
    return this.get('guideController');
  };

  _proto._getKeyFields = function _getKeyFields(scaleDefs) {
    var keyFields = [];
    Util.each(scaleDefs, function (def, field) {
      if (def.key) {
        keyFields.push(field);
      }
    });
    this.set('keyFields', keyFields);
  };

  _proto.scale = function scale(field, cfg) {
    var options = this.get('options');
    var scaleDefs = options.scales;

    if (Util.isObject(field)) {
      Util.mix(scaleDefs, field);
    } else {
      scaleDefs[field] = cfg;
    }

    this._getKeyFields(scaleDefs);

    return this;
  };

  _proto.tooltip = function tooltip(visible) {
    this.set('tooltipEnable', visible);
    return this;
  };

  _proto.animate = function animate(enable) {
    var options = this.get('options');
    options.animate = enable;
    this.set('animate', enable);
    return this;
  };

  _proto.changeOptions = function changeOptions(options) {
    this.set('options', options);

    this._initOptions(options);

    return this;
  }
  /**
   * @internal 鏌ユ壘鍖呭惈鎸囧畾鐐圭殑瑙嗗浘
   * @param  {Object} point 鐐圭殑浣嶇疆
   * @return {Array} 澶氫釜瑙嗗浘
   */
  ;

  _proto.getViewsByPoint = function getViewsByPoint(point) {
    var rst = [];
    var views = this.get('views');

    if (isPointInCoord(this.get('coord'), point)) {
      rst.push(this);
    }

    Util.each(views, function (view) {
      if (view.get('visible') && isPointInCoord(view.get('coord'), point)) {
        rst.push(view);
      }
    });
    return rst;
  }
  /**
   * 閬嶅巻鎵€鏈夌殑 shape 锛岀敤鎴锋洿鏀� shape 鍚庤繘琛屽埛鏂�
   * @param  {Function} fn 鍥炶皟鍑芥暟鍖呭惈鍙傛暟锛歳ecord,shape,geom,view
   * @return {View} 褰撳墠瑙嗗浘
   */
  ;

  _proto.eachShape = function eachShape(fn) {
    var self = this;
    var views = self.get('views');
    var canvas = self.get('canvas');
    Util.each(views, function (view) {
      view.eachShape(fn);
    });
    var geoms = this.get('geoms');
    Util.each(geoms, function (geom) {
      var shapes = geom.getShapes();
      Util.each(shapes, function (shape) {
        var origin = shape.get('origin');

        if (Util.isArray(origin)) {
          var arr = origin.map(function (subOrigin) {
            return subOrigin[FIELD_ORIGIN];
          });
          fn(arr, shape, geom, self);
        } else {
          var obj = origin[FIELD_ORIGIN];
          fn(obj, shape, geom, self);
        }
      });
    });
    canvas.draw();
    return this;
  }
  /**
   * 閬嶅巻鎵€鏈夌殑 shape 锛屽洖璋冨嚱鏁颁腑 true / false 鎺у埗鍥惧舰鏄惁鏄剧ず
   * @param  {Function} fn 鍥炶皟鍑芥暟鍖呭惈鍙傛暟锛歳ecord,shape,geom,view
   * @return {View} 褰撳墠瑙嗗浘
   */
  ;

  _proto.filterShape = function filterShape(fn) {
    var callback = function callback(record, shape, geom, view) {
      if (!fn(record, shape, geom, view)) {
        shape.hide();
      } else {
        shape.show();
      }
    };

    this.eachShape(callback);
    return this;
  };

  _proto.clearInner = function clearInner() {
    this.set('scales', {});
    this.emit('beforeclearinner');
    var options = this.get('options');
    options.geoms = null;

    this._clearGeoms(); // reset guide


    this.get('guideController') && this.get('guideController').reset(); // clear axis

    this.get('axisController') && this.get('axisController').clear();
    this.emit('afterclearinner');
  }
  /**
   * 娓呴櫎瑙嗗浘鍐呭锛屽寘鎷� geoms
   * @return {View} 褰撳墠瑙嗗浘
   */
  ;

  _proto.clear = function clear() {
    var options = this.get('options');
    options.filters = null;

    this._removeGeoms(); // const container = this.get('viewContainer');
    // container.clear();


    this.clearInner();
    this.get('guideController') && this.get('guideController').clear();
    this.set('isUpdate', false);
    this.set('keyFields', []);
    return this;
  }
  /**
   * 璁剧疆鍧愭爣绯讳俊鎭�
   * @param  {String} type 绫诲瀷
   * @param  {Object} cfg  閰嶇疆椤�
   * @return {Object} coordController 鍧愭爣绯荤殑绠＄悊鍣�
   */
  ;

  _proto.coord = function coord(type, cfg) {
    var coordController = this.get('coordController');
    coordController.reset({
      type: type,
      cfg: cfg
    });
    return coordController;
  }
  /**
   * 褰撶埗鍏冪礌杈规鍙戠敓鏀瑰彉鏃跺潗鏍囩郴闇€瑕侀噸鏂拌皟鏁�
   * @protected
   */
  ;

  _proto.resetCoord = function resetCoord() {
    this._createCoord();
  };

  _proto.source = function source(data, scales) {
    this._initData(data);

    if (scales) {
      this.scale(scales);
    }

    this.emit('setdata');
    return this;
  };

  _proto.changeData = function changeData(data) {
    this.emit('beforechangedata');

    this._initData(data);

    this.emit('afterchangedata');
    this.repaint();
    return this;
  };

  _proto._initData = function _initData(data) {
    var dataView = this.get('dataView');

    if (dataView) {
      dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));
      this.set('dataView', null);
    }

    if (data && data.isDataView) {
      data.on('change', Util.wrapBehavior(this, '_onViewChange'));
      this.set('dataView', data);
      data = data.rows;
    }

    this.set('data', data);
  };

  _proto._onViewChange = function _onViewChange() {
    this.emit('beforechangedata');
    var dataView = this.get('dataView');
    var rows = dataView.rows;
    this.set('data', rows);
    this.emit('afterchangedata');
    this.repaint();
  } // 鍒濆鍖栧悇涓� view 鍜岀粯鍒惰緟鍔╁厓绱�
  ;

  _proto.beforeRender = function beforeRender() {
    var views = this.get('views'); // 濡傛灉瀛樺湪 views 鍒欏垵濮嬪寲瀛� view 鐨勬柟娉�

    Util.each(views, function (view) {
      view.beforeRender();
    });
    this.initView();
  } // 缁樺埗鍧愭爣杞淬€佸浘渚嬨€佽緟鍔╁厓绱犵瓑鍥捐〃缁勪欢
  ;

  _proto.drawComponents = function drawComponents() {
    var views = this.get('views'); // 濡傛灉瀛樺湪 views 鍒欏垵濮嬪寲瀛� view 鐨勬柟娉�

    Util.each(views, function (view) {
      view.drawComponents();
    });

    this._renderAxes();

    this._renderGuides();
  } // 缁樺埗鍥惧舰
  ;

  _proto.drawCanvas = function drawCanvas(stopDraw) {
    if (!stopDraw) {
      var views = this.get('views');
      var backPlot = this.get('backPlot');
      backPlot.sort();
      var canvas = this.get('canvas');
      var animate = this.get('animate');

      if (animate) {
        var isUpdate = this.get('isUpdate');
        Util.each(views, function (view) {
          Animate.execAnimation(view, isUpdate);
        });
        Animate.execAnimation(this, isUpdate);
      } else {
        canvas.draw();
      }
    }
  };

  _proto.render = function render(stopDraw) {
    this.clearInner();
    this.emit('beforerender');
    this.beforeRender();
    this.emit('beforepaint');
    this.drawComponents();
    this.paint();
    this.emit('afterpaint');
    this.drawCanvas(stopDraw);
    this.emit('afterrender');
    this.set('rendered', true);
    return this;
  };

  _proto.initView = function initView() {
    var data = this.get('data') || [];
    var filteredData = this.execFilter(data);
    this.set('filteredData', filteredData); // if (!Util.isEmpty(data)) {

    this._createCoord(); // draw geometry 鍓嶇粯鍒跺尯鍩熷彲鑳戒細鍙戠敓鏀瑰彉


    this.emit('beforeinitgeoms');

    this._initGeoms();

    this._adjustScale(); // }

  };

  _proto.paint = function paint() {
    var views = this.get('views'); // 缁樺埗

    Util.each(views, function (view) {
      view.paint();
    });
    var data = this.get('data');

    if (!Util.isEmpty(data)) {
      this._drawGeoms();
    } // 濡傛灉 view 闅愯棌浜嗭紝闅愯棌鎵€鏈夌殑鍥惧舰鍜屽潗鏍囪酱


    if (!this.get('visible')) {
      this.changeVisible(false, true); // 闅愯棌鎵€鏈夌殑鍥惧舰锛屼絾鏄笉缁樺埗
    }
  };

  _proto.changeVisible = function changeVisible(visible, stopDraw) {
    var geoms = this.get('geoms');
    Util.each(geoms, function (geom) {
      // if (geom.get('visible')) { // geom 闅愯棌鏃朵笉鍙�
      geom.changeVisible(visible, true); // }
    });
    this.get('axisController') && this.get('axisController').changeVisible(visible);
    this.get('guideController') && this.get('guideController').changeVisible(visible);

    if (!stopDraw) {
      var canvas = this.get('canvas');
      canvas.draw();
    }
  };

  _proto.repaint = function repaint() {
    this.set('isUpdate', true);
    this.clearInner();
    this.render();
  };

  _proto.destroy = function destroy() {
    this._clearEvents();

    var dataView = this.get('dataView');
    dataView && dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));
    this.clear();

    _Base.prototype.destroy.call(this);
  };

  return View;
}(Base);

module.exports = View;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(30),
    Guide = _require.Guide;

var RegionFilter = __webpack_require__(281);

Guide.RegionFilter = RegionFilter;
module.exports = Guide;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Guide = __webpack_require__(20);

var _require = __webpack_require__(31),
    Path = _require.Path;

var RegionFilter = /*#__PURE__*/function (_Guide) {
  _inheritsLoose(RegionFilter, _Guide);

  function RegionFilter() {
    return _Guide.apply(this, arguments) || this;
  }

  var _proto = RegionFilter.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Guide.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      name: 'regionFilter',
      zIndex: 1,
      top: true,
      start: null,
      end: null,
      color: null,
      apply: null,
      style: {
        opacity: 1
      }
    });
  };

  _proto.render = function render(coord, group, viewData, view) {
    var self = this;
    var layer = group.addGroup();
    layer.name = 'guide-region-filter';
    view.once('afterpaint', function () {
      // 2018-08-08 by blue.lb padding涓篴uto鏃讹紝浼氬鑷撮噸鏂扮粯鍒朵竴娆★紝杩欐椂鍊檒ayer宸茬粡琚攢姣佷簡
      if (layer.get('destroyed')) return;

      self._drawShapes(view, layer);

      var clip = self._drawClip(coord);

      layer.attr({
        clip: clip
      });
      self.set('clip', clip);
      self.get('appendInfo') && layer.setSilent('appendInfo', self.get('appendInfo'));
      self.set('el', layer);
    });
  };

  _proto._drawShapes = function _drawShapes(view, layer) {
    var self = this;
    var output = [];
    var geoms = view.getAllGeoms();
    geoms.map(function (geom) {
      var shapes = geom.getShapes();
      var geomType = geom.get('type');

      var filter = self._geomFilter(geomType);

      if (filter) {
        shapes.map(function (shape) {
          var shapeType = shape.type; // const shapeAttr = Util.mix({}, shape.attr());

          var shapeAttr = Util.cloneDeep(shape.attr());

          self._adjustDisplay(shapeAttr);

          var s = layer.addShape(shapeType, {
            attrs: shapeAttr
          });
          output.push(s);
          return shape;
        });
      }

      return geom;
    });
    return output;
  };

  _proto._drawClip = function _drawClip(coord) {
    var self = this;
    var start = self.parsePoint(coord, self.get('start'));
    var end = self.parsePoint(coord, self.get('end'));
    var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];
    var clip = new Path({
      attrs: {
        path: path,
        opacity: 1
      }
    });
    return clip;
  };

  _proto._adjustDisplay = function _adjustDisplay(attr) {
    var self = this;
    var color = self.get('color');

    if (attr.fill) {
      attr.fill = attr.fillStyle = color;
    }

    attr.stroke = attr.strokeStyle = color;
  };

  _proto._geomFilter = function _geomFilter(geomType) {
    var self = this;
    var apply = self.get('apply');

    if (apply) {
      return Util.contains(apply, geomType);
    }

    return true;
  };

  _proto.clear = function clear() {
    _Guide.prototype.clear.call(this);

    var clip = this.get('clip');
    clip && clip.remove();
  };

  return RegionFilter;
}(Guide);

module.exports = RegionFilter;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The class of tail legend
 * @author Ye Liu
 */
var Util = __webpack_require__(0); // const Category = require('./category');


var Components = __webpack_require__(30);

var Global = __webpack_require__(5);

var Legend = Components.Legend;
var Category = Legend.Category;

var Tail = /*#__PURE__*/function (_Category) {
  _inheritsLoose(Tail, _Category);

  function Tail() {
    return _Category.apply(this, arguments) || this;
  }

  var _proto = Tail.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Category.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      /**
       * type鏍囪瘑
       * @type {String}
       */
      type: 'tail-legend',

      /**
       * 甯冨眬鏂瑰紡
       * horizontal 姘村钩
       * vertical 鍨傜洿
       * @type {String}
       */
      layout: 'vertical',
      autoLayout: true
    });
  };

  _proto._addItem = function _addItem(item) {
    var itemsGroup = this.get('itemsGroup');

    var x = this._getNextX();

    var y = 0;
    var unCheckColor = this.get('unCheckColor');
    var itemGroup = itemsGroup.addGroup({
      x: 0,
      y: 0,
      value: item.value,
      scaleValue: item.scaleValue,
      checked: item.checked
    });
    itemGroup.translate(x, y);
    itemGroup.set('viewId', itemsGroup.get('viewId'));
    var textStyle = this.get('textStyle');
    var wordSpace = this.get('_wordSpaceing');
    var startX = 0;

    if (item.marker) {
      // 濡傛灉鏈塵arker娣诲姞marker
      var markerAttrs = Util.mix({}, item.marker, {
        x: item.marker.radius,
        y: 0
      });

      if (!item.checked) {
        if (markerAttrs.fill) {
          markerAttrs.fill = unCheckColor;
        }

        if (markerAttrs.stroke) {
          markerAttrs.stroke = unCheckColor;
        }
      }

      var markerShape = itemGroup.addShape('marker', {
        type: 'marker',
        attrs: markerAttrs
      });
      markerShape.attr('cursor', 'pointer');
      markerShape.name = 'legend-marker';
      startX += markerShape.getBBox().width + wordSpace;
    }

    var textAttrs = Util.mix({}, textStyle, {
      x: startX,
      y: 0,
      text: this._formatItemValue(item.value)
    });

    if (!item.checked) {
      Util.mix(textAttrs, {
        fill: unCheckColor
      });
    }

    var textShape = itemGroup.addShape('text', {
      attrs: textAttrs
    });
    textShape.attr('cursor', 'pointer');
    textShape.name = 'legend-text';
    this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 娣诲姞涓€涓寘鍥寸煩褰紝鐢ㄤ簬浜嬩欢鏀寔

    var bbox = itemGroup.getBBox();
    var itemWidth = this.get('itemWidth');
    var wrapperShape = itemGroup.addShape('rect', {
      attrs: {
        x: x,
        y: y - bbox.height / 2,
        fill: '#fff',
        fillOpacity: 0,
        width: itemWidth || bbox.width,
        height: bbox.height
      }
    });
    wrapperShape.attr('cursor', 'pointer');
    wrapperShape.setSilent('origin', item); // 淇濆瓨鍥句緥椤圭浉鍏崇殑鏁版嵁锛屼究浜庝簨浠舵搷浣�

    wrapperShape.name = 'legend-item';
    this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));
    itemGroup.name = 'legendGroup';
    return itemGroup;
  };

  _proto._adjust = function _adjust() {
    var self = this;
    var geom = self.get('geom');

    if (geom) {
      var groupMatrix = self.get('group').attr('matrix');
      groupMatrix[7] = 0;
      var dataArray = self.get('geom').get('dataArray');
      var groups = this.get('itemsGroup').get('children');
      var index = 0;
      Util.each(groups, function (groupItem) {
        var dArray = dataArray[index];
        var lastY = dArray[dArray.length - 1].y;

        if (Util.isArray(lastY)) {
          lastY = lastY[1];
        }

        var groupHeight = groupItem.getBBox().height;
        var x = groupItem.get('x');
        var y = lastY - groupHeight / 2;
        groupItem.translate(x, y);
        index++;
      });

      if (self.get('autoLayout')) {
        self._antiCollision(groups);
      }
    }
  };

  _proto.render = function render() {
    var _this = this;

    _Category.prototype.render.call(this);

    var chart = this.get('chart');
    chart.once('afterpaint', function () {
      _this._adjust();
    });
  };

  _proto._getPreviousY = function _getPreviousY(item) {
    var y = item.attr('matrix')[7];
    var height = item.getBBox().height;
    return y + height;
  };

  _proto._adjustDenote = function _adjustDenote(group, start, end) {
    var margin = Global.legend.legendMargin;
    var x0 = -2;
    var x2 = -margin * 2;
    group.addShape('path', {
      attrs: {
        path: 'M' + x0 + ',' + start + 'L' + x2 + ',' + (end + 3),
        lineWidth: 1,
        lineDash: [2, 2],
        stroke: '#999999'
      }
    });
  };

  _proto._antiCollision = function _antiCollision(items) {
    if (items === void 0) {
      items = [];
    }

    if (!items.length) return;
    var self = this;
    items.sort(function (a, b) {
      var ay = a.attr('matrix')[7];
      var by = b.attr('matrix')[7];
      return ay - by;
    });
    var overlapping = true;
    var plotRange = self.get('chart').get('plotRange');
    var startY = plotRange.tl.y;
    var totalHeight = Math.abs(startY - plotRange.bl.y);
    var elementHeight = items[0].getBBox().height;
    var minY = Number.MIN_VALUE;
    var maxY = 0;
    var boxes = items.map(function (item) {
      var y = item.attr('matrix')[7];

      if (y > maxY) {
        maxY = y;
      }

      if (y < minY) {
        minY = y;
      }

      return {
        size: item.getBBox().height,
        targets: [y - startY]
      };
    });
    minY -= startY;
    var i = 0;

    while (overlapping) {
      for (var _i = 0; _i < boxes.length; _i++) {
        var box = boxes[_i];
        var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
        box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
      }

      overlapping = false;
      i = boxes.length;

      while (i--) {
        if (i > 0) {
          var previous = boxes[i - 1];
          var current = boxes[i];

          if (previous.pos + previous.size > current.pos) {
            // overlapping
            previous.size += current.size;
            previous.targets = previous.targets.concat(current.targets);
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      } // end of while i

    } // end of while
    // adjust y


    i = 0;
    var group = this.get('itemsGroup').addGroup();
    boxes.forEach(function (b) {
      var posInCompositeBox = startY + elementHeight;
      b.targets.forEach(function () {
        var origin_y = items[i].attr('matrix')[7];
        var y = b.pos + posInCompositeBox - elementHeight / 2;
        var dist = Math.abs(origin_y - y);

        if (dist > elementHeight / 2) {
          self._adjustDenote(group, y, origin_y - self.get('group').attr('matrix')[7] / 2);
        }

        items[i].translate(0, -origin_y);
        items[i].translate(0, y);
        posInCompositeBox += elementHeight;
        i++;
      });
    });
  } // end of antiCollision
  ;

  return Tail;
}(Category);

module.exports = Tail;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The class of canvas plot
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var _require = __webpack_require__(16),
    Group = _require.Group;

var AUTO_STR = 'auto';

var PlotBack = function PlotBack(cfg) {
  PlotBack.superclass.constructor.call(this, cfg);
};

Util.extend(PlotBack, Group);
Util.augment(PlotBack, {
  getDefaultCfg: function getDefaultCfg() {
    return {
      /**
       * 绫诲瀷
       * @type {String}
       */
      type: 'plotBack',

      /**
       * 鐢诲竷杈硅窛
       * @type {Number | Array | Object | "auto"}
       */
      padding: null,

      /**
       * 澶ц儗鏅�
       * @type {Object}
       */
      background: null,

      /**
       * 缁樺浘鍖哄煙鑼冨洿
       * @type {Object}
       */
      plotRange: null,

      /**
       * 缁樺浘鍖哄煙鑳屾櫙
       * @type {Object}
       */
      plotBackground: null
    };
  },
  _beforeRenderUI: function _beforeRenderUI() {
    this._calculateRange();
  },
  _renderUI: function _renderUI() {
    this._renderBackground();

    this._renderPlotBackground();
  },
  _renderBackground: function _renderBackground() {
    var self = this;
    var background = self.get('background');

    if (background) {
      var canvas = this.get('canvas');
      var width = self.get('width') || canvas.get('width');
      var height = self.get('height') || canvas.get('height');
      var cfg = {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
      var rect = self.get('backgroundShape');

      if (!rect) {
        rect = this.addShape('rect', {
          attrs: Util.mix(cfg, background)
        });
        this.set('backgroundShape', rect);
      } else {
        rect.attr(cfg);
      }
    } else {
      return;
    }
  },
  _renderPlotBackground: function _renderPlotBackground() {
    var self = this;
    var plotBackground = self.get('plotBackground');

    if (plotBackground) {
      var plotRange = self.get('plotRange');
      var width = plotRange.br.x - plotRange.bl.x;
      var height = plotRange.br.y - plotRange.tr.y;
      var tl = plotRange.tl;
      var cfg = {
        x: tl.x,
        y: tl.y,
        width: width,
        height: height
      };
      var plotBackShape = self.get('plotBackShape');

      if (!plotBackShape) {
        if (plotBackground.image) {
          cfg.img = plotBackground.image;
          plotBackShape = self.addShape('image', {
            attrs: cfg
          });
        } else {
          // 鐭╁舰
          Util.mix(cfg, plotBackground);
          plotBackShape = self.addShape('rect', {
            attrs: cfg
          });
        }

        self.set('plotBackShape', plotBackShape);
      } else {
        plotBackShape.attr(cfg);
      }
    } else {
      return;
    }
  },
  _convert: function _convert(val, isHorizontal) {
    if (Util.isString(val)) {
      if (val === AUTO_STR) {
        val = 0;
      } else if (val.includes('%')) {
        var canvas = this.get('canvas');
        var width = this.get('width') || canvas.get('width');
        var height = this.get('height') || canvas.get('height');
        val = parseInt(val, 10) / 100;
        val = isHorizontal ? val * width : val * height;
      }
    }

    return val;
  },
  _calculateRange: function _calculateRange() {
    var self = this;
    var plotRange = self.get('plotRange');

    if (Util.isNil(plotRange)) {
      plotRange = {};
    }

    var padding = self.get('padding');
    var canvas = this.get('canvas');
    var width = self.get('width') || canvas.get('width');
    var height = self.get('height') || canvas.get('height');
    var allPadding = Util.toAllPadding(padding);

    var top = self._convert(allPadding[0], false);

    var right = self._convert(allPadding[1], true);

    var bottom = self._convert(allPadding[2], false);

    var left = self._convert(allPadding[3], true);

    var minX = Math.min(left, width - right);
    var maxX = Math.max(left, width - right);
    var minY = Math.min(height - bottom, top);
    var maxY = Math.max(height - bottom, top);
    plotRange.tl = {
      x: minX,
      y: minY
    }; // top-left

    plotRange.tr = {
      x: maxX,
      y: minY
    }; // top-right

    plotRange.bl = {
      x: minX,
      y: maxY
    }; // bottom-left

    plotRange.br = {
      x: maxX,
      y: maxY
    }; // bottom-right

    plotRange.cc = {
      x: (maxX + minX) / 2,
      y: (maxY + minY) / 2
    };
    this.set('plotRange', plotRange);
  },
  repaint: function repaint() {
    this._calculateRange();

    this._renderBackground();

    this._renderPlotBackground();

    return this;
  }
});
module.exports = PlotBack;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview circle facets
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(46);

function getPoint(center, r, angle) {
  return {
    x: center.x + r * Math.cos(angle),
    y: center.y + r * Math.sin(angle)
  };
}

var Circle = /*#__PURE__*/function (_Base) {
  _inheritsLoose(Circle, _Base);

  function Circle() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Circle.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    cfg.type = 'circle';
    return cfg;
  };

  _proto.getRegion = function getRegion(count, index) {
    var r = 1 / 2; // 鐢诲竷鍗婂緞

    var avgAngle = Math.PI * 2 / count;
    var angle = -1 * Math.PI / 2 + avgAngle * index; // 褰撳墠鍒嗛潰鎵€鍦ㄧ殑寮у害

    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
    var center = {
      x: 0.5,
      y: 0.5
    }; // 鐢诲竷鍦嗗績

    var middle = getPoint(center, r - facetR, angle); // 鍒嗛潰鐨勪腑蹇冪偣

    var startAngle = Math.PI * 5 / 4; // 鍙充笂瑙�

    var endAngle = Math.PI * 1 / 4; // 宸︿笅瑙�

    return {
      start: getPoint(middle, facetR, startAngle),
      end: getPoint(middle, facetR, endAngle)
    };
  };

  _proto.generateFacets = function generateFacets(data) {
    var self = this;
    var fields = self.fields;
    var field = fields[0];

    if (!field) {
      throw 'Please specify for the field for facet!';
    }

    var values = self.getFieldValues(field, data);
    var count = values.length;
    var rst = [];
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var filter = self.getFilter(conditions);
      var subData = data.filter(filter);
      var facet = {
        type: self.type,
        colValue: value,
        colField: field,
        colIndex: index,
        cols: count,
        rows: 1,
        rowIndex: 0,
        data: subData,
        region: self.getRegion(count, index)
      };
      rst.push(facet);
    });
    return rst;
  };

  return Circle;
}(Base);

module.exports = Circle;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Facet 鐨勫叆鍙�
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var Chart = __webpack_require__(44);

var Facets = {};
Facets.Rect = __webpack_require__(126);
Facets.List = __webpack_require__(125);
Facets.Circle = __webpack_require__(284);
Facets.Tree = __webpack_require__(288);
Facets.Mirror = __webpack_require__(287);
Facets.Matrix = __webpack_require__(286);

Chart.prototype.facet = function (type, cfg) {
  var cls = Facets[Util.upperFirst(type)];

  if (!cls) {
    throw new Error('Not support such type of facets as: ' + type);
  }

  var preFacets = this.get('facets');

  if (preFacets) {
    preFacets.destroy();
  }

  cfg.chart = this;
  var facets = new cls(cfg);
  this.set('facets', facets);
};

module.exports = Facets;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview Use matrices to compare different fields
 * @author dxq613@gmail.com
 */
var Rect = __webpack_require__(126);

var Matrix = /*#__PURE__*/function (_Rect) {
  _inheritsLoose(Matrix, _Rect);

  function Matrix() {
    return _Rect.apply(this, arguments) || this;
  }

  var _proto = Matrix.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Rect.prototype.getDefaultCfg.call(this);

    cfg.type = 'matrix';
    cfg.showTitle = false;
    return cfg;
  };

  _proto.generateFacets = function generateFacets(data) {
    var self = this;
    var fields = self.fields;
    var rows = fields.length;
    var cols = rows; // 鐭╅樀涓鍒楃浉绛夛紝绛変簬鎸囧畾鐨勫瓧娈典釜鏁�

    var rst = [];

    for (var i = 0; i < cols; i++) {
      var colField = fields[i];

      for (var j = 0; j < rows; j++) {
        var rowField = fields[j];
        var facet = {
          type: self.type,
          colValue: colField,
          rowValue: rowField,
          colField: colField,
          rowField: rowField,
          colIndex: i,
          rowIndex: j,
          cols: cols,
          rows: rows,
          data: data,
          region: self.getRegion(rows, cols, i, j)
        };
        rst.push(facet);
      }
    }

    return rst;
  } // 璁剧疆 x 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setXAxis = function setXAxis(xField, axes, facet) {
    if (facet.rowIndex !== facet.rows - 1) {
      axes[xField].title = null;
      axes[xField].label = null;
    }
  } // 璁剧疆 y 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setYAxis = function setYAxis(yField, axes, facet) {
    if (facet.colIndex !== 0) {
      axes[yField].title = null;
      axes[yField].label = null;
    }
  };

  return Matrix;
}(Rect);

module.exports = Matrix;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview mirror facets
 * @author dxq613@gmail.com
 */
var List = __webpack_require__(125);

var Mirror = /*#__PURE__*/function (_List) {
  _inheritsLoose(Mirror, _List);

  function Mirror() {
    return _List.apply(this, arguments) || this;
  }

  var _proto = Mirror.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _List.prototype.getDefaultCfg.call(this);

    cfg.type = 'mirror';
    this.transpose = false;
    return cfg;
  };

  _proto.init = function init() {
    var self = this;

    if (self.transpose) {
      self.cols = 2;
      self.rows = 1;
    } else {
      self.cols = 1;
      self.rows = 2;
    }

    _List.prototype.init.call(this);
  };

  _proto.beforeProcessView = function beforeProcessView(view, facet) {
    if (this.transpose) {
      if (facet.colIndex % 2 === 0) {
        view.coord().transpose().scale(-1, 1);
      } else {
        view.coord().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coord().scale(1, -1);
      }
    }
  };

  _proto.renderTitle = function renderTitle(view, facet) {
    if (this.transpose) {
      this.drawColTitle(view, facet);
    } else {
      this.drawRowTitle(view, facet);
    }
  };

  _proto.setXAxis = function setXAxis(xField, axes, facet) {
    // 褰撴槸鏈€鍚庝竴琛屾垨鑰呬笅闈㈡病鏈� view 鏃舵枃鏈笉鏄剧ず
    if (facet.colIndex === 1 || facet.rowIndex === 1) {
      axes[xField].label = null;
      axes[xField].title = null;
    }
  };

  _proto.setYAxis = function setYAxis()
  /* yField, axes, facet */
  {};

  return Mirror;
}(List);

module.exports = Mirror;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview tree facets
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(46);

var Util = __webpack_require__(0);

var assign = Util.assign;

var Tree = /*#__PURE__*/function (_Base) {
  _inheritsLoose(Tree, _Base);

  function Tree() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Tree.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Base.prototype.getDefaultCfg.call(this);

    cfg.type = 'tree';
    cfg.line = {
      lineWidth: 1,
      stroke: '#ddd'
    };
    cfg.lineSmooth = false;
    return cfg;
  };

  _proto.generateFacets = function generateFacets(data) {
    var self = this;
    var fields = self.fields;

    if (!fields.length) {
      throw 'Please specify for the fields for facet!';
    }

    var rst = [];
    var root = self.getRootFacet(data); // if (self.showRoot) {

    rst.push(root); // }

    root.children = self.getChildFacets(data, 1, rst);
    self.setRegion(rst);
    return rst;
  };

  _proto.getRootFacet = function getRootFacet(data) {
    var self = this;
    var facet = {
      type: self.type,
      rows: self.getRows(),
      rowIndex: 0,
      colIndex: 0,
      colValue: self.rootTitle,
      data: data
    };
    return facet;
  };

  _proto.getRows = function getRows() {
    return this.fields.length + 1;
  } // get child
  ;

  _proto.getChildFacets = function getChildFacets(data, level, arr) {
    var self = this;
    var fields = self.fields;
    var length = fields.length;

    if (length < level) {
      return;
    }

    var rst = [];
    var field = fields[level - 1];
    var values = self.getFieldValues(field, data);
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var filter = self.getFilter(conditions);
      var subData = data.filter(filter);

      if (subData.length) {
        var facet = {
          type: self.type,
          colValue: value,
          colField: field,
          colIndex: index,
          rows: self.getRows(),
          rowIndex: level,
          data: subData,
          children: self.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  } // 璁剧疆 region
  ;

  _proto.setRegion = function setRegion(facets) {
    var self = this;
    self.forceColIndex(facets);
    facets.forEach(function (facet) {
      facet.region = self.getRegion(facet.rows, facet.cols, facet.colIndex, facet.rowIndex);
    });
  } // set column index of facets
  ;

  _proto.forceColIndex = function forceColIndex(facets) {
    var self = this;
    var leafs = [];
    var index = 0;
    facets.forEach(function (facet) {
      if (self.isLeaf(facet)) {
        leafs.push(facet);
        facet.colIndex = index;
        index++;
      }
    });
    leafs.forEach(function (facet) {
      facet.cols = leafs.length;
    });
    var maxLevel = self.fields.length;

    for (var i = maxLevel - 1; i >= 0; i--) {
      var levelFacets = self.getFacetsByLevel(facets, i); // var yIndex = maxLevel - i;

      for (var j = 0; j < levelFacets.length; j++) {
        var facet = levelFacets[j];

        if (!self.isLeaf(facet)) {
          facet.originColIndex = facet.colIndex;
          facet.colIndex = self.getRegionIndex(facet.children);
          facet.cols = leafs.length;
        }
      }
    }
  } // get facet use level
  ;

  _proto.getFacetsByLevel = function getFacetsByLevel(facets, level) {
    var rst = [];
    facets.forEach(function (facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  } // set facets region
  ;

  _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols; // x杞存柟鍚戠殑姣忎釜鍒嗛潰鐨勫亸绉�

    var yWidth = 1 / rows; // y杞存柟鍚戠殑姣忎釜鍒嗛潰鐨勫亸绉�

    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3 // 棰勭暀1/3鐨勭┖闅欙紝鏂逛究娣诲姞杩炴帴绾�

    };
    return {
      start: start,
      end: end
    };
  } // if the facet has children , make it's column index in the middle of it's children
  ;

  _proto.getRegionIndex = function getRegionIndex(children) {
    var first = children[0];
    var last = children[children.length - 1];
    return (last.colIndex - first.colIndex) / 2 + first.colIndex;
  } // is  a leaf without children
  ;

  _proto.isLeaf = function isLeaf(facet) {
    return !facet.children || !facet.children.length;
  };

  _proto.setXAxis = function setXAxis(xField, axes, facet) {
    // 褰撴槸鏈€鍚庝竴琛屾垨鑰呬笅闈㈡病鏈� view 鏃舵枃鏈笉鏄剧ず
    if (facet.rowIndex !== facet.rows - 1) {
      axes[xField].label = null;
      axes[xField].title = null;
    }
  } // 璁剧疆 y 鍧愭爣杞寸殑鏂囨湰銆乼itle 鏄惁鏄剧ず
  ;

  _proto.setYAxis = function setYAxis(yField, axes, facet) {
    if (facet.originColIndex !== 0 && facet.colIndex !== 0) {
      axes[yField].title = null;
      axes[yField].label = null;
    }
  } // 缁樺埗瀹屾垚鍚�
  ;

  _proto.onPaint = function onPaint() {
    _Base.prototype.onPaint.call(this);

    this.group.clear();

    if (this.facets && this.line) {
      this.drawLines(this.facets, this.group);
    }
  };

  _proto.drawLines = function drawLines(facets, group) {
    var self = this;
    var lineGroup = group.addGroup();
    facets.forEach(function (facet) {
      if (!self.isLeaf(facet)) {
        var children = facet.children;

        self._addFacetLines(facet, children, lineGroup);
      }
    });
  } // add lines with it's children
  ;

  _proto._addFacetLines = function _addFacetLines(facet, children, group) {
    var self = this;
    var view = facet.view;
    var region = view.getViewRegion();
    var start = {
      x: region.start.x + (region.end.x - region.start.x) / 2,
      y: region.start.y
    };
    children.forEach(function (subFacet) {
      var subRegion = subFacet.view.getViewRegion();
      var end = {
        x: subRegion.start.x + (subRegion.end.x - subRegion.start.x) / 2,
        y: subRegion.end.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };

      self._drawLine([start, middle1, middle2, end], group);
    });
  };

  _proto._getPath = function _getPath(points) {
    var self = this;
    var path = [];
    var smooth = self.lineSmooth;

    if (smooth) {
      path.push(['M', points[0].x, points[0].y]);
      path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    } else {
      points.forEach(function (point, index) {
        if (index === 0) {
          path.push(['M', point.x, point.y]);
        } else {
          path.push(['L', point.x, point.y]);
        }
      });
    }

    return path;
  } // draw line width points
  ;

  _proto._drawLine = function _drawLine(points, group) {
    var self = this;

    var path = self._getPath(points);

    var line = self.line;
    group.addShape('path', {
      attrs: assign({
        path: path
      }, line)
    });
  };

  return Tree;
}(Base);

module.exports = Tree;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 闈㈢Н鍥�
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var SplitMixin = __webpack_require__(128);

var Util = __webpack_require__(0);

__webpack_require__(304);

var Area = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Area, _GeomBase);

  var _proto = Area.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'area';
    cfg.shapeType = 'area';
    cfg.generatePoints = true;
    cfg.sortable = true;
    return cfg;
  };

  function Area(cfg) {
    var _this;

    _this = _GeomBase.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), SplitMixin);
    return _this;
  }

  _proto.draw = function draw(data, container, shapeFactory, index) {
    var self = this;
    var cfg = this.getDrawCfg(data[0]);

    self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);

    var splitArray = this.splitData(data);
    cfg.origin = data; // path,line,area 绛夊浘鐨刼rigin 鏄暣涓簭鍒�

    Util.each(splitArray, function (subData, splitedIndex) {
      cfg.splitedIndex = splitedIndex; // 浼犲叆鍒嗗壊鐗囨绱㈠紩 鐢ㄤ簬鐢熸垚id

      var points = subData.map(function (obj) {
        return obj.points;
      });
      cfg.points = points;
      var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);
      self.appendShapeInfo(geomShape, index + splitedIndex);
    });
  };

  return Area;
}(GeomBase);

var AreaStack = /*#__PURE__*/function (_Area) {
  _inheritsLoose(AreaStack, _Area);

  function AreaStack() {
    return _Area.apply(this, arguments) || this;
  }

  var _proto2 = AreaStack.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Area.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'stack'
    }];
    return cfg;
  };

  return AreaStack;
}(Area);

Area.Stack = AreaStack;
GeomBase.Area = Area;
GeomBase.AreaStack = AreaStack;
module.exports = Area;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 杈癸紝鐢ㄤ簬鍏崇郴鍥剧殑杈�
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

__webpack_require__(305);

var Edge = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Edge, _GeomBase);

  function Edge() {
    return _GeomBase.apply(this, arguments) || this;
  }

  var _proto = Edge.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'edge';
    cfg.shapeType = 'edge';
    cfg.generatePoints = true;
    return cfg;
  };

  return Edge;
}(GeomBase);

GeomBase.Edge = Edge;
module.exports = Edge;

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview heatmap
 * @author leungwensen@gmail.com
 */
var _require = __webpack_require__(65),
    ColorUtil = _require.ColorUtil; // TODO: ColorUtil 鐙珛鎴愬寘锛屼粠 attr 鍖呬腑鎶界


var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

var ORIGIN_FIELD = '_origin';
var SHADOW_CANVAS = 'shadowCanvas';
var VALUE_RANGE = 'valueRange';
var IMAGE_SHAPE = 'imageShape';
var MAPPED_DATA = 'mappedData';
var GRAY_SCALE_BLURRED_CANVAS = 'grayScaleBlurredCanvas';
var HEATMAP_SIZE = 'heatmapSize';

var Heatmap = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Heatmap, _GeomBase);

  function Heatmap() {
    return _GeomBase.apply(this, arguments) || this;
  }

  var _proto = Heatmap.prototype;

  /**
   * get default configuration
   * @protected
   * @return {Object} configuration
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'heatmap';
    cfg.paletteCache = {}; // cfg.shapeType = 'heatmap';

    return cfg;
  };

  _proto._prepareRange = function _prepareRange() {
    var self = this;
    var data = self.get(MAPPED_DATA);
    var colorAttr = self.getAttr('color');
    var colorField = colorAttr.field;
    var min = Infinity;
    var max = -Infinity;
    data.forEach(function (row) {
      var value = row[ORIGIN_FIELD][colorField];

      if (value > max) {
        max = value;
      }

      if (value < min) {
        min = value;
      }
    });

    if (min === max) {
      min = max - 1;
    }

    var range = [min, max];
    self.set(VALUE_RANGE, range);
  };

  _proto._prepareSize = function _prepareSize() {
    var self = this;
    var radius = self.getDefaultValue('size');

    if (!Util.isNumber(radius)) {
      radius = self._getDefaultSize();
    }

    var styleOptions = self.get('styleOptions');
    var blur = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.blur : null;

    if (!Util.isFinite(blur) || blur === null) {
      blur = radius / 2;
    }

    self.set(HEATMAP_SIZE, {
      blur: blur,
      radius: radius
    });
  };

  _proto._getDefaultSize = function _getDefaultSize() {
    var self = this;
    var position = self.getAttr('position');
    var coord = self.get('coord');
    var radius = Math.min(coord.width / (position.scales[0].ticks.length * 4), coord.height / (position.scales[1].ticks.length * 4));
    return radius;
  };

  _proto._colorize = function _colorize(img) {
    var self = this;
    var colorAttr = self.getAttr('color');
    var pixels = img.data;
    var paletteCache = self.get('paletteCache');

    for (var i = 3; i < pixels.length; i += 4) {
      var alpha = pixels[i]; // get gradient color from opacity value

      if (alpha) {
        var palette = void 0;

        if (paletteCache[alpha]) {
          palette = paletteCache[alpha];
        } else {
          palette = ColorUtil.rgb2arr(colorAttr.gradient(alpha / 256));
          paletteCache[alpha] = palette;
        } // const palette = colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));


        pixels[i - 3] = palette[0];
        pixels[i - 2] = palette[1];
        pixels[i - 1] = palette[2];
        pixels[i] = alpha;
      }
    }
  };

  _proto._prepareGreyScaleBlurredCircle = function _prepareGreyScaleBlurredCircle(r, blur) {
    var self = this;
    var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);

    if (!circleCanvas) {
      circleCanvas = document.createElement('canvas');
      self.set(GRAY_SCALE_BLURRED_CANVAS, circleCanvas);
    }

    var r2 = r + blur;
    var ctx = circleCanvas.getContext('2d');
    circleCanvas.width = circleCanvas.height = r2 * 2;
    ctx.clearRect(0, 0, circleCanvas.width, circleCanvas.height); // ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;

    ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
    ctx.shadowBlur = blur;
    ctx.shadowColor = 'black';
    ctx.beginPath();
    ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
  };

  _proto._drawGrayScaleBlurredCircle = function _drawGrayScaleBlurredCircle(x, y, r, alpha, ctx) {
    var self = this;
    var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);
    ctx.globalAlpha = alpha;
    ctx.drawImage(circleCanvas, x - r, y - r);
  };

  _proto._getShadowCanvasCtx = function _getShadowCanvasCtx() {
    var self = this;
    var canvas = self.get(SHADOW_CANVAS);

    if (!canvas) {
      canvas = document.createElement('canvas');
      self.set(SHADOW_CANVAS, canvas);
    }

    var coord = self.get('coord');

    if (coord) {
      canvas.width = coord.width;
      canvas.height = coord.height;
    }

    return canvas.getContext('2d');
  };

  _proto._clearShadowCanvasCtx = function _clearShadowCanvasCtx() {
    var ctx = this._getShadowCanvasCtx();

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  };

  _proto._getImageShape = function _getImageShape() {
    var self = this;
    var imageShape = self.get(IMAGE_SHAPE);

    if (imageShape) {
      return imageShape;
    }

    var container = self.get('container');
    imageShape = container.addShape('Image', {});
    self.set(IMAGE_SHAPE, imageShape);
    return imageShape;
  };

  _proto.clear = function clear() {
    // @2019-02-28 by blue.lb 鐢变簬璁剧疆浜哠HADOW_CANVAS浣滀负鍍忕礌缂撳瓨canvas锛屾瘡娆￠攢姣乧hart鏃讹紝涔熼渶瑕佹竻闄よ缂撳啿鍖�
    this._clearShadowCanvasCtx();

    _GeomBase.prototype.clear.call(this);
  };

  _proto.drawWithRange = function drawWithRange(range) {
    var self = this; // canvas size

    var _self$get = self.get('coord'),
        start = _self$get.start,
        end = _self$get.end,
        width = _self$get.width,
        height = _self$get.height; // value, range, etc


    var valueField = self.getAttr('color').field;
    var size = self.get(HEATMAP_SIZE); // prepare shadow canvas context

    self._clearShadowCanvasCtx();

    var ctx = self._getShadowCanvasCtx(); // filter data


    var data = self.get(MAPPED_DATA);

    if (range) {
      data = data.filter(function (row) {
        return row[ORIGIN_FIELD][valueField] <= range[1] && row[ORIGIN_FIELD][valueField] >= range[0];
      });
    } // step1. draw points with shadow


    var scale = self._getScale(valueField);

    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var cfg = self.getDrawCfg(obj);
      var alpha = scale.scale(obj[ORIGIN_FIELD][valueField]);

      self._drawGrayScaleBlurredCircle(cfg.x - start.x, cfg.y - end.y, size.radius + size.blur, alpha, ctx);
    } // step2. convert pixels


    var colored = ctx.getImageData(0, 0, width, height);

    self._clearShadowCanvasCtx();

    self._colorize(colored);

    ctx.putImageData(colored, 0, 0);

    var imageShape = self._getImageShape();

    imageShape.attr('x', start.x);
    imageShape.attr('y', end.y);
    imageShape.attr('width', width);
    imageShape.attr('height', height);
    imageShape.attr('img', ctx.canvas);
  };

  _proto.draw = function draw(data
  /* , container, shapeFactory, index */
  ) {
    var self = this;
    self.set(MAPPED_DATA, data);

    self._prepareRange();

    self._prepareSize();

    var size = self.get(HEATMAP_SIZE);

    self._prepareGreyScaleBlurredCircle(size.radius, size.blur);

    var range = self.get(VALUE_RANGE);
    self.drawWithRange(range); // super.draw(data, container, shapeFactory, index);
  };

  return Heatmap;
}(GeomBase);

GeomBase.Heatmap = Heatmap;
module.exports = Heatmap;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var Geom = __webpack_require__(8);

Geom.Point = __webpack_require__(301);
Geom.PointJitter = Geom.Point.Jitter;
Geom.PointStack = Geom.Point.Stack;
Geom.Path = __webpack_require__(130);
Geom.Line = __webpack_require__(297);
Geom.LineStack = Geom.Line.Stack;
Geom.Interval = __webpack_require__(293);
Geom.IntervalStack = Geom.Interval.Stack;
Geom.IntervalDodge = Geom.Interval.Dodge;
Geom.IntervalSymmetric = Geom.Interval.Symmetric;
Geom.Area = __webpack_require__(289);
Geom.AreaStack = Geom.Area.Stack;
Geom.Polygon = __webpack_require__(302);
Geom.Schema = __webpack_require__(303);
Geom.SchemaDodge = Geom.Schema.Dodge;
Geom.Edge = __webpack_require__(290);
Geom.Heatmap = __webpack_require__(291);
Geom.Venn = __webpack_require__(315);
Geom.Violin = __webpack_require__(316);
module.exports = Geom;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview interval geometry
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

var SizeMixin = __webpack_require__(70);

__webpack_require__(306);

var Interval = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Interval, _GeomBase);

  var _proto = Interval.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'interval';
    cfg.shapeType = 'interval';
    cfg.generatePoints = true;
    return cfg;
  };

  function Interval(cfg) {
    var _this;

    _this = _GeomBase.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), SizeMixin);
    return _this;
  }

  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

    cfg.size = this.getNormalizedSize(obj);
    return cfg;
  };

  _proto.clearInner = function clearInner() {
    _GeomBase.prototype.clearInner.call(this);

    this.set('defaultSize', null);
  };

  return Interval;
}(GeomBase);

var IntervalStack = /*#__PURE__*/function (_Interval) {
  _inheritsLoose(IntervalStack, _Interval);

  function IntervalStack() {
    return _Interval.apply(this, arguments) || this;
  }

  var _proto2 = IntervalStack.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interval.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'stack'
    }];
    return cfg;
  };

  return IntervalStack;
}(Interval);

var IntervalDodge = /*#__PURE__*/function (_Interval2) {
  _inheritsLoose(IntervalDodge, _Interval2);

  function IntervalDodge() {
    return _Interval2.apply(this, arguments) || this;
  }

  var _proto3 = IntervalDodge.prototype;

  _proto3.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interval2.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'dodge'
    }];
    return cfg;
  };

  return IntervalDodge;
}(Interval);

var IntervalSymmetric = /*#__PURE__*/function (_Interval3) {
  _inheritsLoose(IntervalSymmetric, _Interval3);

  function IntervalSymmetric() {
    return _Interval3.apply(this, arguments) || this;
  }

  var _proto4 = IntervalSymmetric.prototype;

  _proto4.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interval3.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'symmetric'
    }];
    return cfg;
  };

  return IntervalSymmetric;
}(Interval);

Interval.Stack = IntervalStack;
Interval.Dodge = IntervalDodge;
Interval.Symmetric = IntervalSymmetric;
GeomBase.Interval = Interval;
GeomBase.IntervalStack = IntervalStack;
GeomBase.IntervalDodge = IntervalDodge;
GeomBase.IntervalSymmetric = IntervalSymmetric;
module.exports = Interval;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var GeomLabels = __webpack_require__(69);

var PolarLabels = __webpack_require__(127);

var PieLabels = __webpack_require__(296);

var IntervalLabels = __webpack_require__(295);

var Labels = {
  getLabelsClass: function getLabelsClass(coordType, type) {
    var rst = GeomLabels;

    if (coordType === 'polar') {
      rst = PolarLabels;
    } else if (coordType === 'theta') {
      // pie chart
      rst = PieLabels;
    } else if (type === 'interval' || type === 'polygon') {
      // bar
      rst = IntervalLabels;
    }

    return rst;
  }
};
module.exports = Labels;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var GeomLabels = __webpack_require__(69);

var IntervalLabels = function IntervalLabels(cfg) {
  IntervalLabels.superclass.constructor.call(this, cfg);
};

Util.extend(IntervalLabels, GeomLabels);
Util.augment(IntervalLabels, {
  setLabelPosition: function setLabelPosition(point, originPoint, index, position) {
    if (Util.isFunction(position)) {
      position = position(point.text, originPoint._origin, index);
    }

    var coord = this.get('coord');
    var transposed = coord.isTransposed;
    var point0 = coord.convertPoint(originPoint.points[0]);
    var point1 = coord.convertPoint(originPoint.points[2]);
    var width = (point0.x - point1.x) / 2 * (transposed ? -1 : 1);
    var height = (point0.y - point1.y) / 2 * (transposed ? -1 : 1);

    switch (position) {
      case 'right':
        if (transposed) {
          point.x -= width;
          point.y += height;
          point.textAlign = point.textAlign || 'center';
        } else {
          point.x -= width;
          point.y += height;
          point.textAlign = point.textAlign || 'left';
        }

        break;

      case 'left':
        if (transposed) {
          point.x -= width;
          point.y -= height;
          point.textAlign = point.textAlign || 'center';
        } else {
          point.x += width;
          point.y += height;
          point.textAlign = point.textAlign || 'right';
        }

        break;

      case 'bottom':
        if (transposed) {
          point.x -= width * 2;
          point.textAlign = point.textAlign || 'left';
        } else {
          point.y += height * 2;
          point.textAlign = point.textAlign || 'center';
        }

        break;

      case 'middle':
        if (transposed) {
          point.x -= width;
        } else {
          point.y += height;
        }

        point.textAlign = point.textAlign || 'center';
        break;

      case 'top':
        if (transposed) {
          point.textAlign = point.textAlign || 'left';
        } else {
          point.textAlign = point.textAlign || 'center';
        }

        break;

      default:
        break;
    }
  }
});
module.exports = IntervalLabels;

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var PolarLabels = __webpack_require__(127);

var PathUtil = __webpack_require__(25);

var Global = __webpack_require__(5);

var MARGIN = 5;

function getEndPoint(center, angle, r) {
  return {
    x: center.x + r * Math.cos(angle),
    y: center.y + r * Math.sin(angle)
  };
}

function antiCollision(labels, lineHeight, plotRange, center, isRight) {
  // adjust y position of labels to avoid overlapping
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function (label) {
    if (label.y > maxY) {
      maxY = label.y;
    }

    if (label.y < minY) {
      minY = label.y;
    }

    return {
      size: lineHeight,
      targets: [label.y - startY]
    };
  });
  minY -= startY;

  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }

  while (overlapping) {
    /* eslint no-loop-func: 0 */
    boxes.forEach(function (box) {
      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size); // box.pos = Math.max(0, target - box.size / 2);
    }); // detect overlapping and join boxes

    overlapping = false;
    i = boxes.length;

    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box = boxes[i];

        if (previousBox.pos + previousBox.size > box.pos) {
          // overlapping
          previousBox.size += box.size;
          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up

          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }

          boxes.splice(i, 1); // removing box

          overlapping = true;
        }
      }
    }
  }

  i = 0; // step 4: normalize y and adjust x

  boxes.forEach(function (b) {
    var posInCompositeBox = startY + lineHeight / 2; // middle of the label

    b.targets.forEach(function () {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  }); // (x - cx)^2 + (y - cy)^2 = totalR^2

  labels.forEach(function (label) {
    var rPow2 = label.r * label.r;
    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);

    if (rPow2 < dyPow2) {
      label.x = center.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);

      if (!isRight) {
        // left
        label.x = center.x - dx;
      } else {
        // right
        label.x = center.x + dx;
      }
    }
  });
}

var PieLabels = function PieLabels(cfg) {
  PieLabels.superclass.constructor.call(this, cfg);
};

Util.extend(PieLabels, PolarLabels);
Util.augment(PieLabels, {
  getDefaultCfg: function getDefaultCfg() {
    return {
      label: Global.thetaLabels
    };
  },
  getDefaultOffset: function getDefaultOffset(point) {
    return point.offset || 0;
  },

  /**
   * @protected
   * to avoid overlapping
   * @param {Array} items labels to be placed
   * @return {Array} items
   */
  adjustItems: function adjustItems(items) {
    var self = this;
    var offset = items[0] ? items[0].offset : 0;

    if (offset > 0) {
      items = self._distribute(items, offset);
    }

    return PieLabels.superclass.adjustItems.call(this, items);
  },

  /**
   * @private
   * distribute labels
   * @param {Array} labels labels
   * @param {Number} offset offset
   * @return {Array} labels
   */
  _distribute: function _distribute(labels, offset) {
    var self = this;
    var coord = self.get('coord');
    var radius = coord.getRadius();
    var lineHeight = self.get('label').labelHeight;
    var center = coord.getCenter();
    var totalR = radius + offset;
    var totalHeight = totalR * 2 + lineHeight * 2;
    var plotRange = {
      start: coord.start,
      end: coord.end
    };
    var geom = self.get('geom');

    if (geom) {
      var view = geom.get('view');
      plotRange = view.getViewRegion();
    } // step 1: separate labels


    var halves = [[], // left
    [] // right
    ];
    labels.forEach(function (label) {
      if (!label) {
        return;
      }

      if (label.textAlign === 'right') {
        // left
        halves[0].push(label);
      } else {
        // right or center will be put on the right side
        halves[1].push(label);
      }
    });
    halves.forEach(function (half, index) {
      // step 2: reduce labels
      var maxLabelsCountForOneSide = parseInt(totalHeight / lineHeight, 10);

      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function (a, b) {
          // sort by percentage DESC
          return b['..percent'] - a['..percent'];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      } // step 3: distribute position (x and y)


      half.sort(function (a, b) {
        // sort by y ASC
        return a.y - b.y;
      });
      antiCollision(half, lineHeight, plotRange, center, index);
    });
    return halves[0].concat(halves[1]);
  },
  // 杩炴帴绾�
  lineToLabel: function lineToLabel(label) {
    var self = this;
    var coord = self.get('coord');
    var r = coord.getRadius();
    var distance = label.offset;
    var angle = label.orignAngle || label.angle;
    var center = coord.getCenter();
    var start = getEndPoint(center, angle, r + MARGIN / 2);
    var inner = getEndPoint(center, angle, r + distance / 2);

    if (!label.labelLine) {
      label.labelLine = self.get('label').labelLine || {};
    }

    label.labelLine.path = ['M' + start.x, start.y + ' Q' + inner.x, inner.y + ' ' + label.x, label.y].join(',');
  },

  /**
   * @protected
   * get rotation for label
   * @param {Number} angle angle
   * @param {Number} offset offset
   * @return {Number} rotate
   */
  getLabelRotate: function getLabelRotate(angle, offset) {
    var rotate;

    if (offset < 0) {
      rotate = angle * 180 / Math.PI;

      if (rotate > 90) {
        rotate = rotate - 180;
      }

      if (rotate < -90) {
        rotate = rotate + 180;
      }
    }

    return rotate / 180 * Math.PI;
  },

  /**
   * @protected
   * get text align for label
   * @param {Object} point point
   * @return {String} align
   */
  getLabelAlign: function getLabelAlign(point) {
    var self = this;
    var coord = self.get('coord');
    var center = coord.getCenter();
    var align;

    if (point.angle <= Math.PI / 2 && point.x >= center.x) {
      align = 'left';
    } else {
      align = 'right';
    }

    var offset = self.getDefaultOffset(point);

    if (offset <= 0) {
      if (align === 'right') {
        align = 'left';
      } else {
        align = 'right';
      }
    }

    return align;
  },
  getArcPoint: function getArcPoint(point) {
    return point;
  },
  getPointAngle: function getPointAngle(point) {
    var self = this;
    var coord = self.get('coord');
    var startPoint = {
      x: Util.isArray(point.x) ? point.x[0] : point.x,
      y: point.y[0]
    };
    self.transLabelPoint(startPoint); // 杞崲鍒扮敾甯冨潗鏍囷紝濡傛灉鍧愭爣绯诲彂鐢熸敼鍙�

    var endPoint = {
      x: Util.isArray(point.x) ? point.x[1] : point.x,
      y: point.y[1]
    };
    self.transLabelPoint(endPoint); // 杞崲鍒扮敾甯冨潗鏍囷紝濡傛灉鍧愭爣绯诲彂鐢熸敼鍙�

    var angle;
    var startAngle = PathUtil.getPointAngle(coord, startPoint);

    if (point.points && point.points[0].y === point.points[1].y) {
      angle = startAngle;
    } else {
      var endAngle = PathUtil.getPointAngle(coord, endPoint);

      if (startAngle >= endAngle) {
        // 100% pie slice
        endAngle = endAngle + Math.PI * 2;
      }

      angle = startAngle + (endAngle - startAngle) / 2;
    }

    return angle;
  },
  getCirclePoint: function getCirclePoint(angle, offset) {
    var self = this;
    var coord = self.get('coord');
    var center = coord.getCenter();
    var r = coord.getRadius() + offset;
    var point = getEndPoint(center, angle, r);
    point.angle = angle;
    point.r = r;
    return point;
  }
});
module.exports = PieLabels;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 绾垮浘
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Path = __webpack_require__(130);

__webpack_require__(307);

var Line = /*#__PURE__*/function (_Path) {
  _inheritsLoose(Line, _Path);

  function Line() {
    return _Path.apply(this, arguments) || this;
  }

  var _proto = Line.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Path.prototype.getDefaultCfg.call(this);

    cfg.type = 'line';
    cfg.sortable = true;
    return cfg;
  };

  return Line;
}(Path);

var LineStack = /*#__PURE__*/function (_Line) {
  _inheritsLoose(LineStack, _Line);

  function LineStack() {
    return _Line.apply(this, arguments) || this;
  }

  var _proto2 = LineStack.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Line.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'stack'
    }];
    return cfg;
  };

  return LineStack;
}(Line);

Line.Stack = LineStack;
GeomBase.Line = Line;
GeomBase.LineStack = LineStack;
module.exports = Line;

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview the interaction when geom was actived
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var FIELD_ORIGIN = '_origin';

var ZIndexUtil = __webpack_require__(129);

var ATTRS_ORIGIN_ACTIVE = '_originActiveAttrs';

function isSameShape(shape1, shape2) {
  if (Util.isNil(shape1) || Util.isNil(shape2)) {
    return false;
  }

  var shape1Origin = shape1.get('origin');
  var shape2Origin = shape2.get('origin');
  return Util.isEqual(shape1Origin, shape2Origin);
}

function isChange(preShapes, shapes) {
  if (!preShapes) {
    return true;
  }

  if (preShapes.length !== shapes.length) {
    return true;
  }

  var rst = false;
  Util.each(shapes, function (shape, index) {
    if (!isSameShape(shape, preShapes[index])) {
      rst = true;
      return false;
    }
  });
  return rst;
}

function getOriginAttrs(activeCfg, shape) {
  var originAttrs = {};
  Util.each(activeCfg, function (v, k) {
    var originValue = shape.attr(k);

    if (Util.isArray(originValue)) {
      originValue = Util.cloneDeep(originValue); // 缂撳瓨鍘熸潵鐨勫睘鎬э紝鐢变簬 .attr('matrix') 鏄暟缁勶紝鎵€浠ユ澶勯渶瑕佹繁搴﹀鍒�
    }

    originAttrs[k] = originValue;
  });
  return originAttrs;
}

var ActiveMixin = {
  _isAllowActive: function _isAllowActive() {
    var allowActive = this.get('allowActive');

    if (Util.isNil(allowActive)) {
      // 鐢ㄦ埛鏈缃紝浣跨敤榛樿鐨勭瓥鐣�
      var view = this.get('view');
      var isShareTooltip = this.isShareTooltip();
      var options = view.get('options'); // 榛樿鎯呭喌涓嬶紝tooltip 鍏抽棴鎴栬€� tooltip 妯″紡涓� shared === false 鐨勬椂鍊欏厑璁� active

      if (options.tooltip === false || !isShareTooltip) {
        return true;
      }
    } else {
      return allowActive;
    }

    return false;
  },
  _onMouseenter: function _onMouseenter(ev) {
    var self = this;
    var shape = ev.shape;
    var shapeContainer = self.get('shapeContainer');

    if (shape && shapeContainer.contain(shape) && self._isAllowActive()) {
      // shape.get('animating')
      self.setShapesActived(shape);
    }
  },
  _onMouseleave: function _onMouseleave() {
    var self = this;
    var view = self.get('view');
    var canvas = view.get('canvas');

    if (self.get('activeShapes')) {
      self.clearActivedShapes();
      canvas.draw();
    }
  },
  _bindActiveAction: function _bindActiveAction() {
    var self = this;
    var view = self.get('view');
    var type = self.get('type');
    view.on(type + ':mouseenter', Util.wrapBehavior(self, '_onMouseenter'));
    view.on(type + ':mouseleave', Util.wrapBehavior(self, '_onMouseleave'));
  },
  _offActiveAction: function _offActiveAction() {
    var self = this;
    var view = self.get('view');
    var type = self.get('type');
    view.off(type + ':mouseenter', Util.getWrapBehavior(self, '_onMouseenter'));
    view.off(type + ':mouseleave', Util.getWrapBehavior(self, '_onMouseleave'));
  },
  _setActiveShape: function _setActiveShape(shape) {
    var self = this;
    var activedOptions = self.get('activedOptions') || {};
    var shapeData = shape.get('origin');
    var shapeName = shapeData.shape || self.getDefaultValue('shape');

    if (Util.isArray(shapeName)) {
      shapeName = shapeName[0];
    }

    var shapeFactory = self.get('shapeFactory');
    var shapeCfg = Util.mix({}, shape.attr(), {
      origin: shapeData
    });
    var activeCfg = shapeFactory.getActiveCfg(shapeName, shapeCfg);

    if (activedOptions.style) {
      Util.mix(activeCfg, activedOptions.style);
    }

    var originAttrs = getOriginAttrs(activeCfg, shape);
    shape.setSilent(ATTRS_ORIGIN_ACTIVE, originAttrs);

    if (activedOptions.animate) {
      shape.animate(activeCfg, 300);
    } else {
      shape.attr(activeCfg);
    }

    ZIndexUtil.toFront(shape); // 鎻愬墠
  },
  setShapesActived: function setShapesActived(shapes) {
    var self = this;

    if (!Util.isArray(shapes)) {
      shapes = [shapes];
    }

    var preShapes = self.get('activeShapes'); // 鑾峰彇涓婃琚縺娲荤殑 shapes

    if (!isChange(preShapes, shapes)) {
      return;
    }

    var view = self.get('view');
    var canvas = view.get('canvas');
    var activedOptions = self.get('activedOptions');

    if (activedOptions && activedOptions.highlight) {
      // 涓婃鐨勫姩鐢绘湭瀹屾垚锛屾墍浠ヨ鍋滄鎺夊姩鐢�
      Util.each(shapes, function (shape) {
        if (shape.get('animating')) {
          shape.stopAnimate();
        }
      });
      self.highlightShapes(shapes);
    } else {
      if (preShapes) {
        self.clearActivedShapes(); // 鍏堟竻闄ゆ縺娲诲厓绱�
      }

      Util.each(shapes, function (shape) {
        if (shape.get('animating')) {
          shape.stopAnimate();
        }

        if (shape.get('visible')) {
          // && !shape.get('selected')
          self._setActiveShape(shape);
        }
      });
    }

    self.set('activeShapes', shapes); // shapeContainer.sort(); // toFront, resetZIndex 涓嶉渶瑕佸啀鎺掑簭

    canvas.draw();
  },
  clearActivedShapes: function clearActivedShapes() {
    var self = this;
    var shapeContainer = self.get('shapeContainer');
    var activedOptions = self.get('activedOptions');
    var activeAnimate = activedOptions && activedOptions.animate;

    if (shapeContainer && !shapeContainer.get('destroyed')) {
      var activeShapes = self.get('activeShapes');
      Util.each(activeShapes, function (activeShape) {
        // if (!activeShape.get('selected')) {
        var originAttrs = activeShape.get(ATTRS_ORIGIN_ACTIVE);

        if (activeAnimate) {
          activeShape.stopAnimate();
          activeShape.animate(originAttrs, 300);
        } else {
          activeShape.attr(originAttrs);
        }

        ZIndexUtil.resetZIndex(activeShape);
        activeShape.setSilent(ATTRS_ORIGIN_ACTIVE, null); // }
      });
      var preHighlightShapes = self.get('preHighlightShapes');

      if (preHighlightShapes) {
        var shapes = shapeContainer.get('children');
        Util.each(shapes, function (shape) {
          // if (!shape.get('selected')) {
          var originAttrs = shape.get(ATTRS_ORIGIN_ACTIVE);

          if (originAttrs) {
            if (activeAnimate) {
              shape.stopAnimate();
              shape.animate(originAttrs, 300);
            } else {
              shape.attr(originAttrs);
            }

            ZIndexUtil.resetZIndex(shape);
            shape.setSilent(ATTRS_ORIGIN_ACTIVE, null);
          } // }

        });
      } // 鎭㈠鍘熸潵鎺掑簭
      // const children = shapeContainer.get('children');
      // children.sort((obj1, obj2) => {
      //   return obj1._INDEX - obj2._INDEX;
      // });


      self.set('activeShapes', null);
      self.set('preHighlightShapes', null);
    }
  },
  getGroupShapesByPoint: function getGroupShapesByPoint(point) {
    var self = this;
    var shapeContainer = self.get('shapeContainer');
    var activeShapes = [];

    if (shapeContainer) {
      var xField = self.getXScale().field;
      var shapes = self.getShapes();

      var originObj = self._getOriginByPoint(point);

      Util.each(shapes, function (shape) {
        var origin = shape.get('origin');

        if (shape.get('visible') && origin) {
          // 鏈夊彲鑳戒笉鏄浘褰紝鑰屾槸label鏂囨湰锛屾墍浠ュ垽鏂竴涓�
          var shapeXValue = origin[FIELD_ORIGIN][xField];

          if (shapeXValue === originObj[xField]) {
            activeShapes.push(shape);
          }
        }
      });
    }

    return activeShapes;
  },
  getSingleShapeByPoint: function getSingleShapeByPoint(point) {
    var self = this;
    var shapeContainer = self.get('shapeContainer');
    var canvas = shapeContainer.get('canvas');
    var pixelRatio = canvas.get('pixelRatio');
    var result;

    if (shapeContainer) {
      result = shapeContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);
    }

    if (result && result.get('origin')) {
      return result;
    }
  },
  highlightShapes: function highlightShapes(_highlightShapes, highlightCfg) {
    var self = this;

    if (!Util.isArray(_highlightShapes)) {
      _highlightShapes = [_highlightShapes];
    }

    var preHighlightShapes = self.get('activeShapes'); // 鑾峰彇涓婃琚縺娲荤殑 shapes

    if (!isChange(preHighlightShapes, _highlightShapes)) {
      return;
    }

    if (preHighlightShapes) {
      self.clearActivedShapes();
    }

    var shapes = self.getShapes();
    var activedOptions = self.get('activedOptions');
    var activeAnimate = activedOptions && activedOptions.animate;
    var activeStyle = activedOptions && activedOptions.style;
    Util.each(shapes, function (shape) {
      var changeAttrs = {};
      shape.stopAnimate();

      if (Util.indexOf(_highlightShapes, shape) !== -1) {
        Util.mix(changeAttrs, activeStyle, highlightCfg); // shape.setZIndex(1); // 鎻愬墠

        ZIndexUtil.toFront(shape);
      } else {
        Util.mix(changeAttrs, {
          fillOpacity: 0.3,
          // @2018-07-11 by blue.lb 鐢变簬绾垮浘鍙湁stoke锛宖illOpacity涓嶇敓鏁堬紝鏈€濂借繕鏄洿鎺ユ敼鎴愭暣涓浘褰㈤€忔槑搴pacity
          opacity: 0.3
        });
        ZIndexUtil.resetZIndex(shape);
      }

      var originAttrs = getOriginAttrs(changeAttrs, shape);
      shape.setSilent(ATTRS_ORIGIN_ACTIVE, originAttrs);

      if (activeAnimate) {
        shape.animate(changeAttrs, 300);
      } else {
        shape.attr(changeAttrs);
      }
    });
    self.set('preHighlightShapes', _highlightShapes);
    self.set('activeShapes', _highlightShapes);
  }
};
module.exports = ActiveMixin;

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview the interaction when geom was selected
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var FIELD_ORIGIN = '_origin';

var ZIndexUtil = __webpack_require__(129);

function isSameShape(shape1, shape2) {
  if (Util.isNil(shape1) || Util.isNil(shape2)) {
    return false;
  }

  var shape1Origin = shape1.get('origin');
  var shape2Origin = shape2.get('origin');
  return Util.isEqual(shape1Origin, shape2Origin);
}

function getOriginAttrs(selectedCfg, shape) {
  var originAttrs = {};
  Util.each(selectedCfg, function (v, k) {
    if (k === 'transform') {
      k = 'matrix';
    }

    var originValue = shape.attr(k);

    if (Util.isArray(originValue)) {
      originValue = Util.cloneDeep(originValue); // 缂撳瓨鍘熸潵鐨勫睘鎬э紝鐢变簬 .attr('matrix') 鏄暟缁勶紝鎵€浠ユ澶勯渶瑕佹繁搴﹀鍒�
    }

    originAttrs[k] = originValue;
  });
  return originAttrs;
}

var SelectMixin = {
  _isAllowSelect: function _isAllowSelect() {
    var isAllowSelect = this.get('allowSelect');

    if (Util.isNil(isAllowSelect)) {
      var type = this.get('type');
      var coord = this.get('coord');
      var coordType = coord && coord.type;

      if (type === 'interval' && coordType === 'theta') {
        // 楗煎浘榛樿鍙互杩涜閫変腑
        return true;
      }
    } else {
      // 鐢ㄦ埛璁剧疆浜� select 閰嶇疆
      return isAllowSelect;
    }

    return false;
  },
  _onClick: function _onClick(ev) {
    var self = this;

    if (self._isAllowSelect()) {
      // 鍏佽閫変腑涓嬫墠鎵ц
      // self.clearActivedShapes(); // 涓嶉渶瑕佹竻闄over鏁堟灉
      var shape = ev.shape;
      var shapeContainer = self.get('shapeContainer');

      if (shape && shapeContainer.contain(shape)) {
        // 鍘婚櫎 !shape.get('animating') 鐨勫垽瀹氾紝鐐瑰嚮鍙嶉鏇村姞鍙婃椂
        self.setShapeSelected(shape);
      }
    }
  },
  _bindSelectedAction: function _bindSelectedAction() {
    var self = this;
    var view = self.get('view');
    var type = self.get('type');
    view.on(type + ':click', Util.wrapBehavior(self, '_onClick'));
  },
  _offSelectedAction: function _offSelectedAction() {
    var self = this;
    var view = self.get('view');
    var type = self.get('type');
    view.off(type + ':click', Util.getWrapBehavior(self, '_onClick'));
  },
  _setShapeStatus: function _setShapeStatus(shape, status) {
    var self = this;
    var view = self.get('view');
    var selectedOptions = self.get('selectedOptions') || {};
    var animate = selectedOptions.animate !== false; // 榛樿鍏佽鍔ㄧ敾

    var canvas = view.get('canvas');
    shape.set('selected', status);
    var shapeData = shape.get('origin');

    if (status) {
      // 閫変腑鐘舵€�
      var shapeName = shapeData.shape || self.getDefaultValue('shape');

      if (Util.isArray(shapeName)) {
        shapeName = shapeName[0];
      }

      var shapeFactory = self.get('shapeFactory');
      var cfg = Util.mix({
        geom: self,
        point: shapeData
      }, selectedOptions);
      var selectedStyle = shapeFactory.getSelectedCfg(shapeName, cfg);
      Util.mix(selectedStyle, cfg.style); // 鐢ㄦ埛璁剧疆鐨勪紭鍏堢骇鏇撮珮

      if (!shape.get('_originAttrs')) {
        // 缂撳瓨鍘熸湁灞炴€�
        if (shape.get('animating')) {
          // 鍋滄鍔ㄧ敾
          shape.stopAnimate();
        }

        shape.set('_originAttrs', getOriginAttrs(selectedStyle, shape));
      } // 閫変腑鏃跺浘褰㈣鍒版渶涓婇潰


      if (selectedOptions.toFront) {
        ZIndexUtil.toFront(shape);
      }

      if (animate) {
        shape.animate(selectedStyle, 300);
      } else {
        shape.attr(selectedStyle);
        canvas.draw();
      }
    } else {
      var originAttrs = shape.get('_originAttrs'); // 鍙栨秷閫変腑鏃讹紝瑕佹仮澶嶅埌鍘熷厛鐨勪綅缃�

      if (selectedOptions.toFront) {
        ZIndexUtil.resetZIndex(shape);
      }

      shape.set('_originAttrs', null);

      if (animate) {
        shape.animate(originAttrs, 300);
      } else {
        shape.attr(originAttrs);
        canvas.draw();
      }
    }
  },
  setShapeSelected: function setShapeSelected(shape) {
    var self = this;

    var selectedShapes = self._getSelectedShapes();

    var selectedOptions = self.get('selectedOptions') || {};
    var cancelable = selectedOptions.cancelable !== false; // 閫変腑鐘舵€佹槸鍚﹀厑璁稿彇娑堬紝榛樿鍏佽

    if (selectedOptions.mode === 'multiple') {
      // 鏀寔澶氶€�
      if (Util.indexOf(selectedShapes, shape) === -1) {
        selectedShapes.push(shape);

        self._setShapeStatus(shape, true);
      } else if (cancelable) {
        // 鍥惧舰宸茬粡琚€変腑骞朵笖閫変腑鐘舵€佸厑璁稿彇娑堥€変腑
        Util.Array.remove(selectedShapes, shape);

        self._setShapeStatus(shape, false);
      }
    } else {
      var selectedShape = selectedShapes[0];

      if (cancelable) {
        // 濡傛灉鍏佽鍙栨秷锛屽垯閫変腑null
        shape = isSameShape(selectedShape, shape) ? null : shape;
      }

      if (!isSameShape(selectedShape, shape)) {
        if (selectedShape) {
          self._setShapeStatus(selectedShape, false);
        }

        if (shape) {
          self._setShapeStatus(shape, true);
        }
      }
    }
  },
  clearSelected: function clearSelected() {
    var self = this;
    var shapeContainer = self.get('shapeContainer');

    if (shapeContainer && !shapeContainer.get('destroyed')) {
      var selectedShapes = self._getSelectedShapes();

      Util.each(selectedShapes, function (shape) {
        self._setShapeStatus(shape, false);

        shape.set('_originAttrs', null);
      });
    }
  },

  /**
   * 璁剧疆璁板綍瀵瑰簲鐨勫浘褰㈤€変腑
   * @param {Object} record 閫変腑鐨勮褰�
   * @chainable
   * @return {Geom} 杩斿洖褰撳墠鐨� Geometry
   */
  setSelected: function setSelected(record) {
    var self = this;
    var shapes = self.getShapes();
    Util.each(shapes, function (shape) {
      var origin = shape.get('origin');

      if (origin && origin[FIELD_ORIGIN] === record) {
        self.setShapeSelected(shape);
      }
    });
    return this;
  },
  _getSelectedShapes: function _getSelectedShapes() {
    var self = this;
    var shapes = self.getShapes();
    var selectedShapes = [];
    Util.each(shapes, function (shape) {
      if (shape.get('selected')) {
        selectedShapes.push(shape);
      }
    });
    self.set('selectedShapes', selectedShapes);
    return selectedShapes;
  }
};
module.exports = SelectMixin;

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The tooltip handler
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var _require = __webpack_require__(5),
    defaultColor = _require.defaultColor;

var FIELD_ORIGIN = '_origin';

function getScaleName(scale) {
  return scale.alias || scale.field;
}

var TooltipMixin = {
  _getIntervalSize: function _getIntervalSize(obj) {
    var size = null;
    var type = this.get('type');
    var coord = this.get('coord');

    if (coord.isRect && (type === 'interval' || type === 'schema')) {
      size = this.getSize(obj[FIELD_ORIGIN]); // 濡傛灉瀛楁鍙戠敓浜嗘槧灏勶紝瀹藉害璁＄畻灏变細鎶ラ敊

      var dim = coord.isTransposed ? 'y' : 'x';

      if (Util.isArray(obj[dim])) {
        var width = Math.abs(obj[dim][1] - obj[dim][0]);
        size = size < width ? null : size; // 鐩存柟鍥捐绠楅敊璇�
      }
    }

    return size;
  },
  _snapEqual: function _snapEqual(v1, v2, scale) {
    var equals;
    v1 = scale.translate(v1);
    v2 = scale.translate(v2);

    if (scale.isCategory) {
      equals = v1 === v2;
    } else {
      equals = Util.snapEqual(v1, v2);
    }

    return equals;
  },
  _getScaleValueByPoint: function _getScaleValueByPoint(point) {
    var result = 0;
    var coord = this.get('coord');
    var xScale = this.getXScale();
    var invertPoint = coord.invert(point);
    var xValue = invertPoint.x;

    if (this.isInCircle() && xValue > (1 + xScale.rangeMax()) / 2) {
      xValue = xScale.rangeMin(); // 鏋佸潗鏍囦笅锛宻cale 鐨� range 琚仛杩囩壒娈婂鐞� see view.js#L88
    }

    result = xScale.invert(xValue);

    if (xScale.isCategory) {
      result = xScale.translate(result); // 闃叉鍒嗙被绫诲瀷
    }

    return result;
  },
  _getOriginByPoint: function _getOriginByPoint(point) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field;
    var yField = yScale.field;
    var coord = this.get('coord');
    var invertPoint = coord.invert(point);
    var xValue = xScale.invert(invertPoint.x);
    var yValue = yScale.invert(invertPoint.y);
    var result = {};
    result[xField] = xValue;
    result[yField] = yValue;
    return result;
  },
  _getScale: function _getScale(field) {
    var self = this;
    var scales = self.get('scales');
    var rst = null;
    Util.each(scales, function (scale) {
      if (scale.field === field) {
        rst = scale;
        return false;
      }
    });
    return rst;
  },
  // 鑾峰彇鍊煎搴旂殑搴﹂噺
  _getTipValueScale: function _getTipValueScale() {
    var attrs = this.getAttrsForLegend();
    var scale;
    Util.each(attrs, function (attr) {
      var tmpScale = attr.getScale(attr.type);

      if (tmpScale.isLinear) {
        // 濡傛灉鎸囧畾瀛楁鏄潪position鐨勶紝鍚屾椂鏄繛缁殑
        scale = tmpScale;
        return false;
      }
    });
    var xScale = this.getXScale();
    var yScale = this.getYScale();

    if (!scale && yScale && yScale.field === '..y') {
      return xScale;
    }

    return scale || yScale || xScale;
  },
  _getTipTitleScale: function _getTipTitleScale(titleField) {
    var self = this;

    if (titleField) {
      return self._getScale(titleField);
    }

    var position = self.getAttr('position');
    var fields = position.getFields();
    var tmpField;
    Util.each(fields, function (field) {
      if (!field.includes('..')) {
        tmpField = field;
        return false;
      }
    });
    return self._getScale(tmpField);
  },
  _filterValue: function _filterValue(arr, point) {
    var coord = this.get('coord');
    var yScale = this.getYScale();
    var yField = yScale.field;
    var invertPoint = coord.invert(point);
    var yValue = invertPoint.y;
    yValue = yScale.invert(yValue);
    var rst = arr[arr.length - 1];
    Util.each(arr, function (obj) {
      var origin = obj[FIELD_ORIGIN];

      if (origin[yField][0] <= yValue && origin[yField][1] >= yValue) {
        rst = obj;
        return false;
      }
    });
    return rst;
  },
  getXDistance: function getXDistance() {
    var self = this;
    var distance = self.get('xDistance');

    if (!distance) {
      var xScale = self.getXScale();

      if (xScale.isCategory) {
        distance = 1;
      } else {
        var values = xScale.values; // values 鏄棤搴忕殑

        var min = xScale.translate(values[0]);
        var max = min;
        Util.each(values, function (value) {
          // 鏃堕棿绫诲瀷闇€瑕� translate
          value = xScale.translate(value);

          if (value < min) {
            min = value;
          }

          if (value > max) {
            max = value;
          }
        });
        var length = values.length; // 搴旇鏄櫎浠� length - 1

        distance = (max - min) / (length - 1);
      }

      self.set('xDistance', distance);
    }

    return distance;
  },
  findPoint: function findPoint(point, dataArray) {
    var self = this;
    var type = self.get('type');
    var xScale = self.getXScale();
    var yScale = self.getYScale();
    var xField = xScale.field;
    var yField = yScale.field;
    var rst = null;

    if (Util.indexOf(['heatmap', 'point'], type) > -1) {
      var coord = self.get('coord');
      var invertPoint = coord.invert(point);
      var xValue = xScale.invert(invertPoint.x);
      var yValue = yScale.invert(invertPoint.y);
      var min = Infinity;
      Util.each(dataArray, function (obj) {
        var distance = Math.pow(obj[FIELD_ORIGIN][xField] - xValue, 2) + Math.pow(obj[FIELD_ORIGIN][yField] - yValue, 2);

        if (distance < min) {
          min = distance;
          rst = obj;
        }
      });
      return rst;
    }

    var first = dataArray[0];
    var last = dataArray[dataArray.length - 1];

    if (!first) {
      return rst;
    }

    var value = self._getScaleValueByPoint(point); // 鏍规嵁璇ョ偣鑾峰緱瀵瑰簲搴﹂噺鍚庢暟鎹殑鍊�


    var firstXValue = first[FIELD_ORIGIN][xField];
    var firstYValue = first[FIELD_ORIGIN][yField];
    var lastXValue = last[FIELD_ORIGIN][xField];
    var isYRange = yScale.isLinear && Util.isArray(firstYValue); // 鑰冭檻 x 缁村害鐩稿悓锛寉 鏄暟缁勫尯闂寸殑鎯呭喌
    // 濡傛灉x鐨勫€兼槸鏁扮粍

    if (Util.isArray(firstXValue)) {
      Util.each(dataArray, function (record) {
        var origin = record[FIELD_ORIGIN];

        if (xScale.translate(origin[xField][0]) <= value && xScale.translate(origin[xField][1]) >= value) {
          if (isYRange) {
            if (!Util.isArray(rst)) {
              rst = [];
            }

            rst.push(record);
          } else {
            rst = record;
            return false;
          }
        }
      });

      if (Util.isArray(rst)) {
        rst = this._filterValue(rst, point);
      }
    } else {
      var next;

      if (!xScale.isLinear && xScale.type !== 'timeCat') {
        Util.each(dataArray, function (record, index) {
          var origin = record[FIELD_ORIGIN];

          if (self._snapEqual(origin[xField], value, xScale)) {
            if (isYRange) {
              if (!Util.isArray(rst)) {
                rst = [];
              }

              rst.push(record);
            } else {
              rst = record;
              return false;
            }
          } else if (xScale.translate(origin[xField]) <= value) {
            last = record;
            next = dataArray[index + 1];
          }
        });

        if (Util.isArray(rst)) {
          rst = this._filterValue(rst, point);
        }
      } else {
        if ((value > xScale.translate(lastXValue) || value < xScale.translate(firstXValue)) && (value > xScale.max || value < xScale.min)) {
          return null;
        }

        var firstIdx = 0;
        var lastIdx = dataArray.length - 1;
        var middleIdx;

        while (firstIdx <= lastIdx) {
          middleIdx = Math.floor((firstIdx + lastIdx) / 2);
          var item = dataArray[middleIdx][FIELD_ORIGIN][xField];

          if (self._snapEqual(item, value, xScale)) {
            return dataArray[middleIdx];
          }

          if (xScale.translate(item) <= xScale.translate(value)) {
            firstIdx = middleIdx + 1;
            last = dataArray[middleIdx];
            next = dataArray[middleIdx + 1];
          } else {
            if (lastIdx === 0) {
              last = dataArray[0];
            }

            lastIdx = middleIdx - 1;
          }
        }
      }

      if (last && next) {
        // 璁＄畻鏈€閫艰繎鐨�
        if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - value)) {
          last = next;
        }
      }
    }

    var distance = self.getXDistance(); // 姣忎釜鍒嗙被闂寸殑骞冲潎闂磋窛

    if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) <= distance / 2) {
      rst = last;
    }

    return rst;
  },

  /**
   * @protected
   * 鑾峰彇tooltip鐨勬爣棰�
   * @param  {Object} origin 鐐圭殑鍘熷淇℃伅
   * @param  {String} titleField 鏍囬鐨勫瓧娈�
   * @return {String} 鎻愮ず淇℃伅鐨勬爣棰�
   */
  getTipTitle: function getTipTitle(origin, titleField) {
    var tipTitle = '';

    var titleScale = this._getTipTitleScale(titleField);

    if (titleScale) {
      var value = origin[titleScale.field];
      tipTitle = titleScale.getText(value);
    } else if (this.get('type') === 'heatmap') {
      // 鐑姏鍥惧湪涓嶅瓨鍦� title 鐨勬椂鍊欑壒娈婂鐞�
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xValue = xScale.getText(origin[xScale.field]);
      var yValue = yScale.getText(origin[yScale.field]);
      tipTitle = '( ' + xValue + ', ' + yValue + ' )';
    }

    return tipTitle;
  },
  getTipValue: function getTipValue(origin, valueScale) {
    var value;
    var field = valueScale.field;
    var key = origin.key;
    value = origin[field];

    if (Util.isArray(value)) {
      var tmp = [];
      Util.each(value, function (sub) {
        tmp.push(valueScale.getText(sub));
      });
      value = tmp.join('-');
    } else {
      value = valueScale.getText(value, key);
    }

    return value;
  },

  /**
   * @protected
   * 鑾峰彇tooltip鐨勫悕绉�
   * @param  {Object} origin 鐐圭殑鍘熷淇℃伅
   * @return {String} 鎻愮ず淇℃伅鐨勫悕绉�
   */
  getTipName: function getTipName(origin) {
    var name;
    var nameScale;

    var groupScales = this._getGroupScales();

    if (groupScales.length) {
      // 濡傛灉瀛樺湪鍒嗙粍绫诲瀷锛屽彇绗竴涓垎缁勭被鍨�
      Util.each(groupScales, function (scale) {
        nameScale = scale;
        return false;
      });
    }

    if (nameScale) {
      var field = nameScale.field;
      name = nameScale.getText(origin[field]);
    } else {
      var valueScale = this._getTipValueScale();

      name = getScaleName(valueScale);
    }

    return name;
  },

  /**
   * 鑾峰彇鐐瑰搴攖ooltip鐨勪俊鎭�
   * @protected
   * @param  {Object} point 鍘熷鐨勬暟鎹褰�
   * @param  {String} titleField tooltipTitle 閰嶇疆淇℃伅
   * @return {Array}  涓€鏉℃垨鑰呭鏉¤褰�
   */
  getTipItems: function getTipItems(point, titleField) {
    var self = this;
    var origin = point[FIELD_ORIGIN];
    var tipTitle = self.getTipTitle(origin, titleField);
    var tooltipCfg = self.get('tooltipCfg');
    var items = [];
    var name;
    var value;

    function addItem(itemName, itemValue, cfg) {
      if (!Util.isNil(itemValue) && itemValue !== '') {
        // 鍊间负null鐨勬椂鍊欙紝蹇借
        var item = {
          title: tipTitle,
          point: point,
          name: itemName || tipTitle,
          value: itemValue,
          color: point.color || defaultColor,
          marker: true
        };
        item.size = self._getIntervalSize(point);
        items.push(Util.mix({}, item, cfg));
      }
    }

    if (tooltipCfg) {
      var fields = tooltipCfg.fields;
      var cfg = tooltipCfg.cfg;
      var callbackParams = [];
      Util.each(fields, function (field) {
        callbackParams.push(origin[field]);
      });

      if (cfg) {
        // 瀛樺湪鍥炶皟鍑芥暟
        if (Util.isFunction(cfg)) {
          cfg = cfg.apply(null, callbackParams);
        }

        var itemCfg = Util.mix({}, {
          point: point,
          title: tipTitle,
          color: point.color || defaultColor,
          marker: true // 榛樿灞曠ず marker

        }, cfg);
        itemCfg.size = self._getIntervalSize(point);
        items.push(itemCfg);
      } else {
        Util.each(fields, function (field) {
          if (!Util.isNil(origin[field])) {
            // 瀛楁鏁版嵁涓簄ull ,undefined鏃朵笉鏄剧ず
            var scale = self._getScale(field);

            name = getScaleName(scale);
            value = scale.getText(origin[field]);
            addItem(name, value);
          }
        });
      }
    } else {
      var valueScale = self._getTipValueScale();

      if (!Util.isNil(origin[valueScale.field])) {
        // 瀛楁鏁版嵁涓簄ull ,undefined鏃朵笉鏄剧ず
        value = self.getTipValue(origin, valueScale);
        name = self.getTipName(origin);
        addItem(name, value);
      }
    }

    return items;
  },
  isShareTooltip: function isShareTooltip() {
    var shareTooltip = this.get('shareTooltip');
    var type = this.get('type');
    var view = this.get('view');
    var options;

    if (view.get('parent')) {
      options = view.get('parent').get('options');
    } else {
      options = view.get('options');
    }

    if (type === 'interval') {
      var coord = this.get('coord');
      var coordType = coord.type;

      if (coordType === 'theta' || coordType === 'polar' && coord.isTransposed) {
        shareTooltip = false;
      }
    } else if (!this.getYScale() || Util.inArray(['contour', 'point', 'polygon', 'edge'], type)) {
      shareTooltip = false;
    }

    if (options.tooltip && Util.isBoolean(options.tooltip.shared)) {
      // 浠ョ敤鎴疯缃殑涓哄噯
      shareTooltip = options.tooltip.shared;
    }

    return shareTooltip;
  }
};
module.exports = TooltipMixin;

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 鐐瑰浘
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

__webpack_require__(308);

var Point = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Point, _GeomBase);

  function Point() {
    return _GeomBase.apply(this, arguments) || this;
  }

  var _proto = Point.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'point';
    cfg.shapeType = 'point';
    cfg.generatePoints = true;
    return cfg;
  };

  _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {
    var self = this;
    var shape = obj.shape;
    var cfg = self.getDrawCfg(obj);

    self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);

    var geomShape;

    if (Util.isArray(obj.y)) {
      var hasAdjust = self.hasStack();
      Util.each(obj.y, function (y, idx) {
        cfg.y = y;
        cfg.yIndex = idx;

        if (!hasAdjust || idx !== 0) {
          geomShape = shapeFactory.drawShape(shape, cfg, container);
          self.appendShapeInfo(geomShape, index + idx);
        }
      });
    } else if (!Util.isNil(obj.y)) {
      geomShape = shapeFactory.drawShape(shape, cfg, container);
      self.appendShapeInfo(geomShape, index);
    }
  };

  return Point;
}(GeomBase);

var PointJitter = /*#__PURE__*/function (_Point) {
  _inheritsLoose(PointJitter, _Point);

  function PointJitter() {
    return _Point.apply(this, arguments) || this;
  }

  var _proto2 = PointJitter.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Point.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'jitter'
    }];
    return cfg;
  };

  return PointJitter;
}(Point);

var PointStack = /*#__PURE__*/function (_Point2) {
  _inheritsLoose(PointStack, _Point2);

  function PointStack() {
    return _Point2.apply(this, arguments) || this;
  }

  var _proto3 = PointStack.prototype;

  _proto3.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Point2.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'stack'
    }];
    return cfg;
  };

  return PointStack;
}(Point);

Point.Jitter = PointJitter;
Point.Stack = PointStack;
GeomBase.Point = Point;
GeomBase.PointJitter = PointJitter;
GeomBase.PointStack = PointStack;
module.exports = Point;

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 澶氳竟褰�
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

__webpack_require__(309);

var Polygon = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Polygon, _GeomBase);

  function Polygon() {
    return _GeomBase.apply(this, arguments) || this;
  }

  var _proto = Polygon.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'polygon';
    cfg.shapeType = 'polygon';
    cfg.generatePoints = true;
    return cfg;
  };

  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

    var self = this;
    var x = cfg.x;
    var y = cfg.y;
    var temp;

    if (!(Util.isArray(x) && Util.isArray(y))) {
      // x y 閮芥槸鏁扮粍鏃讹紝涓嶅仛澶勭悊
      var xScale = self.getXScale();
      var yScale = self.getYScale();
      var xCount = xScale.values ? xScale.values.length : xScale.ticks.length;
      var yCount = yScale.values ? yScale.values.length : yScale.ticks.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;

      if (xScale.isCategory && yScale.isCategory) {
        // 濡傛灉x,y閮芥槸鍒嗙被
        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
      } else if (Util.isArray(x)) {
        // x 鏄暟缁�
        temp = x;
        x = [temp[0], temp[0], temp[1], temp[1]];
        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
      } else if (Util.isArray(y)) {
        // y 鏄暟缁�
        temp = y;
        y = [temp[0], temp[1], temp[1], temp[0]];
        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
      }

      cfg.x = x;
      cfg.y = y;
    }

    return cfg;
  };

  return Polygon;
}(GeomBase);

GeomBase.Polygon = Polygon;
module.exports = Polygon;

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 鑷畾涔夊浘褰�
 * @author dxq613@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

var SizeMixin = __webpack_require__(70);

__webpack_require__(310);

var Schema = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Schema, _GeomBase);

  var _proto = Schema.prototype;

  /**
   * 鑾峰彇榛樿鐨勯厤缃睘鎬�
   * @protected
   * @return {Object} 榛樿灞炴€�
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'schema';
    cfg.shapeType = 'schema';
    cfg.generatePoints = true;
    return cfg;
  };

  function Schema(cfg) {
    var _this;

    _this = _GeomBase.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), SizeMixin);
    return _this;
  }

  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

    cfg.size = this.getNormalizedSize(obj);
    return cfg;
  };

  _proto.clearInner = function clearInner() {
    _GeomBase.prototype.clearInner.call(this);

    this.set('defaultSize', null);
  };

  return Schema;
}(GeomBase);

var SchemaDodge = /*#__PURE__*/function (_Schema) {
  _inheritsLoose(SchemaDodge, _Schema);

  function SchemaDodge() {
    return _Schema.apply(this, arguments) || this;
  }

  var _proto2 = SchemaDodge.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Schema.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'dodge'
    }];
    return cfg;
  };

  return SchemaDodge;
}(Schema);

Schema.Dodge = SchemaDodge;
GeomBase.Schema = Schema;
GeomBase.SchemaDodge = SchemaDodge;
module.exports = Schema;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview area shape
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var PathUtil = __webpack_require__(25);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

function getLineAttrs(cfg) {
  var defaultAttrs = Global.shape.hollowArea;
  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

  if (Util.isNumber(cfg.size)) {
    lineAttrs.lineWidth = cfg.size;
  }

  return lineAttrs;
}

function getFillAttrs(cfg) {
  var defaultAttrs = Global.shape.area;
  var areaAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addFillAttrs(areaAttrs, cfg);

  if (cfg.color) {
    areaAttrs.stroke = areaAttrs.stroke || cfg.color;
  }

  if (Util.isNumber(cfg.size)) {
    areaAttrs.lineWidth = cfg.size;
  }

  return areaAttrs;
}

function getPath(cfg, smooth, shape) {
  var path = [];
  var pointsArr = [];
  var topLinePoints = []; // area 鍖哄煙涓婇儴鍒�

  var bottomLinePoints = []; // area 鍖哄煙涓嬮儴鍒�

  var isInCircle = cfg.isInCircle;
  Util.each(cfg.points, function (point) {
    topLinePoints.push(point[1]);
    bottomLinePoints.push(point[0]);
  }); // if (!isInCircle) {

  bottomLinePoints = bottomLinePoints.reverse(); // }

  pointsArr.push(topLinePoints, bottomLinePoints);
  Util.each(pointsArr, function (points, index) {
    var subPath = [];
    points = shape.parsePoints(points);
    var p1 = points[0];

    if (isInCircle) {
      points.push({
        x: p1.x,
        y: p1.y
      });
    }

    if (smooth) {
      subPath = PathUtil.getSplinePath(points, false, cfg.constraint);
    } else {
      subPath = PathUtil.getLinePath(points, false);
    }

    if (index > 0) {
      subPath[0][0] = 'L';
    }

    path = path.concat(subPath);
  });
  path.push(['Z']);
  return path;
} // get marker cfg


function _getMarkerCfg(cfg) {
  return {
    symbol: function symbol(x, y, r) {
      return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
    },
    radius: 5,
    fill: cfg.color,
    fillOpacity: 0.6
  };
} // 榧犳爣鎮诞瑙﹀彂active鐘舵€�


function _getActiveCfg(type, cfg) {
  if (type === 'line' || type === 'smoothLine') {
    // 绾垮姞绮�
    var lineWidth = cfg.lineWidth || 0;
    return {
      lineWidth: lineWidth + 1
    };
  }

  var opacity = cfg.fillOpacity || cfg.opacity || 1;
  return {
    fillOpacity: opacity - 0.15,
    strokeOpacity: opacity - 0.15
  };
} // 褰撳彧鏈変竴涓暟鎹椂缁樺埗鐐�


function drawPointShape(shapeObj, cfg, container) {
  var coord = shapeObj._coord;
  var point = coord.convertPoint(cfg.points[0][1]);
  return container.addShape('circle', {
    attrs: Util.mix({
      x: point.x,
      y: point.y,
      r: 2,
      fill: cfg.color
    }, cfg.style)
  });
}

var Area = Shape.registerFactory('area', {
  defaultShapeType: 'area',

  /**
   * @override
   * @protected
   * 璁＄畻鐐� 濡傛灉瀛樺湪澶氫釜鐐癸紝鍒嗗壊鎴愬崟涓殑鐐�, 涓嶈€冭檻澶氫釜x瀵瑰簲涓€涓獃鐨勬儏鍐�
   * 鍗曠偣鍒欒ˉ涓妝0鐐�
   */
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    var points = [];
    var x = pointInfo.x;
    var y = pointInfo.y;
    var y0 = pointInfo.y0;
    y = Util.isArray(y) ? y : [y0, y];
    Util.each(y, function (yItem) {
      points.push({
        x: x,
        y: yItem
      });
    });
    return points;
  },
  // 鑾峰彇婵€娲荤殑鍥惧舰灞炴€�
  getActiveCfg: function getActiveCfg(type, cfg) {
    return _getActiveCfg(type, cfg);
  },
  drawShape: function drawShape(type, cfg, container) {
    var shape = this.getShape(type);
    var gShape;

    if (cfg.points.length === 1 && Global.showSinglePoint) {
      gShape = drawPointShape(this, cfg, container);
    } else {
      gShape = shape.draw(cfg, container);
    }

    if (gShape) {
      gShape.set('origin', cfg.origin);
      gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;
      gShape.name = this.name;
    }

    return gShape;
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    if (cfg && cfg.style) {
      return cfg.style;
    }

    return this.getActiveCfg(type, cfg);
  }
}); // 榛樿锛氬～鍏呭尯鍩熷浘

Shape.registerShape('area', 'area', {
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var path = getPath(cfg, false, this); // path = this.parsePath(path, false);

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg);
  }
}); // 濉厖骞虫粦鍖哄煙鍥�

Shape.registerShape('area', 'smooth', {
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var coord = this._coord; // 鏇茬嚎鐨勯檺鍒�

    cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];
    var path = getPath(cfg, true, this); // path = this.parsePath(path, false);

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg);
  }
}); // 灏侀棴鐨勬姌绾�

Shape.registerShape('area', 'line', {
  draw: function draw(cfg, container) {
    var attrs = getLineAttrs(cfg);
    var path = getPath(cfg, false, this); // path = this.parsePath(path, false);

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg);
  }
}); // 灏侀棴鐨勫钩婊戠嚎

Shape.registerShape('area', 'smoothLine', {
  draw: function draw(cfg, container) {
    var attrs = getLineAttrs(cfg);
    var path = getPath(cfg, true, this);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg);
  }
});
Area.spline = Area.smooth;
module.exports = Area;

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 杈圭殑 shape
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

var PathUtil = __webpack_require__(25);

var CORNER_PERCENT = 1 / 3;

function getAttrs(cfg) {
  var defaultCfg = Global.shape.edge;
  var lineAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

  if (cfg.size) {
    lineAttrs.lineWidth = cfg.size;
  }

  return lineAttrs;
}

var Edge = Shape.registerFactory('edge', {
  defaultShapeType: 'line',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return ShapeUtil.splitPoints(pointInfo);
  },
  getActiveCfg: function getActiveCfg(type, cfg) {
    var lineWidth = cfg.lineWidth || 0;
    return {
      lineWidth: lineWidth + 1
    };
  }
});

function getCPath(from, to) {
  var points = [];
  points.push({
    x: from.x,
    y: from.y * (1 - 1 / 2) + to.y * 1 / 2
  });
  points.push({
    y: from.y * (1 - 1 / 2) + to.y * 1 / 2,
    x: to.x
  });
  points.push(to);
  var sub = ['C'];
  Util.each(points, function (point) {
    sub.push(point.x, point.y);
  });
  return sub;
}

function getQPath(to, center) {
  var points = [];
  points.push({
    x: center.x,
    y: center.y
  });
  points.push(to);
  var sub = ['Q'];
  Util.each(points, function (point) {
    sub.push(point.x, point.y);
  });
  return sub;
}

function createSmoothPath(from, to) {
  var sub = getCPath(from, to);
  var path = [['M', from.x, from.y]];
  path.push(sub);
  return path;
}

function createArcPath(from, to, center) {
  var sub = getQPath(to, center);
  var path = [['M', from.x, from.y]];
  path.push(sub);
  return path;
}

function createArcWeightPath(points, center) {
  var arc1 = getQPath(points[1], center);
  var arc2 = getQPath(points[3], center);
  var path = [['M', points[0].x, points[0].y]];
  path.push(arc2);
  path.push(['L', points[3].x, points[3].y]);
  path.push(['L', points[2].x, points[2].y]);
  path.push(arc1);
  path.push(['L', points[1].x, points[1].y]);
  path.push(['L', points[0].x, points[0].y]);
  path.push(['Z']);
  return path;
}

function createRectPath(from, to) {
  var points = [];
  points.push({
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
    x: from.x
  });
  points.push({
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
    x: to.x
  });
  points.push(to);
  var path = [['M', from.x, from.y]];
  Util.each(points, function (point) {
    path.push(['L', point.x, point.y]);
  });
  return path;
}

Shape.registerShape('edge', 'line', {
  draw: function draw(cfg, container) {
    var points = this.parsePoints(cfg.points);
    var attrCfg = getAttrs(cfg);
    var path = PathUtil.getLinePath(points);
    var line = container.addShape('path', {
      attrs: Util.mix(attrCfg, {
        path: path
      })
    });
    return line;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4.5
    }, getAttrs(cfg));
  }
});
Shape.registerShape('edge', 'vhv', {
  draw: function draw(cfg, container) {
    var points = cfg.points;
    var attrCfg = getAttrs(cfg);
    var path = createRectPath(points[0], points[1]);
    path = this.parsePath(path);
    var line = container.addShape('path', {
      attrs: Util.mix(attrCfg, {
        path: path
      })
    });
    return line;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4.5
    }, getAttrs(cfg));
  }
});
Shape.registerShape('edge', 'smooth', {
  draw: function draw(cfg, container) {
    var points = cfg.points;
    var attrCfg = getAttrs(cfg);
    var path = createSmoothPath(points[0], points[1]);
    path = this.parsePath(path);
    var line = container.addShape('path', {
      attrs: Util.mix(attrCfg, {
        path: path
      })
    });
    return line;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4.5
    }, getAttrs(cfg));
  }
}); //  寮х嚎鍖呮嫭绗涘崱灏斿潗鏍囩郴涓嬬殑鍗婂渾寮х嚎銆佹瀬鍧愭爣绯讳笅浠ュ渾蹇冧负鎺у埗鐐圭殑浜岄樁鏇茬嚎銆佺瑳鍗″皵鍧愭爣绯讳笅甯︽潈閲嶇殑涓夐樁鏇茬嚎銆佹瀬鍧愭爣绯讳笅甯︽潈閲嶇殑浠ュ渾蹇冧负鎺у埗鐐圭殑浜岄樁鏇茬嚎

Shape.registerShape('edge', 'arc', {
  draw: function draw(cfg, container) {
    var points = cfg.points;
    var type = points.length > 2 ? 'weight' : 'normal';
    var attrCfg = getAttrs(cfg);
    var line;
    var path;

    if (cfg.isInCircle) {
      var center = {
        x: 0,
        y: 1
      };

      if (type === 'normal') {
        path = createArcPath(points[0], points[1], center);
      } else {
        attrCfg.fill = attrCfg.stroke;
        path = createArcWeightPath(points, center);
      }

      path = this.parsePath(path);
      line = container.addShape('path', {
        attrs: Util.mix(attrCfg, {
          path: path
        })
      });
    } else {
      if (type === 'normal') {
        points = this.parsePoints(points);
        line = container.addShape('arc', {
          attrs: Util.mix(attrCfg, {
            x: (points[1].x + points[0].x) / 2,
            y: points[0].y,
            r: Math.abs(points[1].x - points[0].x) / 2,
            startAngle: Math.PI,
            endAngle: Math.PI * 2
          })
        });
      } else {
        path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y]];
        var c1 = getCPath(points[1], points[3]);
        var c2 = getCPath(points[2], points[0]);
        path.push(c1);
        path.push(['L', points[3].x, points[3].y]);
        path.push(['L', points[2].x, points[2].y]);
        path.push(c2);
        path.push(['Z']);
        path = this.parsePath(path);
        attrCfg.fill = attrCfg.stroke;
        line = container.addShape('path', {
          attrs: Util.mix(attrCfg, {
            path: path
          })
        });
      }
    }

    return line;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4.5
    }, getAttrs(cfg));
  }
});
module.exports = Edge;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview interval shapes
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 * @author huangtonger@aliyun.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var PathUtil = __webpack_require__(25);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

var G = __webpack_require__(16);

var GPathUtil = Util.PathUtil; // 鑾峰彇鏌辩姸鍥剧殑鍑犱釜鐐�

function getRectPoints(cfg, isPyramid) {
  var x = cfg.x;
  var y = cfg.y;
  var y0 = cfg.y0; // 0 鐐圭殑浣嶇疆

  var width = cfg.size; // 鏈�3绉嶆儏鍐碉紝
  // 1. y锛寈閮戒笉鏄暟缁�
  // 2. y鏄暟缁勶紝x涓嶆槸
  // 3. x鏄暟缁勶紝y涓嶆槸

  var ymin = y0;
  var ymax = y;

  if (Util.isArray(y)) {
    ymax = y[1];
    ymin = y[0];
  }

  var xmin;
  var xmax;

  if (Util.isArray(x)) {
    xmin = x[0];
    xmax = x[1];
  } else {
    xmin = x - width / 2;
    xmax = x + width / 2;
  }

  var points = [];
  points.push({
    x: xmin,
    y: ymin
  }, {
    x: xmin,
    y: ymax
  });

  if (isPyramid) {
    points.push({
      x: xmax,
      y: (ymax + ymin) / 2
    });
  } else {
    points.push({
      x: xmax,
      y: ymax
    }, {
      x: xmax,
      y: ymin
    });
  }

  return points;
}

function getRectPath(points) {
  var path = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];

    if (point) {
      var action = i === 0 ? 'M' : 'L';
      path.push([action, point.x, point.y]);
    }
  }

  var first = points[0];
  path.push(['L', first.x, first.y]);
  path.push(['z']);
  return path;
}

function getLinePoints(cfg) {
  var x = cfg.x;
  var y = cfg.y;
  var y0 = cfg.y0; // 0 鐐圭殑浣嶇疆

  var points = [];

  if (Util.isArray(y)) {
    Util.each(y, function (yItem, idx) {
      points.push({
        x: Util.isArray(x) ? x[idx] : x,
        y: yItem
      });
    });
  } else {
    points.push({
      x: x,
      y: y
    }, {
      x: x,
      y: y0
    });
  }

  return points;
}

function getTickPoints(cfg) {
  var x = cfg.x;
  var y = Util.isArray(cfg.y) ? cfg.y[1] : cfg.y;
  var y0 = Util.isArray(cfg.y) ? cfg.y[0] : cfg.y0;
  var barWidth = cfg.size;
  var points = [];
  points.push({
    x: x - barWidth / 2,
    y: y
  }, {
    x: x + barWidth / 2,
    y: y
  }, {
    x: x,
    y: y
  }, {
    x: x,
    y: y0
  }, {
    x: x - barWidth / 2,
    y: y0
  }, {
    x: x + barWidth / 2,
    y: y0
  });
  return points;
}

function getTickPath(points) {
  var path = [];
  path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]);
  return path;
}

function getFillAttrs(cfg) {
  var defaultAttrs = Global.shape.interval;
  var attrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addFillAttrs(attrs, cfg);

  if (cfg.color) {
    attrs.stroke = attrs.stroke || cfg.color;
  }

  return attrs;
}

function getLineAttrs(cfg) {
  var defaultAttrs = Global.shape.hollowInterval;
  var attrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addStrokeAttrs(attrs, cfg);
  return attrs;
}

function getFunnelPath(cfg, isFunnel) {
  var path = [];
  var points = cfg.points;
  var nextPoints = cfg.nextPoints;

  if (!Util.isNil(nextPoints)) {
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);
  } else if (isFunnel) {
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);
  } else {
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);
  }

  return path;
}

function getThetaCfg(point, coord) {
  var r = coord.getRadius();
  var inner = coord.innerRadius;
  var startAngle;
  var endAngle;
  var ir = r * inner;
  var startPoint;
  var endPoint;

  if (!Util.isArray(point.x) && Util.isArray(point.y)) {
    point.x = [point.x, point.x]; // 濡傛灉x鏄竴涓€硷紝y鏄暟缁勶紝灏唜杞垚鏁扮粍
  }

  if (Util.isArray(point.x)) {
    startPoint = {
      x: point.x[0],
      y: point.y[0]
    };
    endPoint = {
      x: point.x[1],
      y: point.y[1]
    };
    startAngle = PathUtil.getPointAngle(coord, startPoint);
    endAngle = PathUtil.getPointAngle(coord, endPoint);

    if (endAngle <= startAngle) {
      // 鑰冭檻鍗犳瘮鐧惧垎鐧剧殑鎯呭舰
      endAngle = endAngle + Math.PI * 2;
    }
  } else {
    endPoint = point;
    startAngle = coord.startAngle;
    endAngle = PathUtil.getPointAngle(coord, endPoint);
  }

  return {
    r: r,
    ir: ir,
    startAngle: startAngle,
    endAngle: endAngle
  };
} // 鑾峰彇閫変腑鏃剁殑鏍峰紡锛屽綋鍓嶄粎鏀寔楗煎浘


function _getSelectedCfg(type, cfg) {
  var geom = cfg.geom;
  var coord = geom.get('coord');
  var point = cfg.point;
  var r = 7.5;
  var selectedCfg;

  if (coord && coord.type === 'theta') {
    var thetaCfg = getThetaCfg(point, coord);
    var middleAngle = (thetaCfg.endAngle - thetaCfg.startAngle) / 2 + thetaCfg.startAngle;
    var x = r * Math.cos(middleAngle);
    var y = r * Math.sin(middleAngle);
    selectedCfg = {
      transform: [['t', x, y]]
    };
  }

  return Util.mix({}, selectedCfg);
}

var Interval = Shape.registerFactory('interval', {
  defaultShapeType: 'rect',
  getActiveCfg: function getActiveCfg(type, cfg) {
    if (!type || Util.inArray(['rect', 'funnel', 'pyramid'], type)) {
      // 閫忔槑搴﹂檷浣� 0.15
      var fillOpacity = cfg.fillOpacity || cfg.opacity || 1;
      return {
        fillOpacity: fillOpacity - 0.15
      };
    }

    var lineWidth = cfg.lineWidth || 0;
    return {
      lineWidth: lineWidth + 1
    };
  },
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return getRectPoints(pointInfo);
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    return _getSelectedCfg(type, cfg);
  }
}); // 榛樿鏌辩姸鍥�

Shape.registerShape('interval', 'rect', {
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var path = getRectPath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var rectCfg = getFillAttrs(cfg);
    var isInCircle = cfg.isInCircle;
    return Util.mix({
      symbol: isInCircle ? 'circle' : 'square',
      radius: isInCircle ? 4.5 : 4
    }, rectCfg);
  }
}); // 绌哄績鏌辩姸鍥�

Shape.registerShape('interval', 'hollowRect', {
  draw: function draw(cfg, container) {
    var attrs = getLineAttrs(cfg);
    var path = getRectPath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var rectCfg = getLineAttrs(cfg);
    var isInCircle = cfg.isInCircle;
    return Util.mix({
      symbol: isInCircle ? 'circle' : 'square',
      radius: isInCircle ? 4.5 : 4
    }, rectCfg);
  }
}); // 绾垮舰鏌辩姸鍥�

Shape.registerShape('interval', 'line', {
  getPoints: function getPoints(pointInfo) {
    return getLinePoints(pointInfo);
  },
  draw: function draw(cfg, container) {
    var attrs = getLineAttrs(cfg);
    attrs.lineWidth = cfg.size || 1; // size 灏辨槸绾跨殑瀹藉害

    var path = getRectPath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var lineCfg = getLineAttrs(cfg);
    return Util.mix({
      symbol: 'line',
      radius: 5
    }, lineCfg);
  }
}); // 閽夊瓙褰㈢殑鏌辩姸鍥�

Shape.registerShape('interval', 'tick', {
  getPoints: function getPoints(pointInfo) {
    return getTickPoints(pointInfo);
  },
  draw: function draw(cfg, container) {
    var attrs = getLineAttrs(cfg); // @2018-12-25 by blue.lb 缁忚繃娴嬭瘯鍙戠幇size浠ｈ〃鐨勬槸瀹藉害锛岃€宻tyle涓殑lineWidth鎵嶆槸璁剧疆绾垮锛屾斁鍦╥nterval鏆傛椂鍏堢壒娈婂鐞�

    if (!attrs.lineWidth) {
      attrs.lineWidth = 2;
    }

    var path = getTickPath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var lineCfg = getLineAttrs(cfg);
    return Util.mix({
      symbol: 'tick',
      radius: 5
    }, lineCfg);
  }
}); // 婕忔枟鍥�

Shape.registerShape('interval', 'funnel', {
  getPoints: function getPoints(pointInfo) {
    pointInfo.size = pointInfo.size * 2; // 婕忔枟鍥剧殑 size 鏄煴鐘跺浘鐨勪袱鍊�

    return getRectPoints(pointInfo);
  },
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var path = getFunnelPath(cfg, true);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var funnelCfg = getFillAttrs(cfg);
    return Util.mix({
      symbol: 'square',
      radius: 4
    }, funnelCfg);
  }
}); // 閲戝瓧濉斿浘

Shape.registerShape('interval', 'pyramid', {
  getPoints: function getPoints(pointInfo) {
    pointInfo.size = pointInfo.size * 2; // 婕忔枟鍥剧殑 size 鏄煴鐘跺浘鐨勪袱鍊�

    return getRectPoints(pointInfo, true);
  },
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var path = getFunnelPath(cfg, false);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var funnelCfg = getFillAttrs(cfg);
    return Util.mix({
      symbol: 'square',
      radius: 4
    }, funnelCfg);
  }
}); // 姘存尝鍥�

/**
 * 鐢ㄨ礉濉炲皵鏇茬嚎妯℃嫙姝ｅ鸡娉�
 * Using Bezier curves to fit sine wave.
 * There is 4 control points for each curve of wave,
 * which is at 1/4 wave length of the sine wave.
 *
 * The control points for a wave from (a) to (d) are a-b-c-d:
 *          c *----* d
 *     b *
 *       |
 * ... a * ..................
 *
 * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
 *
 * @param {number} x          x position of the left-most point (a)
 * @param {number} stage      0-3, stating which part of the wave it is
 * @param {number} waveLength wave length of the sine wave
 * @param {number} amplitude  wave amplitude
 * @return {Array} 姝ｅ鸡鐗囨鏇茬嚎
 */

function getWaterWavePositions(x, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];
  } else if (stage === 1) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];
  } else if (stage === 2) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];
  }

  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];
}
/**
 * 鑾峰彇姘存尝璺緞
 * @param  {number} radius          鍗婂緞
 * @param  {number} waterLevel      姘翠綅
 * @param  {number} waveLength      娉㈤暱
 * @param  {number} phase           鐩镐綅
 * @param  {number} amplitude       闇囧箙
 * @param  {number} cx              鍦嗗績x
 * @param  {number} cy              鍦嗗績y
 * @return {Array}  path            璺緞
 * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
 */


function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 2;
  var path = []; // map phase to [-Math.PI * 2, 0]

  while (phase < -Math.PI * 2) {
    phase += Math.PI * 2;
  }

  while (phase > 0) {
    phase -= Math.PI * 2;
  }

  phase = phase / Math.PI / 2 * waveLength;
  var left = cx - radius + phase - radius * 2;
  /**
   * top-left corner as start point
   *
   * draws this point
   *  |
   * \|/
   *  ~~~~~~~~
   *  |      |
   *  +------+
   */

  path.push(['M', left, waterLevel]);
  /**
   * top wave
   *
   * ~~~~~~~~ <- draws this sine wave
   * |      |
   * +------+
   */

  var waveRight = 0;

  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);
    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);

    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  /**
   * top-right corner
   *
   *                       ~~~~~~~~
   * 3. draws this line -> |      | <- 1. draws this line
   *                       +------+
   *                          ^
   *                          |
   *                  2. draws this line
   */


  path.push(['L', waveRight + left, cy + radius]);
  path.push(['L', left, cy + radius]);
  path.push(['L', left, waterLevel]);
  return path;
}
/**
 * 娣诲姞姘存尝
 * @param {number} x           涓績x
 * @param {number} y           涓績y
 * @param {number} level       姘翠綅绛夌骇 0锝�1
 * @param {number} waveCount   姘存尝鏁�
 * @param {number} colors      鑹插€�
 * @param {number} group       鍥剧粍
 * @param {number} clip        鐢ㄤ簬鍓垏鐨勫浘褰�
 * @param {number} radius      缁樺埗鍥惧舰鐨勯珮搴�
 */


function addWaterWave(x, y, level, waveCount, colors, group, clip, radius) {
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;
  var duration = 5000;
  var delayDiff = 300;

  for (var i = 0; i < waveCount; i++) {
    var wave = group.addShape('path', {
      attrs: {
        path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / 64, x, y),
        fill: colors[i],
        clip: clip
      }
    }); // FIXME wave animation error in svg

    if (Global.renderer === 'canvas') {
      wave.animate({
        transform: [['t', width / 2, 0]],
        repeat: true
      }, duration - i * delayDiff);
    }
  }
}

Shape.registerShape('interval', 'liquid-fill-gauge', {
  draw: function draw(cfg, container) {
    var self = this;
    var cy = 0.5;
    var sumX = 0;
    var minX = Infinity;
    Util.each(cfg.points, function (p) {
      if (p.x < minX) {
        minX = p.x;
      }

      sumX += p.x;
    });
    var cx = sumX / cfg.points.length;
    var cp = self.parsePoint({
      x: cx,
      y: cy
    });
    var minP = self.parsePoint({
      x: minX,
      y: 0.5
    });
    var xWidth = cp.x - minP.x;
    var radius = Math.min(xWidth, minP.y);
    var attrs = getFillAttrs(cfg);
    var clipCircle = new G.Circle({
      attrs: {
        x: cp.x,
        y: cp.y,
        r: radius
      }
    });
    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, clipCircle, radius * 4);
    return container.addShape('circle', {
      attrs: Util.mix(getLineAttrs(cfg), {
        x: cp.x,
        y: cp.y,
        r: radius + radius / 8
      })
    });
  }
});
var pathMetaCache = {};
Shape.registerShape('interval', 'liquid-fill-path', {
  draw: function draw(cfg, container) {
    var self = this;
    var attrs = Util.mix({}, getFillAttrs(cfg));
    var path = cfg.shape[1];
    var cy = 0.5;
    var sumX = 0;
    var minX = Infinity;
    Util.each(cfg.points, function (p) {
      if (p.x < minX) {
        minX = p.x;
      }

      sumX += p.x;
    });
    var cx = sumX / cfg.points.length;
    var cp = self.parsePoint({
      x: cx,
      y: cy
    });
    var minP = self.parsePoint({
      x: minX,
      y: 0.5
    });
    var xWidth = cp.x - minP.x;
    var radius = Math.min(xWidth, minP.y);
    var pathMeta;

    if (pathMetaCache[path]) {
      pathMeta = pathMetaCache[path];
    } else {
      var segments = GPathUtil.parsePathString(path);
      pathMetaCache[path] = pathMeta = {
        segments: segments
      };
    }

    var transform = [];

    if (attrs.rotate) {
      transform.push(['r', attrs.rotate / 180 * Math.PI]);
      delete attrs.rotate;
    }

    var shape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        fillOpacity: 0,
        path: pathMeta.segments
      })
    });
    var bbox = Util.cloneDeep(shape.getBBox());
    var rangeX = bbox.maxX - bbox.minX;
    var rangeY = bbox.maxY - bbox.minY;
    var range = Math.max(rangeX, rangeY);
    var scale = radius * 2 / range;
    shape.transform(transform.concat([['s', scale, scale]]));
    var dw = scale * rangeX / 2; // (bbox.maxX - bbox.minX) / 2;

    var dh = scale * rangeY / 2; // (bbox.maxY - bbox.minY) / 2;

    shape.transform([['t', cp.x - dw, cp.y - dh]]);
    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, shape, minP.y * 4);
    var keyShape = container.addShape('path', {
      attrs: Util.mix(getLineAttrs(cfg), {
        path: pathMeta.segments
      })
    });
    keyShape.transform(transform.concat([['s', scale, scale], ['t', cp.x - dw, cp.y - dh]]));
    return keyShape;
  }
});
Shape.registerShape('interval', 'top-line', {
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var style = cfg.style || {};
    var linePath = [['M', cfg.points[1].x, cfg.points[1].y], ['L', cfg.points[2].x, cfg.points[2].y]];
    var lineAttrs = {
      stroke: style.stroke || 'white',
      lineWidth: style.lineWidth || 1,
      path: this.parsePath(linePath)
    };
    var path = getRectPath(cfg.points);
    path = this.parsePath(path);
    delete attrs.stroke; // 涓嶅湪鏌卞瓙涓婄粯鍒剁嚎

    var rectShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        zIndex: 0,
        path: path
      })
    });
    container.addShape('path', {
      zIndex: 1,
      attrs: lineAttrs
    });
    return rectShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var rectCfg = getFillAttrs(cfg);
    var isInCircle = cfg.isInCircle;
    return Util.mix({
      symbol: isInCircle ? 'circle' : 'square',
      radius: isInCircle ? 4.5 : 4
    }, rectCfg);
  }
});
module.exports = Interval;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview line shapes
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 * @author huangtonger@aliyun.com
 */
var Util = __webpack_require__(0);

var PathUtil = __webpack_require__(25);

var ShapeUtil = __webpack_require__(23);

var Shape = __webpack_require__(9);

var Global = __webpack_require__(5);

var DOT_ARR = [1, 1];
var DASH_ARR = [5.5, 1];

function getAttrs(cfg) {
  var defaultCfg = Global.shape.line;
  var lineAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);

  if (cfg.size) {
    lineAttrs.lineWidth = cfg.size;
  }

  return lineAttrs;
}

function getMarkerAttrs(cfg) {
  var defaultCfg = Global.shape.line;
  var lineAttrs = Util.mix({
    lineWidth: 2,
    radius: 6
  }, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);
  return lineAttrs;
} // 鑾峰彇甯︽湁涓婁笅鍖洪棿鐨� path


function getRangePath(points, smooth, isInCircle, cfg) {
  var topPoints = [];
  var isStack = cfg.isStack;
  var bottomPoints = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    var tmp = ShapeUtil.splitPoints(point);
    bottomPoints.push(tmp[0]);
    topPoints.push(tmp[1]);
  }

  var topPath = getSinglePath(topPoints, smooth, isInCircle, cfg);
  var bottomPath = getSinglePath(bottomPoints, smooth, isInCircle, cfg);

  if (isStack) {
    return topPath;
  }

  return topPath.concat(bottomPath);
} // 鍗曟潯 path


function getSinglePath(points, smooth, isInCircle, cfg) {
  var path;

  if (!smooth) {
    path = PathUtil.getLinePath(points, false);

    if (isInCircle) {
      path.push(['Z']);
    }
  } else {
    // 鐩磋鍧愭爣绯讳笅缁樺埗鏇茬嚎鏃堕檺鍒舵渶澶у€笺€佹渶灏忓€�
    var constraint = cfg.constraint;

    if (isInCircle && points.length) {
      points.push({
        x: points[0].x,
        y: points[0].y
      });
    }

    path = PathUtil.getSplinePath(points, false, constraint);
  }

  return path;
} // get line path


function getPath(cfg, smooth) {
  var path;
  var points = cfg.points;
  var isInCircle = cfg.isInCircle;
  var first = points[0];

  if (Util.isArray(first.y)) {
    path = getRangePath(points, smooth, isInCircle, cfg);
  } else {
    path = getSinglePath(points, smooth, isInCircle, cfg);
  }

  return path;
}

function _interpPoints(points, fn) {
  var tmpPoints = [];
  Util.each(points, function (point, index) {
    var nextPoint = points[index + 1];
    tmpPoints.push(point);

    if (nextPoint) {
      tmpPoints = tmpPoints.concat(fn(point, nextPoint));
    }
  });
  return tmpPoints;
} // 鎻掑€肩殑鍥惧舰path锛屼笉鑰冭檻null


function _getInterPath(points) {
  var path = [];
  Util.each(points, function (point, index) {
    var subPath = index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
    path.push(subPath);
  });
  return path;
} // 鎻掑€肩殑鍥惧舰


function _getInterPointShapeCfg(cfg, fn) {
  var points = _interpPoints(cfg.points, fn);

  return _getInterPath(points);
}

function _markerFn(x, y, r) {
  return [['M', x - r, y], ['L', x + r, y]];
}

function _smoothMarkerFn(x, y, r) {
  return [['M', x - r, y], ['A', r / 2, r / 2, 0, 1, 1, x, y], ['A', r / 2, r / 2, 0, 1, 0, x + r, y]];
} // get marker cfg


function _getMarkerCfg(cfg, smooth) {
  return Util.mix({
    symbol: smooth ? _smoothMarkerFn : _markerFn
  }, getMarkerAttrs(cfg));
}

function _getInterMarkerCfg(cfg, fn) {
  return Util.mix({
    symbol: fn
  }, getMarkerAttrs(cfg));
} // 褰撳彧鏈変竴涓暟鎹椂缁樺埗鐐�


function drawPointShape(shapeObj, cfg, container) {
  var point = cfg.points[0];
  return container.addShape('circle', {
    attrs: Util.mix({
      x: point.x,
      y: point.y,
      r: 2,
      fill: cfg.color
    }, cfg.style)
  });
} // regist line geom


var Line = Shape.registerFactory('line', {
  // 榛樿鐨剆hape
  defaultShapeType: 'line',

  /* getMarkerCfg(type, cfg) {
    const lineObj = Line[type] || Line.line;
    return lineObj.getMarkerCfg(cfg);
  }, */
  getActiveCfg: function getActiveCfg(type, cfg) {
    var lineWidth = cfg.lineWidth || 0;
    return {
      lineWidth: lineWidth + 1
    };
  },
  // 璁＄畻鐐� 濡傛灉瀛樺湪澶氫釜鐐癸紝鍒嗗壊鎴愬崟涓殑鐐�, 涓嶈€冭檻澶氫釜x瀵瑰簲涓€涓獃鐨勬儏鍐�
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return ShapeUtil.splitPoints(pointInfo);
  },
  drawShape: function drawShape(type, cfg, container) {
    var shape = this.getShape(type);
    var gShape;

    if (cfg.points.length === 1 && Global.showSinglePoint) {
      gShape = drawPointShape(this, cfg, container);
    } else {
      gShape = shape.draw(cfg, container);
    }

    if (gShape) {
      gShape.set('origin', cfg.origin);
      gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;
      gShape.name = this.name;
    }

    return gShape;
  }
}); // draw line shape

Shape.registerShape('line', 'line', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getPath(cfg, false);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg);
  }
}); // 鐐圭嚎 路路路

Shape.registerShape('line', 'dot', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getPath(cfg, false);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path,
        lineDash: DOT_ARR
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var tmp = _getMarkerCfg(cfg, false);

    tmp.lineDash = DOT_ARR;
    return tmp;
  }
}); // 鏂嚎 - - -

Shape.registerShape('line', 'dash', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getPath(cfg, false);
    return container.addShape('path', {
      attrs: Util.mix({
        path: path,
        lineDash: DASH_ARR
      }, attrs)
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var tmp = _getMarkerCfg(cfg, false);

    tmp.lineDash = tmp.lineDash || DASH_ARR;
    return tmp;
  }
}); // draw smooth line shape

Shape.registerShape('line', 'smooth', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var coord = this._coord; // 鏇茬嚎鐨勯檺鍒�

    cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];
    var path = getPath(cfg, true);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getMarkerCfg(cfg, true);
  }
});
Shape.registerShape('line', 'hv', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);

    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
      var tmp = [];
      tmp.push({
        x: nextPoint.x,
        y: point.y
      });
      return tmp;
    });

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getInterMarkerCfg(cfg, function (x, y, r) {
      return [['M', x - r - 1, y - 2.5], ['L', x, y - 2.5], ['L', x, y + 2.5], ['L', x + r + 1, y + 2.5]];
    });
  }
});
Shape.registerShape('line', 'vh', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);

    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
      var tmp = [];
      tmp.push({
        x: point.x,
        y: nextPoint.y
      });
      return tmp;
    });

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getInterMarkerCfg(cfg, function (x, y, r) {
      return [['M', x - r - 1, y + 2.5], ['L', x, y + 2.5], ['L', x, y - 2.5], ['L', x + r + 1, y - 2.5]];
    });
  }
});
Shape.registerShape('line', 'hvh', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);

    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
      var tmp = [];
      var middlex = (nextPoint.x - point.x) / 2 + point.x;
      tmp.push({
        x: middlex,
        y: point.y
      });
      tmp.push({
        x: middlex,
        y: nextPoint.y
      });
      return tmp;
    });

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getInterMarkerCfg(cfg, function (x, y, r) {
      return [['M', x - (r + 1), y + 2.5], ['L', x - r / 2, y + 2.5], ['L', x - r / 2, y - 2.5], ['L', x + r / 2, y - 2.5], ['L', x + r / 2, y + 2.5], ['L', x + r + 1, y + 2.5]];
    });
  }
});
Shape.registerShape('line', 'vhv', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);

    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {
      var tmp = [];
      var middley = (nextPoint.y - point.y) / 2 + point.y;
      tmp.push({
        x: point.x,
        y: middley
      });
      tmp.push({
        x: nextPoint.x,
        y: middley
      });
      return tmp;
    });

    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return _getInterMarkerCfg(cfg, function (x, y) {
      // 瀹� 13px锛岄珮 8px
      return [['M', x - 5, y + 2.5], ['L', x - 5, y], ['L', x, y], ['L', x, y - 3], ['L', x, y + 3], ['L', x + 6.5, y + 3]];
    });
  }
});
Line.spline = Line.smooth;
module.exports = Line;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview point shapes
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 * @author huangtonger@aliyun.com
 */
var Util = __webpack_require__(0);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

var Shape = __webpack_require__(9); // const svgpath = require('svgpath');


var _require = __webpack_require__(16),
    Marker = _require.Marker;

var PathUtil = Util.PathUtil;
var SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];
var HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line', 'pointerLine', 'pointerArrow'];
var SQRT_3 = Math.sqrt(3); // 澧炲姞marker

Util.mix(Marker.Symbols, {
  hexagon: function hexagon(x, y, r) {
    var diffX = r / 2 * SQRT_3;
    return [['M', x, y - r], ['L', x + diffX, y - r / 2], ['L', x + diffX, y + r / 2], ['L', x, y + r], ['L', x - diffX, y + r / 2], ['L', x - diffX, y - r / 2], ['Z']];
  },
  bowtie: function bowtie(x, y, r) {
    var diffY = r - 1.5;
    return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];
  },
  cross: function cross(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y + r], ['M', x + r, y - r], ['L', x - r, y + r]];
  },
  tick: function tick(x, y, r) {
    return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
  },
  plus: function plus(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y], ['M', x, y - r], ['L', x, y + r]];
  },
  hyphen: function hyphen(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  line: function line(x, y, r) {
    return [['M', x, y - r], ['L', x, y + r]];
  }
});

function getFillAttrs(cfg) {
  var defaultAttrs = Global.shape.point;
  var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addFillAttrs(pointAttrs, cfg);

  if (Util.isNumber(cfg.size)) {
    pointAttrs.radius = cfg.size;
  }

  return pointAttrs;
}

function getLineAttrs(cfg) {
  var defaultAttrs = Global.shape.hollowPoint;
  var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addStrokeAttrs(pointAttrs, cfg);

  if (Util.isNumber(cfg.size)) {
    pointAttrs.radius = cfg.size;
  }

  return pointAttrs;
}

var Point = Shape.registerFactory('point', {
  defaultShapeType: 'hollowCircle',
  getActiveCfg: function getActiveCfg(type, cfg) {
    // 鐐规斁澶� + 棰滆壊鍔犱寒
    var radius = cfg.radius;
    var color;

    if (type && (type.indexOf('hollow') === 0 || Util.indexOf(HOLLOW_SHAPES, type) !== -1) || !type) {
      color = cfg.stroke || cfg.strokeStyle;
    } else {
      color = cfg.fill || cfg.fillStyle;
    }

    return {
      radius: radius + 1,
      shadowBlur: radius,
      shadowColor: color,
      stroke: color,
      strokeOpacity: 1,
      lineWidth: 1
    };
  },
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return ShapeUtil.splitPoints(pointInfo);
  }
});

function getRectPath(cfg) {
  var x = cfg.points[0].x;
  var y = cfg.points[0].y;
  var w = cfg.size[0];
  var h = cfg.size[1];
  var path = [['M', x - 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y + 0.5 * h], ['L', x - 0.5 * w, y + 0.5 * h], ['z']];
  return path;
} // 鐢ㄤ簬妗戝熀鍥剧殑鑺傜偣


Shape.registerShape('point', 'rect', {
  draw: function draw(cfg, container) {
    var rectAttrs = getFillAttrs(cfg);
    var path = getRectPath(cfg);
    path = this.parsePath(path);
    var gShape = container.addShape('path', {
      attrs: Util.mix(rectAttrs, {
        path: path
      })
    });
    return gShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    var attrs = getFillAttrs(cfg);
    attrs.symbol = 'rect';
    attrs.radius = 4.5;
    return attrs;
  }
}); // 娣诲姞shapes

Util.each(SHAPES, function (shape) {
  Shape.registerShape('point', shape, {
    draw: function draw(cfg, container) {
      // cfg.points = this.parsePoints(cfg.points);
      var attrs = getFillAttrs(cfg);
      return container.addShape('Marker', {
        attrs: Util.mix(attrs, {
          symbol: shape,
          x: cfg.x,
          y: cfg.y
        })
      });
    },
    getMarkerCfg: function getMarkerCfg(cfg) {
      var attrs = getFillAttrs(cfg);
      attrs.symbol = shape;
      attrs.radius = 4.5;
      return attrs;
    }
  }); // 娣诲姞璇� shape 瀵瑰簲鐨� hollowShape

  Shape.registerShape('point', 'hollow' + Util.upperFirst(shape), {
    draw: function draw(cfg, container) {
      // cfg.points = this.parsePoints(cfg.points);
      var attrs = getLineAttrs(cfg);
      return container.addShape('Marker', {
        attrs: Util.mix(attrs, {
          symbol: shape,
          x: cfg.x,
          y: cfg.y
        })
      });
    },
    getMarkerCfg: function getMarkerCfg(cfg) {
      var attrs = getLineAttrs(cfg);
      attrs.symbol = shape;
      attrs.radius = 4.5;
      return attrs;
    }
  });
}); // 娣诲姞 hollowShapes

Util.each(HOLLOW_SHAPES, function (shape) {
  Shape.registerShape('point', shape, {
    draw: function draw(cfg, container) {
      var attrs = getLineAttrs(cfg);
      return container.addShape('Marker', {
        attrs: Util.mix(attrs, {
          symbol: shape,
          x: cfg.x,
          y: cfg.y
        })
      });
    },
    getMarkerCfg: function getMarkerCfg(cfg) {
      var attrs = getLineAttrs(cfg);
      attrs.symbol = shape;
      attrs.radius = 4.5;
      return attrs;
    }
  });
}); // image

Shape.registerShape('point', 'image', {
  draw: function draw(cfg, container) {
    cfg.points = this.parsePoints(cfg.points);
    return container.addShape('image', {
      attrs: {
        x: cfg.points[0].x - cfg.size / 2,
        y: cfg.points[0].y - cfg.size,
        width: cfg.size,
        height: cfg.size,
        img: cfg.shape[1]
      }
    });
  }
}); // path

var pathMetaCache = {};
Shape.registerShape('point', 'path', {
  draw: function draw(cfg, container) {
    var attrs = Util.mix({}, getLineAttrs(cfg), getFillAttrs(cfg));
    var path = cfg.shape[1];
    var size = cfg.size || 10;
    var pathMeta;

    if (pathMetaCache[path]) {
      pathMeta = pathMetaCache[path];
    } else {
      var segments = PathUtil.parsePathString(path);
      var nums = Util.flatten(segments).filter(function (num) {
        return Util.isNumber(num);
      });
      pathMetaCache[path] = pathMeta = {
        range: Math.max.apply(null, nums) - Math.min.apply(null, nums),
        segments: segments
      };
    }

    var scale = size / pathMeta.range;
    var transform = [];

    if (attrs.rotate) {
      transform.push(['r', attrs.rotate / 180 * Math.PI]);
      delete attrs.rotate;
    }

    var shape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: pathMeta.segments
      })
    });
    transform.push(['s', scale, scale], ['t', cfg.x, cfg.y]);
    shape.transform(transform);
    return shape;
  }
});
module.exports = Point;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview line shapes
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 * @author huangtonger@aliyun.com
 # @author liuye10@yahoo.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

function getAttrs(cfg) {
  var defaultCfg = Global.shape.polygon;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addFillAttrs(pathAttrs, cfg);
  return pathAttrs;
}

function getHollowAttrs(cfg) {
  var defaultCfg = Global.shape.hollowPolygon;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
  return pathAttrs;
}

function getPath(points) {
  var flag = points[0];
  var i = 1;
  var path = [['M', flag.x, flag.y]];

  while (i < points.length) {
    var c = points[i];

    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
      path.push(['L', c.x, c.y]);

      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
        flag = points[i + 1];
        path.push(['Z']);
        path.push(['M', flag.x, flag.y]);
        i++;
      }
    }

    i++;
  }

  if (!Util.isEqual(path[path.length - 1], flag)) {
    path.push(['L', flag.x, flag.y]);
  }

  path.push(['Z']);
  return path;
} // regist line geom


var Polygon = Shape.registerFactory('polygon', {
  defaultShapeType: 'polygon',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    var points = [];
    Util.each(pointInfo.x, function (subX, index) {
      var subY = pointInfo.y[index];
      points.push({
        x: subX,
        y: subY
      });
    });
    return points;
  },
  getActiveCfg: function getActiveCfg(type, cfg) {
    var lineWidth = cfg.lineWidth || 1;

    if (type === 'hollow') {
      return {
        lineWidth: lineWidth + 1
      };
    }

    var opacity = cfg.fillOpacity || cfg.opacity || 1;
    return {
      // lineWidth,
      fillOpacity: opacity - 0.08
    };
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    if (cfg && cfg.style) {
      return cfg.style;
    }

    return this.getActiveCfg(type, cfg);
  }
});
Shape.registerShape('polygon', 'polygon', {
  draw: function draw(cfg, container) {
    if (!Util.isEmpty(cfg.points)) {
      var attrs = getAttrs(cfg);
      var path = getPath(cfg.points);
      path = this.parsePath(path);
      return container.addShape('path', {
        attrs: Util.mix(attrs, {
          path: path
        })
      });
    }
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'square',
      radius: 4
    }, getAttrs(cfg));
  }
});
Shape.registerShape('polygon', 'hollow', {
  draw: function draw(cfg, container) {
    if (!Util.isEmpty(cfg.points)) {
      var attrs = getHollowAttrs(cfg);
      var path = getPath(cfg.points);
      path = this.parsePath(path);
      return container.addShape('path', {
        attrs: Util.mix(attrs, {
          path: path
        })
      });
    }
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'square',
      radius: 4
    }, getAttrs(cfg));
  }
});
module.exports = Polygon;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 鑷畾涔夌殑 shape
 * @author dxq613@gmail.com
 * @author sima.zhang1990@gmail.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

function _parseValue(value) {
  if (!Util.isArray(value)) {
    value = [value];
  }

  var min = value[0]; // 鏈€灏忓€�

  var max = value[value.length - 1]; // 鏈€澶у€�

  var min1 = value.length > 1 ? value[1] : min;
  var max1 = value.length > 3 ? value[3] : max;
  var median = value.length > 2 ? value[2] : min1;
  return {
    min: min,
    // 鏈€灏忓€�
    max: max,
    // 鏈€澶у€�
    min1: min1,
    max1: max1,
    median: median
  };
}

function addPoints(from, to) {
  Util.each(from, function (subArr) {
    to.push({
      x: subArr[0],
      y: subArr[1]
    });
  });
}

function getAttrs(cfg) {
  var defaultAttrs = Global.shape.schema;
  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);
  return lineAttrs;
}

function getFillAttrs(cfg) {
  var defaultAttrs = Global.shape.schema;
  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);
  ShapeUtil.addFillAttrs(lineAttrs, cfg);

  if (cfg.color) {
    lineAttrs.stroke = cfg.color || lineAttrs.stroke;
  }

  return lineAttrs;
}

function getBoxPoints(x, y, width) {
  var points = [];
  var pointsArray;
  var obj;

  if (Util.isArray(y)) {
    // 2缁�
    obj = _parseValue(y);
    pointsArray = [[x - width / 2, obj.max], [x + width / 2, obj.max], [x, obj.max], [x, obj.max1], [x - width / 2, obj.min1], [x - width / 2, obj.max1], [x + width / 2, obj.max1], [x + width / 2, obj.min1], [x, obj.min1], [x, obj.min], [x - width / 2, obj.min], [x + width / 2, obj.min], [x - width / 2, obj.median], [x + width / 2, obj.median]];
  } else {
    // 鍙湁涓€涓淮搴�
    y = y || 0.5;
    obj = _parseValue(x);
    pointsArray = [[obj.min, y - width / 2], [obj.min, y + width / 2], [obj.min, y], [obj.min1, y], [obj.min1, y - width / 2], [obj.min1, y + width / 2], [obj.max1, y + width / 2], [obj.max1, y - width / 2], [obj.max1, y], [obj.max, y], [obj.max, y - width / 2], [obj.max, y + width / 2], [obj.median, y - width / 2], [obj.median, y + width / 2]];
  }

  addPoints(pointsArray, points);
  return points;
}

function _sortValue(value) {
  if (!Util.isArray(value)) {
    value = [value];
  } // 浠庡ぇ鍒板皬鎺掑簭


  var sorted = value.sort(function (a, b) {
    return a < b ? 1 : -1;
  });
  var length = sorted.length;

  if (length < 4) {
    var min = sorted[length - 1];

    for (var i = 0; i < 4 - length; i++) {
      sorted.push(min);
    }
  }

  return sorted;
} // 鑾峰彇K绾垮浘鐨刾oints


function getCandlePoints(x, y, width) {
  var yValues = _sortValue(y);

  var points = [{
    x: x,
    y: yValues[0]
  }, {
    x: x,
    y: yValues[1]
  }, {
    x: x - width / 2,
    y: yValues[2]
  }, {
    x: x - width / 2,
    y: yValues[1]
  }, {
    x: x + width / 2,
    y: yValues[1]
  }, {
    x: x + width / 2,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[3]
  }]; // 鎸夌収椤烘椂閽堣繛鎺�

  return points;
}

function getBoxPath(points) {
  var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], // 灏侀棴 z
  ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x, points[10].y], ['L', points[11].x, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
  return path;
}

function getCandlePath(points) {
  var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
  return path;
}

var Schema = Shape.registerFactory('schema', {
  defaultShapeType: '',
  getActiveCfg: function getActiveCfg(type, cfg) {
    if (type === 'box') {
      var lineWidth = cfg.lineWidth || 1;
      return {
        lineWidth: lineWidth + 1
      };
    }

    var opacity = cfg.fillOpacity || cfg.opacity || 1;
    return {
      fillOpacity: opacity - 0.15,
      strokeOpacity: opacity - 0.15
    };
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    if (cfg && cfg.style) {
      return cfg.style;
    }

    return this.getActiveCfg(type, cfg);
  }
}); // 绠辩嚎鍥�

Shape.registerShape('schema', 'box', {
  getPoints: function getPoints(pointInfo) {
    return getBoxPoints(pointInfo.x, pointInfo.y, pointInfo.size);
  },
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getBoxPath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return {
      symbol: function symbol(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points = getBoxPoints(x, yValues, r);
        return [['M', points[0].x + 1, points[0].y], ['L', points[1].x - 1, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x + 1, points[10].y], ['L', points[11].x - 1, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
      },
      radius: 6,
      lineWidth: 1,
      stroke: cfg.color
    };
  }
}); // K绾�

Shape.registerShape('schema', 'candle', {
  getPoints: function getPoints(pointInfo) {
    return getCandlePoints(pointInfo.x, pointInfo.y, pointInfo.size);
  },
  draw: function draw(cfg, container) {
    var attrs = getFillAttrs(cfg);
    var path = getCandlePath(cfg.points);
    path = this.parsePath(path);
    return container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return {
      symbol: function symbol(x, y, r) {
        y = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points = getCandlePoints(x, y, r);
        return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
      },
      lineWidth: 1,
      stroke: cfg.color,
      fill: cfg.color,
      radius: 6
    };
  }
});
module.exports = Schema;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview venn shapes
 * @author leungwensen@gmail.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

var PathUtil = Util.PathUtil;

function getAttrs(cfg) {
  var defaultCfg = Global.shape.venn;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addFillAttrs(pathAttrs, cfg);
  return pathAttrs;
}

function getHollowAttrs(cfg) {
  var defaultCfg = Global.shape.hollowVenn;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
  return pathAttrs;
} // register venn geom


var Venn = Shape.registerFactory('venn', {
  defaultShapeType: 'venn',
  getActiveCfg: function getActiveCfg(type, cfg) {
    var lineWidth = cfg.lineWidth || 1;

    if (type === 'hollow') {
      return {
        lineWidth: lineWidth + 1
      };
    }

    var opacity = cfg.fillOpacity || cfg.opacity || 1;
    return {
      // lineWidth,
      fillOpacity: opacity - 0.08
    };
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    if (cfg && cfg.style) {
      return cfg.style;
    }

    return this.getActiveCfg(type, cfg);
  }
});
Shape.registerShape('venn', 'venn', {
  draw: function draw(cfg, container) {
    var origin = cfg.origin._origin;
    var path = origin.path;
    var attrs = getAttrs(cfg);
    var segments = PathUtil.parsePathString(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: segments
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getAttrs(cfg));
  }
});
Shape.registerShape('venn', 'hollow', {
  draw: function draw(cfg, container) {
    var origin = cfg.origin._origin;
    var path = origin.path;
    var attrs = getHollowAttrs(cfg);
    var segments = PathUtil.parsePathString(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: segments
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getAttrs(cfg));
  }
});
module.exports = Venn;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview venn shapes
 * @author leungwensen@gmail.com
 */
var Util = __webpack_require__(0);

var Shape = __webpack_require__(9);

var ShapeUtil = __webpack_require__(23);

var Global = __webpack_require__(5);

var PathUtil = __webpack_require__(25);

function getAttrs(cfg) {
  var defaultCfg = Global.shape.venn;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addFillAttrs(pathAttrs, cfg);

  if (cfg.color) {
    pathAttrs.stroke = pathAttrs.stroke || cfg.color;
  }

  return pathAttrs;
}

function getHollowAttrs(cfg) {
  var defaultCfg = Global.shape.hollowVenn;
  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);
  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);
  return pathAttrs;
}

function getViolinPath(points) {
  var path = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];

    if (point) {
      var action = i === 0 ? 'M' : 'L';
      path.push([action, point.x, point.y]);
    }
  }

  var first = points[0];

  if (first) {
    path.push(['L', first.x, first.y]);
    path.push(['z']);
  }

  return path;
}

function getSmoothViolinPath(points) {
  var half = points.length / 2;
  var leftPoints = [];
  var rightPoints = [];

  for (var i = 0; i < points.length; i++) {
    if (i < half) {
      leftPoints.push(points[i]);
    } else {
      rightPoints.push(points[i]);
    }
  }

  var leftPath = PathUtil.getSplinePath(leftPoints, false);
  var rightPath = PathUtil.getSplinePath(rightPoints, false);

  if (rightPoints.length) {
    leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);
  }

  rightPath.shift();
  var path = leftPath.concat(rightPath);

  if (leftPoints.length) {
    path.push(['L', leftPoints[0].x, leftPoints[0].y]);
  }

  path.push(['z']);
  return path;
}

function normalizeSize(arr) {
  var max = Math.max.apply(null, arr);
  return arr.map(function (num) {
    return num / max;
  });
} // register violin geom shape


var Violin = Shape.registerFactory('violin', {
  defaultShapeType: 'violin',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    var radius = pointInfo.size / 2;
    var points = [];
    var sizeArr = normalizeSize(pointInfo._size);
    Util.each(pointInfo.y, function (y, index) {
      var offset = sizeArr[index] * radius;
      var isMin = index === 0;
      var isMax = index === pointInfo.y.length - 1;
      points.push({
        isMin: isMin,
        isMax: isMax,
        x: pointInfo.x - offset,
        y: y
      });
      points.unshift({
        isMin: isMin,
        isMax: isMax,
        x: pointInfo.x + offset,
        y: y
      });
    });
    return points;
  },
  getActiveCfg: function getActiveCfg(type, cfg) {
    var lineWidth = cfg.lineWidth || 1;

    if (type === 'hollow') {
      return {
        lineWidth: lineWidth + 1
      };
    }

    var opacity = cfg.fillOpacity || cfg.opacity || 1;
    return {
      // lineWidth,
      fillOpacity: opacity - 0.08
    };
  },
  getSelectedCfg: function getSelectedCfg(type, cfg) {
    if (cfg && cfg.style) {
      return cfg.style;
    }

    return this.getActiveCfg(type, cfg);
  }
}); // normal violin, filled path

Shape.registerShape('violin', 'violin', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getViolinPath(cfg.points);
    path = this.parsePath(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getAttrs(cfg));
  }
}); // smooth spline violin, filled path

Shape.registerShape('violin', 'smooth', {
  draw: function draw(cfg, container) {
    var attrs = getAttrs(cfg);
    var path = getSmoothViolinPath(cfg.points);
    path = this.parsePath(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getAttrs(cfg));
  }
}); // hollow violin, stroked path

Shape.registerShape('violin', 'hollow', {
  draw: function draw(cfg, container) {
    var attrs = getHollowAttrs(cfg);
    var path = getViolinPath(cfg.points);
    path = this.parsePath(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getHollowAttrs(cfg));
  }
}); // hollow smooth spline violin, stroked path

Shape.registerShape('violin', 'smoothHollow', {
  draw: function draw(cfg, container) {
    var attrs = getHollowAttrs(cfg);
    var path = getSmoothViolinPath(cfg.points);
    path = this.parsePath(path);
    var pathShape = container.addShape('path', {
      attrs: Util.mix(attrs, {
        path: path
      })
    });
    return pathShape;
  },
  getMarkerCfg: function getMarkerCfg(cfg) {
    return Util.mix({
      symbol: 'circle',
      radius: 4
    }, getHollowAttrs(cfg));
  }
});
module.exports = Violin;

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

module.exports = function (field) {
  if (Util.isArray(field)) {
    return field;
  }

  if (Util.isString(field)) {
    return field.split('*');
  }

  return [field];
};

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var MatrixUtil = __webpack_require__(0).MatrixUtil;

var Vector2 = MatrixUtil.vec2;

function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min, max;

  if (hasConstraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min = Vector2.min([], min, point);
      max = Vector2.max([], max, point);
    }

    min = Vector2.min([], min, constraint[0]);
    max = Vector2.max([], max, constraint[1]);
  }

  for (var _i = 0, len = points.length; _i < len; _i++) {
    var _point = points[_i];

    if (isLoop) {
      prevPoint = points[_i ? _i - 1 : len - 1];
      nextPoint = points[(_i + 1) % len];
    } else {
      if (_i === 0 || _i === len - 1) {
        cps.push(_point);
        continue;
      } else {
        prevPoint = points[_i - 1];
        nextPoint = points[_i + 1];
      }
    }

    var v = [];
    v = Vector2.sub(v, nextPoint, prevPoint);
    v = Vector2.scale(v, v, smooth);
    var d0 = Vector2.distance(_point, prevPoint);
    var d1 = Vector2.distance(_point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    var v1 = Vector2.scale([], v, -d0);
    var v2 = Vector2.scale([], v, d1);
    var cp0 = Vector2.add([], _point, v1);
    var cp1 = Vector2.add([], _point, v2);

    if (hasConstraint) {
      cp0 = Vector2.max([], cp0, min);
      cp0 = Vector2.min([], cp0, max);
      cp1 = Vector2.max([], cp1, min);
      cp1 = Vector2.min([], cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
}

function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];

  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }

  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;

  for (var _i2 = 0; _i2 < len - 1; _i2++) {
    cp1 = controlPointList[_i2 * 2];
    cp2 = controlPointList[_i2 * 2 + 1];
    p = pointList[_i2 + 1];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  return d1;
}

module.exports = {
  catmullRom2bezier: catmullRom2bezier
};

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview Venn Diagram
 * @author leungwensen@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

var _require = __webpack_require__(544),
    venn = _require.venn,
    scaleSolution = _require.scaleSolution,
    circlePath = _require.circlePath,
    intersectionAreaPath = _require.intersectionAreaPath,
    computeTextCentres = _require.computeTextCentres;

__webpack_require__(311);

var Venn = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Venn, _GeomBase);

  function Venn() {
    return _GeomBase.apply(this, arguments) || this;
  }

  var _proto = Venn.prototype;

  /**
   * get default configuration
   * @protected
   * @return {Object} configuration
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'venn';
    cfg.shapeType = 'venn';
    cfg.generatePoints = false; // super.draw(data, container, shapeFactory, index);

    return cfg;
  };

  _proto._getAttrValues = function _getAttrValues(attr, record) {
    if (attr.type === 'position') {
      return [record.x, record.y];
    }

    return _GeomBase.prototype._getAttrValues.call(this, attr, record);
  };

  _proto.sets = function sets(field) {
    this.set('setsField', field);
    return this;
  };

  _proto._initAttrs = function _initAttrs() {
    var self = this;

    _GeomBase.prototype._initAttrs.call(this);

    var attrOptions = self.get('attrOptions');
    var setsField = self.get('setsField') || 'sets';
    var data = self.get('data');
    var sizeField = attrOptions.size ? attrOptions.size.field : 'size'; // prepare data

    data.forEach(function (row) {
      row.sets = row[setsField];
      row._sets = row[setsField].join('&');
      row.size = row[sizeField];
    });
    var solution = venn(data); // scaling

    var coord = self.get('coord');
    var xRange = [Math.min(coord.x.end, coord.x.start), Math.max(coord.x.end, coord.x.start)];
    var yRange = [Math.min(coord.y.end, coord.y.start), Math.max(coord.y.end, coord.y.start)];
    var width = xRange[1] - xRange[0];
    var height = yRange[1] - yRange[0];
    var styleOptions = self.get('styleOptions');
    var padding = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.padding : 0;

    if (!Util.isFinite(padding)) {
      padding = 0;
    }

    var circles = scaleSolution(solution, width, height, padding);
    var textCenters = computeTextCentres(circles, data);
    data.forEach(function (row) {
      var sets = row.sets;
      var id = sets.join(',');
      row.id = id;

      if (sets.length === 1) {
        var circle = circles[id];
        row.path = circlePath(circle.x, circle.y, circle.radius);
        Util.assign(row, circle);
      } else {
        var setCircles = sets.map(function (set) {
          return circles[set];
        });
        var path = intersectionAreaPath(setCircles);

        if (!/[zZ]$/.test(path)) {
          path += 'Z';
        }

        row.path = path;
        var center = textCenters[id] || {
          x: 0,
          y: 0
        };
        Util.assign(row, center);
      }
    }); // x, y scales
    // self.position('x*y');
    // self.scale('x', { type: 'identity' });
    // self.scale('y', { type: 'identity' });
  } // createShapePointsCfg(obj) {
  //   const xScale = this.getXScale();
  //   const yScale = this.getYScale();
  //   return {
  //     x: obj[xScale.field],
  //     y: obj[yScale.field],
  //     y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
  //   };
  // }
  // paint() {
  //   super.paint();
  //   const self = this;
  //   const dataArray = self.get('dataArray');
  //   const shapeContainer = self.get('shapeContainer');
  //   // add labels
  //   dataArray.forEach(row => {
  //     const cfg = self.getDrawCfg(row[0]);
  //     const origin = cfg.origin._origin;
  //     shapeContainer.addShape('text', {
  //       attrs: Util.mix({}, {
  //         x: origin.x,
  //         y: origin.y,
  //         text: origin.label || '',
  //         fontSize: 18,
  //         fill: cfg.shape === 'hollow' ? cfg.color : '#666',
  //         textAlign: 'center',
  //         textBaseline: 'middle'
  //       }, cfg.style ? cfg.style.textStyle : {})
  //     });
  //   });
  // }
  ;

  return Venn;
}(GeomBase);

GeomBase.Venn = Venn;
module.exports = Venn;

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview Venn Diagram
 * @author leungwensen@gmail.com
 */
var GeomBase = __webpack_require__(8);

var Util = __webpack_require__(0);

var SizeMixin = __webpack_require__(70);

__webpack_require__(312);

var Violin = /*#__PURE__*/function (_GeomBase) {
  _inheritsLoose(Violin, _GeomBase);

  var _proto = Violin.prototype;

  /**
   * get default configuration
   * @protected
   * @return {Object} configuration
   */
  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);

    cfg.type = 'violin';
    cfg.shapeType = 'violin';
    cfg.generatePoints = true; // super.draw(data, container, shapeFactory, index);

    return cfg;
  };

  function Violin(cfg) {
    var _this;

    _this = _GeomBase.call(this, cfg) || this;
    Util.assign(_assertThisInitialized(_this), SizeMixin);
    return _this;
  }

  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {
    var self = this;

    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);

    cfg.size = self.getNormalizedSize(obj);
    var sizeField = self.get('_sizeField');
    cfg._size = obj._origin[sizeField];
    return cfg;
  };

  _proto.clearInner = function clearInner() {
    _GeomBase.prototype.clearInner.call(this);

    this.set('defaultSize', null);
  };

  _proto._initAttrs = function _initAttrs() {
    var self = this;
    var attrOptions = self.get('attrOptions');
    var sizeField = attrOptions.size ? attrOptions.size.field : self.get('_sizeField') ? self.get('_sizeField') : 'size';
    self.set('_sizeField', sizeField);
    delete attrOptions.size;

    _GeomBase.prototype._initAttrs.call(this);
  };

  return Violin;
}(GeomBase);

var ViolinDodge = /*#__PURE__*/function (_Violin) {
  _inheritsLoose(ViolinDodge, _Violin);

  function ViolinDodge() {
    return _Violin.apply(this, arguments) || this;
  }

  var _proto2 = ViolinDodge.prototype;

  _proto2.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Violin.prototype.getDefaultCfg.call(this);

    cfg.hasDefaultAdjust = true;
    cfg.adjusts = [{
      type: 'dodge'
    }];
    return cfg;
  };

  return ViolinDodge;
}(Violin);

Violin.Dodge = ViolinDodge;
GeomBase.Violin = Violin;
GeomBase.ViolinDodge = ViolinDodge;
module.exports = Violin;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Interaction = __webpack_require__(28); // const G2 = require('../core.js');


var BRUSH_TYPES = ['X', 'Y', 'XY', 'POLYGON'];
var DEFAULT_TYPE = 'XY';

var Brush = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(Brush, _Interaction);

  var _proto = Brush.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      type: DEFAULT_TYPE,
      startPoint: null,
      brushing: false,
      dragging: false,
      brushShape: null,
      container: null,
      polygonPath: null,
      style: {
        fill: '#C5D4EB',
        opacity: 0.3,
        lineWidth: 1,
        stroke: '#82A6DD'
      },
      draggable: false,
      dragOffX: 0,
      dragOffY: 0,
      inPlot: true,
      xField: null,
      yField: null
    });
  };

  function Brush(cfg, view) {
    var _this;

    _this = _Interaction.call(this, cfg, view) || this;

    var me = _assertThisInitialized(_this);

    me.filter = !me.draggable;
    me.type = me.type.toUpperCase();
    me.chart = view;

    if (!BRUSH_TYPES.includes(me.type)) {
      me.type = DEFAULT_TYPE;
    }

    var canvas = me.canvas;

    if (canvas) {
      var plotRange;
      canvas.get('children').map(function (child) {
        if (child.get('type') === 'plotBack') {
          plotRange = child.get('plotRange');
          return false;
        }

        return child;
      });
      me.plot = {
        start: plotRange.bl,
        end: plotRange.tr
      };
    }

    if (view) {
      var coord = view.get('coord');
      me.plot = {
        start: coord.start,
        end: coord.end
      };
      view.on('afterrender', function () {
        me.plot = {
          start: coord.start,
          end: coord.end
        };
      });
      me.isTransposed = coord.isTransposed;

      var xScales = view._getScales('x');

      var yScales = view._getScales('y');

      me.xScale = me.xField ? xScales[me.xField] : view.getXScale();
      me.yScale = me.yField ? yScales[me.yField] : view.getYScales()[0];
    }

    return _this;
  } // onBurshstart() { }
  // onBrushmove() { }
  // onBrushend() {}
  // onDragstart() {}
  // onDragmove() {}
  // onDragend() {}


  _proto.start = function start(ev) {
    var me = this;
    var canvas = me.canvas,
        type = me.type,
        brushShape = me.brushShape;
    if (!type) return;

    if (me.brushing) {
      // 榧犳爣绉诲姩鍒板浘琛ㄥup, 鍥炲埌鍥捐〃鍐呯偣鍑诲嵆缁撴潫缁樺埗锛宮ousedown鐨勬椂鍊欏嵈姝ｅ湪缁樺埗涓�
      me.end(ev);
    }

    var startPoint = {
      x: ev.offsetX,
      y: ev.offsetY
    };
    if (!startPoint.x) return;
    var isInPlot = me.plot && me.inPlot;
    var canvasDOM = canvas.get('canvasDOM');
    var pixelRatio = canvas.get('pixelRatio');
    if (me.selection) me.selection = null;

    if (me.draggable && brushShape && !brushShape.get('destroyed')) {
      // allow drag the brushShape
      if (brushShape.isHit(startPoint.x * pixelRatio, startPoint.y * pixelRatio)) {
        canvasDOM.style.cursor = 'move';
        me.selection = brushShape;
        me.dragging = true;

        if (type === 'X') {
          me.dragoffX = startPoint.x - brushShape.attr('x');
          me.dragoffY = 0;
        } else if (type === 'Y') {
          me.dragoffX = 0;
          me.dragoffY = startPoint.y - brushShape.attr('y');
        } else if (type === 'XY') {
          me.dragoffX = startPoint.x - brushShape.attr('x');
          me.dragoffY = startPoint.y - brushShape.attr('y');
        } else if (type === 'POLYGON') {
          var box = brushShape.getBBox();
          me.dragoffX = startPoint.x - box.minX;
          me.dragoffY = startPoint.y - box.minY;
        }

        if (isInPlot) {// me.selection.attr('clip', canvas.addShape('rect', {
          //   attrs: {
          //     x: this.plot.start.x,
          //     y: this.plot.end.y,
          //     width: this.plot.end.x - this.plot.start.x,
          //     height: this.plot.start.y - this.plot.end.y,
          //     fill: '#fff',
          //     fillOpacity: 0
          //   }
          // }));
        }

        me.onDragstart && me.onDragstart(ev);
      }

      me.prePoint = startPoint;
    }

    if (!me.dragging) {
      // brush start
      me.onBrushstart && me.onBrushstart(startPoint);
      var container = me.container;

      if (isInPlot) {
        var _me$plot = me.plot,
            start = _me$plot.start,
            end = _me$plot.end;
        if (startPoint.x < start.x || startPoint.x > end.x || startPoint.y < end.y || startPoint.y > start.y) return;
      }

      canvasDOM.style.cursor = 'crosshair';
      me.startPoint = startPoint;
      me.brushShape = null;
      me.brushing = true;

      if (!container) {
        container = canvas.addGroup({
          zIndex: 5 // upper

        });
        container.initTransform();
      } else {
        container.clear();
      }

      me.container = container;
      if (type === 'POLYGON') me.polygonPath = "M " + startPoint.x + " " + startPoint.y;
    }
  };

  _proto.process = function process(ev) {
    var me = this;
    var brushing = me.brushing,
        dragging = me.dragging,
        type = me.type,
        plot = me.plot,
        startPoint = me.startPoint,
        xScale = me.xScale,
        yScale = me.yScale,
        canvas = me.canvas;

    if (!brushing && !dragging) {
      return;
    }

    var currentPoint = {
      x: ev.offsetX,
      y: ev.offsetY
    };
    var canvasDOM = canvas.get('canvasDOM');

    if (brushing) {
      canvasDOM.style.cursor = 'crosshair';
      var start = plot.start,
          end = plot.end;
      var polygonPath = me.polygonPath;
      var brushShape = me.brushShape;
      var container = me.container;

      if (me.plot && me.inPlot) {
        currentPoint = me._limitCoordScope(currentPoint);
      }

      var rectStartX;
      var rectStartY;
      var rectWidth;
      var rectHeight;

      if (type === 'Y') {
        rectStartX = start.x;
        rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
        rectWidth = Math.abs(start.x - end.x);
        rectHeight = Math.abs(startPoint.y - currentPoint.y);
      } else if (type === 'X') {
        rectStartX = currentPoint.x >= startPoint.x ? startPoint.x : currentPoint.x;
        rectStartY = end.y;
        rectWidth = Math.abs(startPoint.x - currentPoint.x);
        rectHeight = Math.abs(end.y - start.y);
      } else if (type === 'XY') {
        if (currentPoint.x >= startPoint.x) {
          rectStartX = startPoint.x;
          rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
        } else {
          rectStartX = currentPoint.x;
          rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;
        }

        rectWidth = Math.abs(startPoint.x - currentPoint.x);
        rectHeight = Math.abs(startPoint.y - currentPoint.y);
      } else if (type === 'POLYGON') {
        polygonPath += "L " + currentPoint.x + " " + currentPoint.y;
        me.polygonPath = polygonPath;

        if (!brushShape) {
          brushShape = container.addShape('path', {
            attrs: Util.mix(me.style, {
              path: polygonPath
            })
          });
        } else {
          !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
            path: polygonPath
          }));
        }
      }

      if (type !== 'POLYGON') {
        if (!brushShape) {
          brushShape = container.addShape('rect', {
            attrs: Util.mix(me.style, {
              x: rectStartX,
              y: rectStartY,
              width: rectWidth,
              height: rectHeight
            })
          });
        } else {
          !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
            x: rectStartX,
            y: rectStartY,
            width: rectWidth,
            height: rectHeight
          }));
        }
      }

      me.brushShape = brushShape;
    } else if (dragging) {
      canvasDOM.style.cursor = 'move';
      var selection = me.selection;

      if (selection && !selection.get('destroyed')) {
        if (type === 'POLYGON') {
          var prePoint = me.prePoint;
          me.selection.translate(currentPoint.x - prePoint.x, currentPoint.y - prePoint.y);
        } else {
          me.dragoffX && selection.attr('x', currentPoint.x - me.dragoffX);
          me.dragoffY && selection.attr('y', currentPoint.y - me.dragoffY);
        }
      }
    }

    me.prePoint = currentPoint;
    canvas.draw();

    var _me$_getSelected = me._getSelected(),
        data = _me$_getSelected.data,
        shapes = _me$_getSelected.shapes,
        xValues = _me$_getSelected.xValues,
        yValues = _me$_getSelected.yValues;

    var eventObj = {
      data: data,
      shapes: shapes
    };

    if (xScale) {
      eventObj[xScale.field] = xValues;
    }

    if (yScale) {
      eventObj[yScale.field] = yValues;
    } // 灏嗘閫夌殑鏁版嵁浼犻€掔粰 ev锛屼緵 onEnd 閽╁瓙浣跨敤


    Util.mix(ev, eventObj);
    eventObj.x = currentPoint.x;
    eventObj.y = currentPoint.y;
    me.onDragmove && me.onDragmove(eventObj);
    me.onBrushmove && me.onBrushmove(eventObj);
  };

  _proto.end = function end(ev) {
    var me = this;

    if (!me.brushing && !me.dragging) {
      return;
    }

    var data = me.data,
        shapes = me.shapes,
        xValues = me.xValues,
        yValues = me.yValues,
        canvas = me.canvas,
        type = me.type,
        startPoint = me.startPoint,
        chart = me.chart,
        container = me.container,
        xScale = me.xScale,
        yScale = me.yScale;
    var offsetX = ev.offsetX,
        offsetY = ev.offsetY;
    var canvasDOM = canvas.get('canvasDOM');
    canvasDOM.style.cursor = 'default';

    if (startPoint === null) {
      return;
    }

    if (Math.abs(startPoint.x - offsetX) <= 1 && Math.abs(startPoint.y - offsetY) <= 1) {
      // 闃叉鐐瑰嚮浜嬩欢
      me.brushing = false;
      me.dragging = false;
      container.clear();
      canvas.draw();
      return;
    }

    var eventObj = {
      data: data,
      shapes: shapes
    };

    if (xScale) {
      eventObj[xScale.field] = xValues;
    }

    if (yScale) {
      eventObj[yScale.field] = yValues;
    } // 灏嗘閫夌殑鏁版嵁浼犻€掔粰 ev锛屼緵 onEnd 閽╁瓙浣跨敤


    Util.mix(ev, eventObj);
    eventObj.x = offsetX;
    eventObj.y = offsetY;

    if (me.dragging) {
      me.dragging = false;
      me.onDragend && me.onDragend(eventObj);
    } else if (me.brushing) {
      me.brushing = false;
      var brushShape = me.brushShape;
      var polygonPath = me.polygonPath;

      if (type === 'POLYGON') {
        polygonPath += 'z';
        brushShape && !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {
          path: polygonPath
        }));
        me.polygonPath = polygonPath;
        canvas.draw();
      }

      if (me.onBrushend) {
        me.onBrushend(eventObj);
      } else if (chart && me.filter) {
        container.clear(); // clear the brush
        // filter data

        if (!me.isTransposed && type === 'X' || me.isTransposed && type === 'Y') {
          xScale && chart.filter(xScale.field, function (val) {
            return xValues.indexOf(val) > -1;
          });
        } else if (!me.isTransposed && type === 'Y' || me.isTransposed && type === 'X') {
          yScale && chart.filter(yScale.field, function (val) {
            return yValues.indexOf(val) > -1;
          });
        } else {
          xScale && chart.filter(xScale.field, function (val) {
            return xValues.indexOf(val) > -1;
          });
          yScale && chart.filter(yScale.field, function (val) {
            return yValues.indexOf(val) > -1;
          });
        }

        chart.repaint();
      }
    }
  };

  _proto.reset = function reset() {
    var me = this;
    var chart = me.chart,
        filter = me.filter,
        brushShape = me.brushShape,
        canvas = me.canvas;

    this._init(); // 閲嶇疆鍚勭鍙傝€冨€�


    if (chart && filter) {
      chart.get('options').filters = {};
      chart.repaint();
    }

    if (brushShape) {
      brushShape.destroy();
      canvas.draw();
    }
  };

  _proto._limitCoordScope = function _limitCoordScope(point) {
    var plot = this.plot;
    var start = plot.start,
        end = plot.end;

    if (point.x < start.x) {
      point.x = start.x;
    }

    if (point.x > end.x) {
      point.x = end.x;
    }

    if (point.y < end.y) {
      point.y = end.y;
    }

    if (point.y > start.y) {
      point.y = start.y;
    }

    return point;
  };

  _proto._getSelected = function _getSelected() {
    var me = this;
    var chart = me.chart,
        xScale = me.xScale,
        yScale = me.yScale,
        brushShape = me.brushShape,
        canvas = me.canvas;
    var pixelRatio = canvas.get('pixelRatio');
    var selectedShapes = [];
    var xValues = [];
    var yValues = [];
    var selectedData = [];

    if (chart) {
      var geoms = chart.get('geoms');
      geoms.map(function (geom) {
        var shapes = geom.getShapes();
        shapes.map(function (shape) {
          var shapeData = shape.get('origin');

          if (!Array.isArray(shapeData)) {
            // 绾垮浘銆佸尯鍩熷浘绛�
            shapeData = [shapeData];
          }

          shapeData.map(function (each) {
            if (brushShape.isHit(each.x * pixelRatio, each.y * pixelRatio)) {
              selectedShapes.push(shape);
              var origin = each._origin;
              selectedData.push(origin);
              xScale && xValues.push(origin[xScale.field]);
              yScale && yValues.push(origin[yScale.field]);
            }

            return each;
          });
          return shape;
        });
        return geom;
      });
    }

    me.shapes = selectedShapes;
    me.xValues = xValues;
    me.yValues = yValues;
    me.data = selectedData;
    canvas.draw();
    return {
      data: selectedData,
      xValues: xValues,
      yValues: yValues,
      shapes: selectedShapes
    };
  };

  return Brush;
}(Interaction); // G2.registerInteraction('brush', Brush);
// G2.registerInteraction('Brush', Brush);


module.exports = Brush;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var G = __webpack_require__(16);

var Group = G.Group;
var DomUtil = Util.DomUtil;
var OFFSET = 5;

var Range = function Range(cfg) {
  Range.superclass.constructor.call(this, cfg);
};

Util.extend(Range, Group);
Util.augment(Range, {
  getDefaultCfg: function getDefaultCfg() {
    return {
      /**
       * 鑼冨洿
       * @type {Array}
       */
      range: null,

      /**
       * 涓粦鍧楀睘鎬�
       * @type {ATTRS}
       */
      middleAttr: null,

      /**
       * 鑳屾櫙
       * @type {G-Element}
       */
      backgroundElement: null,

      /**
       * 涓嬫粦鍧�
       * @type {G-Element}
       */
      minHandleElement: null,

      /**
       * 涓婃粦鍧�
       * @type {G-Element}
       */
      maxHandleElement: null,

      /**
       * 涓潡
       * @type {G-Element}
       */
      middleHandleElement: null,

      /**
       * 褰撳墠鐨勬縺娲荤殑鍏冪礌
       * @type {G-Element}
       */
      currentTarget: null,

      /**
       * 甯冨眬鏂瑰紡锛� horizontal锛寁ertical
       * @type {String}
       */
      layout: 'vertical',

      /**
       * 瀹�
       * @type {Number}
       */
      width: null,

      /**
       * 楂�
       * @type {Number}
       */
      height: null,

      /**
       * 褰撳墠鐨凱ageX
       * @type {Number}
       */
      pageX: null,

      /**
       * 褰撳墠鐨凱ageY
       * @type {Number}
       */
      pageY: null
    };
  },
  _initHandle: function _initHandle(type) {
    var self = this;
    var handle = self.addGroup();
    var layout = self.get('layout');
    var handleStyle = self.get('handleStyle');
    var img = handleStyle.img;
    var iconWidth = handleStyle.width;
    var iconHeight = handleStyle.height;
    var text;
    var handleIcon;
    var triggerCursor;

    if (layout === 'horizontal') {
      var _iconWidth = handleStyle.width;
      triggerCursor = 'ew-resize';
      handleIcon = handle.addShape('Image', {
        attrs: {
          x: -_iconWidth / 2,
          y: 0,
          width: _iconWidth,
          height: iconHeight,
          img: img,
          cursor: triggerCursor
        }
      });
      text = handle.addShape('Text', {
        attrs: Util.mix({
          x: type === 'min' ? -(_iconWidth / 2 + OFFSET) : _iconWidth / 2 + OFFSET,
          y: iconHeight / 2,
          textAlign: type === 'min' ? 'end' : 'start',
          textBaseline: 'middle',
          text: type === 'min' ? this.get('minText') : this.get('maxText'),
          cursor: triggerCursor
        }, this.get('textStyle'))
      });
    } else {
      triggerCursor = 'ns-resize';
      handleIcon = handle.addShape('Image', {
        attrs: {
          x: 0,
          y: -iconHeight / 2,
          width: iconWidth,
          height: iconHeight,
          img: img,
          cursor: triggerCursor
        }
      });
      text = handle.addShape('Text', {
        attrs: Util.mix({
          x: iconWidth / 2,
          y: type === 'min' ? iconHeight / 2 + OFFSET : -(iconHeight / 2 + OFFSET),
          textAlign: 'center',
          textBaseline: 'middle',
          text: type === 'min' ? this.get('minText') : this.get('maxText'),
          cursor: triggerCursor
        }, this.get('textStyle'))
      });
    }

    this.set(type + 'TextElement', text);
    this.set(type + 'IconElement', handleIcon);
    return handle;
  },
  _initSliderBackground: function _initSliderBackground() {
    var backgroundElement = this.addGroup();
    backgroundElement.initTransform();
    backgroundElement.translate(0, 0);
    backgroundElement.addShape('Rect', {
      attrs: Util.mix({
        x: 0,
        y: 0,
        width: this.get('width'),
        height: this.get('height')
      }, this.get('backgroundStyle'))
    });
    return backgroundElement;
  },
  _beforeRenderUI: function _beforeRenderUI() {
    var backgroundElement = this._initSliderBackground();

    var minHandleElement = this._initHandle('min');

    var maxHandleElement = this._initHandle('max');

    var middleHandleElement = this.addShape('rect', {
      attrs: this.get('middleAttr')
    });
    this.set('middleHandleElement', middleHandleElement);
    this.set('minHandleElement', minHandleElement);
    this.set('maxHandleElement', maxHandleElement);
    this.set('backgroundElement', backgroundElement);
    backgroundElement.set('zIndex', 0);
    middleHandleElement.set('zIndex', 1);
    minHandleElement.set('zIndex', 2);
    maxHandleElement.set('zIndex', 2);
    middleHandleElement.attr('cursor', 'move');
    this.sort();
  },
  _renderUI: function _renderUI() {
    if (this.get('layout') === 'horizontal') {
      this._renderHorizontal();
    } else {
      this._renderVertical();
    }
  },
  _transform: function _transform(layout) {
    var range = this.get('range');
    var minRatio = range[0] / 100;
    var maxRatio = range[1] / 100;
    var width = this.get('width');
    var height = this.get('height');
    var minHandleElement = this.get('minHandleElement');
    var maxHandleElement = this.get('maxHandleElement');
    var middleHandleElement = this.get('middleHandleElement');

    if (minHandleElement.resetMatrix) {
      minHandleElement.resetMatrix();
      maxHandleElement.resetMatrix();
    } else {
      minHandleElement.initTransform();
      maxHandleElement.initTransform();
    }

    if (layout === 'horizontal') {
      middleHandleElement.attr({
        x: width * minRatio,
        y: 0,
        width: (maxRatio - minRatio) * width,
        height: height
      });
      minHandleElement.translate(minRatio * width, 0);
      maxHandleElement.translate(maxRatio * width, 0);
    } else {
      middleHandleElement.attr({
        x: 0,
        y: height * (1 - maxRatio),
        width: width,
        height: (maxRatio - minRatio) * height
      });
      minHandleElement.translate(0, (1 - minRatio) * height);
      maxHandleElement.translate(0, (1 - maxRatio) * height);
    }
  },
  _renderHorizontal: function _renderHorizontal() {
    this._transform('horizontal');
  },
  _renderVertical: function _renderVertical() {
    this._transform('vertical');
  },
  _bindUI: function _bindUI() {
    this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));
  },
  _isElement: function _isElement(target, name) {
    // 鍒ゆ柇鏄惁鏄鍏冪礌
    var element = this.get(name);

    if (target === element) {
      return true;
    }

    if (element.isGroup) {
      var elementChildren = element.get('children');
      return elementChildren.indexOf(target) > -1;
    }

    return false;
  },
  _getRange: function _getRange(diff, range) {
    var rst = diff + range;
    rst = rst > 100 ? 100 : rst;
    rst = rst < 0 ? 0 : rst;
    return rst;
  },
  _limitRange: function _limitRange(diff, limit, range) {
    range[0] = this._getRange(diff, range[0]);
    range[1] = range[0] + limit;

    if (range[1] > 100) {
      range[1] = 100;
      range[0] = range[1] - limit;
    }
  },
  _updateStatus: function _updateStatus(dim, ev) {
    var totalLength = dim === 'x' ? this.get('width') : this.get('height');
    dim = Util.upperFirst(dim);
    var range = this.get('range');
    var page = this.get('page' + dim);
    var currentTarget = this.get('currentTarget');
    var rangeStash = this.get('rangeStash');
    var layout = this.get('layout');
    var sign = layout === 'vertical' ? -1 : 1;
    var currentPage = ev['page' + dim];
    var diffPage = currentPage - page;
    var diffRange = diffPage / totalLength * 100 * sign;
    var diffStashRange;
    var minRange = this.get('minRange');
    var maxRange = this.get('maxRange');

    if (range[1] <= range[0]) {
      if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {
        range[0] = this._getRange(diffRange, range[0]);
        range[1] = this._getRange(diffRange, range[0]);
      }
    } else {
      if (this._isElement(currentTarget, 'minHandleElement')) {
        range[0] = this._getRange(diffRange, range[0]);

        if (minRange) {
          // 璁剧疆浜嗘渶灏忚寖鍥�
          if (range[1] - range[0] <= minRange) {
            this._limitRange(diffRange, minRange, range);
          }
        }

        if (maxRange) {
          // 璁剧疆浜嗘渶澶ц寖鍥�
          if (range[1] - range[0] >= maxRange) {
            this._limitRange(diffRange, maxRange, range);
          }
        }
      }

      if (this._isElement(currentTarget, 'maxHandleElement')) {
        range[1] = this._getRange(diffRange, range[1]);

        if (minRange) {
          // 璁剧疆浜嗘渶灏忚寖鍥�
          if (range[1] - range[0] <= minRange) {
            this._limitRange(diffRange, minRange, range);
          }
        }

        if (maxRange) {
          // 璁剧疆浜嗘渶澶ц寖鍥�
          if (range[1] - range[0] >= maxRange) {
            this._limitRange(diffRange, maxRange, range);
          }
        }
      }
    }

    if (this._isElement(currentTarget, 'middleHandleElement')) {
      diffStashRange = rangeStash[1] - rangeStash[0];

      this._limitRange(diffRange, diffStashRange, range);
    }

    this.emit('sliderchange', {
      range: range
    });
    this.set('page' + dim, currentPage);

    this._renderUI();

    this.get('canvas').draw(); // need delete

    return;
  },
  _onMouseDown: function _onMouseDown(ev) {
    var currentTarget = ev.currentTarget;
    var originEvent = ev.event;
    var range = this.get('range');
    originEvent.stopPropagation();
    originEvent.preventDefault();
    this.set('pageX', originEvent.pageX);
    this.set('pageY', originEvent.pageY);
    this.set('currentTarget', currentTarget);
    this.set('rangeStash', [range[0], range[1]]);

    this._bindCanvasEvents();
  },
  _bindCanvasEvents: function _bindCanvasEvents() {
    var containerDOM = this.get('canvas').get('containerDOM');
    this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));
    this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp')); // @2018-06-06 by blue.lb 娣诲姞mouseleave浜嬩欢鐩戝惉锛岃鐢ㄦ埛鍦ㄦ搷浣滃嚭婊戝潡鍖哄煙鍚庢湁涓€涓€滄甯糕€濈殑鏁堟灉锛屽彲浠ユ甯搁噸鏂拌Е鍙戞粦鍧楃殑鎿嶄綔娴佺▼

    this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));
  },
  _onCanvasMouseMove: function _onCanvasMouseMove(ev) {
    var layout = this.get('layout');

    if (layout === 'horizontal') {
      this._updateStatus('x', ev);
    } else {
      this._updateStatus('y', ev);
    }
  },
  _onCanvasMouseUp: function _onCanvasMouseUp() {
    this._removeDocumentEvents();
  },
  _removeDocumentEvents: function _removeDocumentEvents() {
    this.onMouseMoveListener.remove();
    this.onMouseUpListener.remove();
    this.onMouseLeaveListener.remove();
  }
});
module.exports = Range;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Interaction = __webpack_require__(28);

var filterData = __webpack_require__(320);

var getColDef = __webpack_require__(71);

var getLimitRange = __webpack_require__(73);

var DAY_TIMESTAMPS = 86400000; // const G2 = require('../core.js');

var DRAGGING_TYPES = ['X', 'Y', 'XY'];
var DEFAULT_TYPE = 'X';

var Drag = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(Drag, _Interaction);

  var _proto = Drag.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      type: DEFAULT_TYPE,
      stepRatio: 0.05,
      limitRange: {},
      stepByField: {},
      threshold: 20,
      originScaleDefsByField: {},
      previousPoint: null,
      isDragging: false
    });
  };

  _proto._disableTooltip = function _disableTooltip() {
    var me = this;
    var chart = me.chart;
    var tooltipController = chart.get('tooltipController');

    if (tooltipController) {
      me._showTooltip = true;
      chart.tooltip(false);
    }
  };

  _proto._enableTooltip = function _enableTooltip(ev) {
    var me = this;
    var chart = me.chart;

    if (me._showTooltip) {
      chart.tooltip(true);
      chart.showTooltip(ev);
    }
  };

  function Drag(cfg, chart) {
    var _this;

    _this = _Interaction.call(this, cfg, chart) || this;

    var me = _assertThisInitialized(_this);

    me.type = me.type.toUpperCase();
    me.chart = chart;
    me.coord = chart.get('coord');
    var data = me.data = chart.get('data'); // pre process

    filterData(chart);
    var scales = chart.getYScales();
    var xScale = chart.getXScale();
    scales.push(xScale);
    var scaleController = chart.get('scaleController');
    scales.forEach(function (scale) {
      var field = scale.field;
      me.limitRange[field] = getLimitRange(data, scale);
      var def = scaleController.defs[field] || {};
      me.originScaleDefsByField[field] = Util.mix(def, {
        nice: !!def.nice
      });

      if (scale.isLinear) {
        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
      }
    });

    if (!DRAGGING_TYPES.includes(me.type)) {
      me.type = DEFAULT_TYPE;
    }

    me._disableTooltip();

    return _this;
  } // onDragstart() { }
  // onDrag() { }
  // onDragend() { }


  _proto._applyTranslate = function _applyTranslate(scale, offset, total) {
    if (offset === void 0) {
      offset = 0;
    }

    var me = this;

    if (scale.isLinear) {
      me._translateLinearScale(scale, offset, total);
    } else {
      me._translateCatScale(scale, offset, total);
    }
  };

  _proto._translateCatScale = function _translateCatScale(scale, offset, total) {
    var me = this;
    var chart = me.chart;
    var type = scale.type,
        field = scale.field,
        values = scale.values,
        ticks = scale.ticks;
    var colDef = getColDef(chart, field);
    var originValues = me.limitRange[field];
    var ratio = offset / total;
    var valueLength = values.length;
    var deltaCount = Math.max(1, Math.abs(parseInt(ratio * valueLength)));
    var firstIndex = originValues.indexOf(values[0]);
    var lastIndex = originValues.indexOf(values[valueLength - 1]);

    if (offset > 0 && firstIndex >= 0) {
      // right
      for (var i = 0; i < deltaCount && firstIndex > 0; i++) {
        firstIndex -= 1;
        lastIndex -= 1;
      }

      var newValues = originValues.slice(firstIndex, lastIndex + 1);
      var newTicks = null;

      if (type === 'timeCat') {
        var tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;

        for (var _i = ticks[0] - tickGap; _i >= newValues[0]; _i -= tickGap) {
          ticks.unshift(_i);
        }

        newTicks = ticks;
      }

      chart.scale(field, Util.mix({}, colDef, {
        values: newValues,
        ticks: newTicks
      }));
    } else if (offset < 0 && lastIndex <= originValues.length - 1) {
      // left
      for (var _i2 = 0; _i2 < deltaCount && lastIndex < originValues.length - 1; _i2++) {
        firstIndex += 1;
        lastIndex += 1;
      }

      var _newValues = originValues.slice(firstIndex, lastIndex + 1);

      var _newTicks = null;

      if (type === 'timeCat') {
        var _tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;

        for (var _i3 = ticks[ticks.length - 1] + _tickGap; _i3 <= _newValues[_newValues.length - 1]; _i3 += _tickGap) {
          ticks.push(_i3);
        }

        _newTicks = ticks;
      }

      chart.scale(field, Util.mix({}, colDef, {
        values: _newValues,
        ticks: _newTicks
      }));
    }
  };

  _proto._translateLinearScale = function _translateLinearScale(scale, offset, total) {
    var me = this;
    var chart = me.chart,
        limitRange = me.limitRange; // linear / cat

    var min = scale.min,
        max = scale.max,
        field = scale.field;
    if (min === limitRange[field].min && max === limitRange[field].max) return;
    var ratio = offset / total;
    var range = max - min;
    var colDef = getColDef(chart, field);
    chart.scale(field, Util.mix({}, colDef, {
      nice: false,
      min: min + ratio * range,
      max: max + ratio * range
    }));
  };

  _proto.start = function start(ev) {
    var me = this;
    var canvas = me.canvas;
    var canvasDOM = canvas.get('canvasDOM');
    canvasDOM.style.cursor = 'pointer'; // const coord = chart.get('coord');

    me.isDragging = true;
    me.previousPoint = {
      x: ev.x,
      y: ev.y
    };

    me._disableTooltip();
  };

  _proto.process = function process(ev) {
    var me = this;

    if (me.isDragging) {
      var chart = me.chart,
          type = me.type,
          canvas = me.canvas,
          coord = me.coord,
          threshold = me.threshold;
      var canvasDOM = canvas.get('canvasDOM');
      canvasDOM.style.cursor = 'move'; // const coord = chart.get('coord');

      var previousPoint = me.previousPoint;
      var currentPoint = ev;
      var deltaX = currentPoint.x - previousPoint.x;
      var deltaY = currentPoint.y - previousPoint.y;
      var modified = false;

      if (Math.abs(deltaX) > threshold && type.indexOf('X') > -1) {
        modified = true;
        var xScale = chart.getXScale();

        me._applyTranslate(xScale, xScale.isLinear ? -deltaX : deltaX, coord.width);
      }

      if (Math.abs(deltaY) > threshold && type.indexOf('Y') > -1) {
        modified = true;
        var yScales = chart.getYScales();
        yScales.forEach(function (yScale) {
          me._applyTranslate(yScale, currentPoint.y - previousPoint.y, coord.height);
        });
      }

      if (modified) {
        me.previousPoint = currentPoint;
        chart.repaint();
      }
    }
  };

  _proto.end = function end(ev) {
    var me = this;
    me.isDragging = false;
    var canvas = me.canvas;
    var canvasDOM = canvas.get('canvasDOM');
    canvasDOM.style.cursor = 'default';

    me._enableTooltip(ev);
  };

  _proto.reset = function reset() {
    var me = this;
    var view = me.view,
        originScaleDefsByField = me.originScaleDefsByField;
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    scales.forEach(function (scale) {
      if (scale.isLinear) {
        var field = scale.field;
        view.scale(field, originScaleDefsByField[field]);
      }
    });
    view.repaint();

    me._disableTooltip();
  };

  return Drag;
}(Interaction);

module.exports = Drag;

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(0);

var TimeUtil = __webpack_require__(52);

var getColDefs = __webpack_require__(72);

module.exports = function (chart) {
  chart.on('beforeinitgeoms', function () {
    chart.set('limitInPlot', true);
    var data = chart.get('data');
    var colDefs = getColDefs(chart);
    if (!colDefs) return data;
    var geoms = chart.get('geoms');
    var isSpecialGeom = false;
    Util.each(geoms, function (geom) {
      if (['area', 'line', 'path'].includes(geom.get('type'))) {
        isSpecialGeom = true;
        return false;
      }
    });
    var fields = [];
    Util.each(colDefs, function (def, key) {
      if (!isSpecialGeom && def && (def.values || def.min || def.max)) {
        fields.push(key);
      }
    });

    if (fields.length === 0) {
      return data;
    }

    var geomData = [];
    Util.each(data, function (obj) {
      var flag = true;
      Util.each(fields, function (field) {
        var value = obj[field];

        if (value) {
          var colDef = colDefs[field];

          if (colDef.type === 'timeCat') {
            var values = colDef.values;

            if (Util.isNumber(values[0])) {
              value = TimeUtil.toTimeStamp(value);
            }
          }

          if (colDef.values && !colDef.values.includes(value) || colDef.min && value < colDef.min || colDef.max && value > colDef.max) {
            flag = false;
          }
        }
      });

      if (flag) {
        geomData.push(obj);
      }
    });
    chart.set('filteredData', geomData);
  });
};

/***/ }),
/* 321 */
/***/ (function(module, exports) {

module.exports = function (scale, limitRange, type) {
  if (!scale) return [0, 1];
  var minRatio = 0;
  var maxRatio = 0;

  if (type === 'linear') {
    var min = limitRange.min,
        max = limitRange.max;
    var range = max - min;
    minRatio = (scale.min - min) / range;
    maxRatio = (scale.max - min) / range;
  } else {
    var originValues = limitRange;
    var values = scale.values;
    var firstIndex = originValues.indexOf(values[0]);
    var lastIndex = originValues.indexOf(values[values.length - 1]);
    minRatio = firstIndex / (originValues.length - 1);
    maxRatio = lastIndex / (originValues.length - 1);
  }

  return [minRatio, maxRatio];
};

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Interaction
 * @author leungwensen@gmail.com
 */
var G2 = __webpack_require__(45);

var Chart = __webpack_require__(44);

var Util = __webpack_require__(0);

var Interactions = {
  Base: __webpack_require__(28),
  Brush: __webpack_require__(317),
  Drag: __webpack_require__(319),
  ScrollBar: __webpack_require__(323),
  ShapeSelect: __webpack_require__(324),
  Slider: __webpack_require__(325),
  Zoom: __webpack_require__(326)
};
G2._Interactions = {};

G2.registerInteraction = function (type, constructor) {
  G2._Interactions[type] = constructor;
};

G2.getInteraction = function (type) {
  return G2._Interactions[type];
}; // binding on View


Chart.prototype.getInteractions = function () {
  var me = this;

  if (!me._interactions) {
    me._interactions = {};
  }

  return me._interactions;
};

Chart.prototype._setInteraction = function (type, interaction) {
  var me = this;
  var interactions = me.getInteractions();

  if (interactions[type] && interactions[type] !== interaction) {
    // only one interaction for a key
    interactions[type].destroy();
  }

  interactions[type] = interaction;
};

Chart.prototype.clearInteraction = function (type) {
  var me = this;
  var interactions = me.getInteractions();

  if (type) {
    if (interactions[type]) {
      interactions[type]._reset();

      interactions[type].destroy();
    }

    delete interactions[type];
  } else {
    Util.each(interactions, function (interaction, key) {
      interaction._reset();

      interaction.destroy();
      delete interactions[key];
    });
  }
};

Chart.prototype.interact = Chart.prototype.interaction = function (type, cfg) {
  var me = this;
  var Ctor = G2.getInteraction(type);
  var interaction = new Ctor(cfg, me);

  me._setInteraction(type, interaction);

  return me;
};

G2.registerInteraction('brush', Interactions.Brush);
G2.registerInteraction('Brush', Interactions.Brush);
G2.registerInteraction('drag', Interactions.Drag);
G2.registerInteraction('Drag', Interactions.Drag);
G2.registerInteraction('zoom', Interactions.Zoom);
G2.registerInteraction('Zoom', Interactions.Zoom);
G2.registerInteraction('scroll-bar', Interactions.ScrollBar);
G2.registerInteraction('ScrollBar', Interactions.ScrollBar);
G2.registerInteraction('shape-select', Interactions.ShapeSelect);
G2.registerInteraction('ShapeSelect', Interactions.ShapeSelect);
G2.registerInteraction('slider', Interactions.Slider);
G2.registerInteraction('Slider', Interactions.Slider);
module.exports = Interactions;

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Interaction = __webpack_require__(28);

var getFieldRange = __webpack_require__(321);

var getLimitRange = __webpack_require__(73);

var DEFAULT_TYPE = 'X';

var ScrollBar = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(ScrollBar, _Interaction);

  var _proto = ScrollBar.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      startEvent: null,
      processEvent: null,
      endEvent: null,
      resetEvent: null,
      type: DEFAULT_TYPE,
      xStyle: {
        backgroundColor: 'rgba(202, 215, 239, .2)',
        fillerColor: 'rgba(202, 215, 239, .75)',
        size: 4,
        lineCap: 'round',
        offsetX: 0,
        offsetY: -10
      },
      yStyle: {
        backgroundColor: 'rgba(202, 215, 239, .2)',
        fillerColor: 'rgba(202, 215, 239, .75)',
        size: 4,
        lineCap: 'round',
        offsetX: 8,
        offsetY: 0
      }
    });
  };

  _proto._renderScrollBars = function _renderScrollBars() {
    var chart = this.chart;
    var scrollBarCfg = chart.get('_scrollBarCfg');
    if (!scrollBarCfg) return;
    var data = chart.get('data');
    var plotRange = chart.get('plotRange');
    plotRange.width = Math.abs(plotRange.br.x - plotRange.bl.x);
    plotRange.height = Math.abs(plotRange.tl.y - plotRange.bl.y);
    var backPlot = chart.get('backPlot');
    var canvas = chart.get('canvas');
    var canvasHeight = canvas.get('height');
    var limitRange = chart.get('_limitRange');
    var type = scrollBarCfg.type;

    if (type.indexOf('X') > -1) {
      var _scrollBarCfg$xStyle = scrollBarCfg.xStyle,
          offsetX = _scrollBarCfg$xStyle.offsetX,
          offsetY = _scrollBarCfg$xStyle.offsetY,
          lineCap = _scrollBarCfg$xStyle.lineCap,
          backgroundColor = _scrollBarCfg$xStyle.backgroundColor,
          fillerColor = _scrollBarCfg$xStyle.fillerColor,
          size = _scrollBarCfg$xStyle.size;
      var xScale = chart.getXScale();
      var xLimitRange = limitRange[xScale.field];

      if (!xLimitRange) {
        xLimitRange = getLimitRange(data, xScale);
        limitRange[xScale.field] = xLimitRange;
      }

      var currentRange = getFieldRange(xScale, xLimitRange, xScale.type);
      var horizontalBar = chart.get('_horizontalBar');
      var yPos = canvasHeight - size / 2 + offsetY;

      if (horizontalBar) {
        var progressLine = horizontalBar.get('children')[1];
        progressLine.attr({
          x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),
          x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x)
        });
      } else {
        horizontalBar = backPlot.addGroup({
          className: 'horizontalBar'
        });
        horizontalBar.addShape('line', {
          attrs: {
            x1: plotRange.bl.x + offsetX,
            y1: yPos,
            x2: plotRange.br.x + offsetX,
            y2: yPos,
            lineWidth: size,
            stroke: backgroundColor,
            lineCap: lineCap
          }
        });
        horizontalBar.addShape('line', {
          attrs: {
            x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),
            y1: yPos,
            x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x),
            y2: yPos,
            lineWidth: size,
            stroke: fillerColor,
            lineCap: lineCap
          }
        });
        chart.set('_horizontalBar', horizontalBar);
      }
    }

    if (type.indexOf('Y') > -1) {
      var _scrollBarCfg$yStyle = scrollBarCfg.yStyle,
          _offsetX = _scrollBarCfg$yStyle.offsetX,
          _offsetY = _scrollBarCfg$yStyle.offsetY,
          _lineCap = _scrollBarCfg$yStyle.lineCap,
          _backgroundColor = _scrollBarCfg$yStyle.backgroundColor,
          _fillerColor = _scrollBarCfg$yStyle.fillerColor,
          _size = _scrollBarCfg$yStyle.size;
      var yScale = chart.getYScales()[0];
      var yLimitRange = limitRange[yScale.field];

      if (!yLimitRange) {
        yLimitRange = getLimitRange(data, yScale);
        limitRange[yScale.field] = yLimitRange;
      }

      var _currentRange = getFieldRange(yScale, yLimitRange, yScale.type);

      var verticalBar = chart.get('_verticalBar');
      var xPos = _size / 2 + _offsetX;

      if (verticalBar) {
        var _progressLine = verticalBar.get('children')[1];

        _progressLine.attr({
          y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),
          y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y)
        });
      } else {
        verticalBar = backPlot.addGroup({
          className: 'verticalBar'
        });
        verticalBar.addShape('line', {
          attrs: {
            x1: xPos,
            y1: plotRange.tl.y + _offsetY,
            x2: xPos,
            y2: plotRange.bl.y + _offsetY,
            lineWidth: _size,
            stroke: _backgroundColor,
            lineCap: _lineCap
          }
        });
        verticalBar.addShape('line', {
          attrs: {
            x1: xPos,
            y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),
            x2: xPos,
            y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y),
            lineWidth: _size,
            stroke: _fillerColor,
            lineCap: _lineCap
          }
        });
        chart.set('_verticalBar', verticalBar);
      }
    }
  };

  function ScrollBar(cfg, chart) {
    var _this;

    _this = _Interaction.call(this, cfg, chart) || this;

    var defaultCfg = _this.getDefaultCfg();

    chart.set('_scrollBarCfg', Util.deepMix({}, defaultCfg, cfg));
    chart.set('_limitRange', {});

    if (!chart.get('_horizontalBar') && !chart.get('_verticalBar')) {
      _this._renderScrollBars();
    }

    return _this;
  }

  _proto._clear = function _clear() {
    var chart = this.chart;

    if (chart) {
      var hBar = chart.get('_horizontalBar');
      var vBar = chart.get('_verticalBar');
      hBar && hBar.remove(true);
      vBar && vBar.remove(true);
      chart.set('_horizontalBar', null);
      chart.set('_verticalBar', null);
    }
  };

  _proto._bindEvents = function _bindEvents() {
    this._onAfterclearOrBeforechangedata = this._onAfterclearOrBeforechangedata.bind(this);
    this._onAfterclearinner = this._onAfterclearinner.bind(this);
    this._onAfterdrawgeoms = this._onAfterdrawgeoms.bind(this);
    var chart = this.chart;
    chart.on('afterclear', this._onAfterclearOrBeforechangedata);
    chart.on('beforechangedata', this._onAfterclearOrBeforechangedata);
    chart.on('afterclearinner', this._onAfterclearinner);
    chart.on('afterdrawgeoms', this._onAfterdrawgeoms);
  };

  _proto._onAfterclearOrBeforechangedata = function _onAfterclearOrBeforechangedata() {
    this.chart && this.chart.set('_limitRange', {});
  };

  _proto._onAfterclearinner = function _onAfterclearinner() {
    this._clear();
  };

  _proto._onAfterdrawgeoms = function _onAfterdrawgeoms() {
    this._renderScrollBars();
  };

  _proto._clearEvents = function _clearEvents() {
    var chart = this.chart;

    if (chart) {
      chart.off('afterclear', this._onAfterclearOrBeforechangedata);
      chart.off('beforechangedata', this._onAfterclearOrBeforechangedata);
      chart.off('afterclearinner', this._onAfterclearinner);
      chart.off('afterdrawgeoms', this._onAfterdrawgeoms);
    }
  };

  _proto.destroy = function destroy() {
    this._clearEvents();

    this._clear();

    this.canvas.draw();
  };

  return ScrollBar;
}(Interaction);

module.exports = ScrollBar;

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Interaction = __webpack_require__(28);

function getOriginalAttrs(attrs, styles) {
  var origin = {};

  for (var style in styles) {
    origin[style] = attrs[style];
  }

  return origin;
}

var Select = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(Select, _Interaction);

  function Select() {
    return _Interaction.apply(this, arguments) || this;
  }

  var _proto = Select.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var defaultCfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, defaultCfg, {
      startEvent: 'mouseup',
      processEvent: null,
      selectStyle: {
        fillOpacity: 1
      },
      unSelectStyle: {
        fillOpacity: 0.1
      },
      cancelable: true
    });
  };

  _proto.start = function start(ev) {
    var self = this;
    var chart = self.view;
    var selectedShape;
    var unSelectedShapes = [];
    chart.eachShape(function (obj, shape) {
      if (shape.isPointInPath(ev.x, ev.y)) {
        selectedShape = shape;
      } else {
        unSelectedShapes.push(shape);
      }
    });

    if (!selectedShape) {
      self.reset();
      return;
    }

    if (selectedShape.get('_selected')) {
      // 宸茬粡琚€変腑
      if (!self.cancelable) {
        // 涓嶅厑璁稿彇娑堥€変腑鍒欎笉澶勭悊
        return;
      }

      self.reset(); // 鍏佽鍙栨秷閫変腑
    } else {
      // 鏈閫変腑
      var selectStyle = self.selectStyle,
          unSelectStyle = self.unSelectStyle; // 鑾峰彇閫変腑鏁堟灉瀵瑰簲鐨勬湰鏉ユ晥鏋�,淇濆瓨涓嬫潵

      var originAttrs = getOriginalAttrs(selectedShape.attr(), selectedShape);
      selectedShape.set('_originAttrs', originAttrs);
      selectedShape.attr(selectStyle);
      Util.each(unSelectedShapes, function (child) {
        var originAttrs = child.get('_originAttrs'); // 鍏堟仮澶嶅埌榛樿鐘舵€佷笅

        if (originAttrs) {
          child.attr(originAttrs);
        }

        child.set('_selected', false); // 淇濆瓨鏈€変腑鏁堟灉瀵瑰簲鐨勫師濮嬫晥鏋�

        if (unSelectStyle) {
          originAttrs = getOriginalAttrs(child.attr(), unSelectStyle);
          child.set('_originAttrs', originAttrs);
          child.attr(unSelectStyle);
        }
      });
      selectedShape.set('_selected', true);
      self.selectedShape = selectedShape;
      self.canvas.draw();
    }
  };

  _proto.end = function end(ev) {
    var selectedShape = this.selectedShape;

    if (selectedShape && !selectedShape.get('destroyed') && selectedShape.get('origin')) {
      ev.data = selectedShape.get('origin')._origin; // 缁樺埗鏁版嵁锛屽寘鍚師濮嬫暟鎹晩

      ev.shapeInfo = selectedShape.get('origin');
      ev.shape = selectedShape;
      ev.selected = !!selectedShape.get('_selected'); // 杩斿洖閫変腑鐨勭姸鎬�
    }
  };

  _proto.reset = function reset() {
    var self = this;

    if (!self.selectedShape) {
      return;
    }

    var chart = self.view;
    var geom = chart.get('geoms')[0];
    var container = geom.get('container').get('children')[0];
    var children = container.get('children');
    Util.each(children, function (child) {
      var originAttrs = child.get('_originAttrs');

      if (originAttrs) {
        child._attrs = originAttrs;
        child.set('_originAttrs', null);
      }

      child.set('_selected', false);
    });
    self.canvas.draw();
  };

  return Select;
}(Interaction);

module.exports = Select;

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Range = __webpack_require__(318);

var Chart = __webpack_require__(44);

var Util = __webpack_require__(0);

var G = __webpack_require__(16);

var Global = __webpack_require__(5);

var Interaction = __webpack_require__(28);

var getColDef = __webpack_require__(71);

var getColDefs = __webpack_require__(72);

var Canvas = G.Canvas;
var DomUtil = Util.DomUtil,
    isNumber = Util.isNumber;

var Slider = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(Slider, _Interaction);

  var _proto = Slider.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      startEvent: null,
      processEvent: null,
      endEvent: null,
      resetEvent: null,
      height: 26,
      width: 'auto',
      // 榛樿鑷€傚簲
      padding: Global.plotCfg.padding,
      container: null,
      xAxis: null,
      yAxis: null,
      // 閫変腑鍖哄煙鐨勬牱寮�
      fillerStyle: {
        fill: '#BDCCED',
        fillOpacity: 0.3
      },
      // 婊戝姩鏉¤儗鏅牱寮�
      backgroundStyle: {
        stroke: '#CCD6EC',
        fill: '#CCD6EC',
        fillOpacity: 0.3,
        lineWidth: 1
      },
      range: [0, 100],
      layout: 'horizontal',
      // 鏂囨湰棰滆壊
      textStyle: {
        fill: '#545454'
      },
      // 婊戝潡鐨勬牱寮�
      handleStyle: {
        img: 'https://gw.alipayobjects.com/zos/rmsportal/QXtfhORGlDuRvLXFzpsQ.png',
        width: 5
      },
      // 鑳屾櫙鍥捐〃鐨勯厤缃紝濡傛灉涓� false 鍒欒〃绀轰笉娓叉煋
      backgroundChart: {
        type: ['area'],
        // 鍥捐〃鐨勭被鍨嬶紝鍙互鏄瓧绗︿覆涔熷彲鏄槸鏁扮粍
        color: '#CCD6EC'
      }
    });
  };

  _proto._initContainer = function _initContainer() {
    var me = this;
    var container = me.container;

    if (!container) {
      throw new Error('Please specify the container for the Slider!');
    }

    if (Util.isString(container)) {
      me.domContainer = document.getElementById(container);
    } else {
      me.domContainer = container;
    }
  };

  _proto.forceFit = function forceFit() {
    var me = this;

    if (!me || me.destroyed) {
      return;
    }

    var width = DomUtil.getWidth(me.domContainer);
    var height = me.height;

    if (width !== me.domWidth) {
      var canvas = me.canvas;
      canvas.changeSize(width, height); // 鏀瑰彉鐢诲竷灏哄

      me.bgChart && me.bgChart.changeWidth(width);
      canvas.clear();

      me._initWidth();

      me._initSlider(); // 鍒濆鍖栨粦鍔ㄦ潯


      me._bindEvent();

      canvas.draw();
    }
  };

  _proto._initForceFitEvent = function _initForceFitEvent() {
    var me = this;
    var timer = setTimeout(Util.wrapBehavior(me, 'forceFit'), 200);
    clearTimeout(me.resizeTimer);
    me.resizeTimer = timer;
  };

  _proto._initStyle = function _initStyle() {
    var me = this;
    me.handleStyle = Util.mix({
      width: me.height,
      height: me.height
    }, me.handleStyle);

    if (me.width === 'auto') {
      // 瀹藉害鑷€傚簲
      window.addEventListener('resize', Util.wrapBehavior(me, '_initForceFitEvent'));
    }
  };

  _proto._initWidth = function _initWidth() {
    var me = this;
    var width;

    if (me.width === 'auto') {
      width = DomUtil.getWidth(me.domContainer);
    } else {
      width = me.width;
    }

    me.domWidth = width;
    var padding = Util.toAllPadding(me.padding);

    if (me.layout === 'horizontal') {
      me.plotWidth = width - padding[1] - padding[3];
      me.plotPadding = padding[3];
      me.plotHeight = me.height;
    } else if (me.layout === 'vertical') {
      me.plotWidth = me.width;
      me.plotHeight = me.height - padding[0] - padding[2];
      me.plotPadding = padding[0];
    }
  };

  _proto._initCanvas = function _initCanvas() {
    var me = this;
    var width = me.domWidth;
    var height = me.height;
    var canvas = new Canvas({
      width: width,
      height: height,
      containerDOM: me.domContainer,
      capture: false
    });
    var node = canvas.get('el');
    node.style.position = 'absolute';
    node.style.top = 0;
    node.style.left = 0;
    node.style.zIndex = 3;
    me.canvas = canvas;
  };

  _proto._initBackground = function _initBackground() {
    var _Util$deepMix;

    var me = this;
    var chart = this.chart;
    var geom = chart.getAllGeoms[0];
    var data = me.data = me.data || chart.get('data');
    var xScale = chart.getXScale();
    var xAxis = me.xAxis || xScale.field;
    var yAxis = me.yAxis || chart.getYScales()[0].field;
    var scales = Util.deepMix((_Util$deepMix = {}, _Util$deepMix["" + xAxis] = {
      range: [0, 1]
    }, _Util$deepMix), getColDefs(chart), me.scales); // 鐢ㄦ埛鍒楀畾涔�

    delete scales[xAxis].min;
    delete scales[xAxis].max;

    if (!data) {
      // 娌℃湁鏁版嵁锛屽垯涓嶅垱寤�
      throw new Error('Please specify the data!');
    }

    if (!xAxis) {
      throw new Error('Please specify the xAxis!');
    }

    if (!yAxis) {
      throw new Error('Please specify the yAxis!');
    }

    var backgroundChart = me.backgroundChart;
    var type = backgroundChart.type || geom.get('type');
    var color = backgroundChart.color || 'grey';
    var shape = backgroundChart.shape;

    if (!Util.isArray(type)) {
      type = [type];
    }

    var padding = Util.toAllPadding(me.padding);
    var bgChart = new Chart({
      container: me.container,
      width: me.domWidth,
      height: me.height,
      padding: [0, padding[1], 0, padding[3]],
      animate: false
    });
    bgChart.source(data);
    bgChart.scale(scales);
    bgChart.axis(false);
    bgChart.tooltip(false);
    bgChart.legend(false);
    Util.each(type, function (eachType, index) {
      var bgGeom = bgChart[eachType]().position(xAxis + '*' + yAxis).opacity(1);
      var colorItem = Util.isArray(color) ? color[index] : color;

      if (colorItem) {
        if (Util.isObject(colorItem)) {
          // 閫氳繃 { field: 'ss', colors: [ ] } 鐨勬柟寮忕敵鏄巆olor
          if (colorItem.field) {
            bgGeom.color(colorItem.field, colorItem.colors);
          }
        } else {
          bgGeom.color(colorItem);
        }
      }

      var shapeItem = Util.isArray(shape) ? shape[index] : shape;

      if (shapeItem) {
        if (Util.isObject(shapeItem)) {
          // 閫氳繃 { field: 'ss', shapes: [ ], callback } 鐨勬柟寮忕敵鏄巗hape
          if (shapeItem.field) {
            bgGeom.shape(shapeItem.field, shapeItem.callback || shapeItem.shapes);
          }
        } else {
          bgGeom.shape(shapeItem);
        }
      }
    });
    bgChart.render();
    me.bgChart = bgChart;
    me.scale = me.layout === 'horizontal' ? bgChart.getXScale() : bgChart.getYScales()[0];

    if (me.layout === 'vertical') {
      bgChart.destroy();
    }
  };

  _proto._initRange = function _initRange() {
    var me = this;
    var startRadio = me.startRadio;
    var endRadio = me.endRadio;
    var start = me._startValue;
    var end = me._endValue;
    var scale = me.scale;
    var min = 0;
    var max = 1; // startRadio 浼樺厛绾ч珮浜� start

    if (isNumber(startRadio)) {
      min = startRadio;
    } else if (start) {
      min = scale.scale(scale.translate(start));
    } // endRadio 浼樺厛绾ч珮浜� end


    if (isNumber(endRadio)) {
      max = endRadio;
    } else if (end) {
      max = scale.scale(scale.translate(end));
    }

    var minSpan = me.minSpan,
        maxSpan = me.maxSpan;
    var totalSpan = 0;

    if (scale.type === 'time' || scale.type === 'timeCat') {
      // 鏃堕棿绫诲瀷宸叉帓搴�
      var values = scale.values;
      var firstValue = values[0];
      var lastValue = values[values.length - 1];
      totalSpan = lastValue - firstValue;
    } else if (scale.isLinear) {
      totalSpan = scale.max - scale.min;
    }

    if (totalSpan && minSpan) {
      me.minRange = minSpan / totalSpan * 100;
    }

    if (totalSpan && maxSpan) {
      me.maxRange = maxSpan / totalSpan * 100;
    }

    var range = [min * 100, max * 100];
    me.range = range;
    return range;
  };

  _proto._getHandleValue = function _getHandleValue(type) {
    var me = this;
    var value;
    var range = me.range;
    var min = range[0] / 100;
    var max = range[1] / 100;
    var scale = me.scale;

    if (type === 'min') {
      value = me._startValue ? me._startValue : scale.invert(min);
    } else {
      value = me._endValue ? me._endValue : scale.invert(max);
    }

    return value;
  };

  _proto._initSlider = function _initSlider() {
    var me = this;
    var canvas = me.canvas;

    var range = me._initRange();

    var scale = me.scale;
    var rangeElement = canvas.addGroup(Range, {
      middleAttr: me.fillerStyle,
      range: range,
      minRange: me.minRange,
      maxRange: me.maxRange,
      layout: me.layout,
      width: me.plotWidth,
      height: me.plotHeight,
      backgroundStyle: me.backgroundStyle,
      textStyle: me.textStyle,
      handleStyle: me.handleStyle,
      minText: scale.getText(me._getHandleValue('min')),
      maxText: scale.getText(me._getHandleValue('max'))
    });

    if (me.layout === 'horizontal') {
      rangeElement.translate(me.plotPadding, 0);
    } else if (me.layout === 'vertical') {
      rangeElement.translate(0, me.plotPadding);
    }

    me.rangeElement = rangeElement;
  };

  _proto._updateElement = function _updateElement(minRatio, maxRatio) {
    var me = this;
    var chart = me.chart,
        scale = me.scale,
        rangeElement = me.rangeElement;
    var field = scale.field;
    var minTextElement = rangeElement.get('minTextElement');
    var maxTextElement = rangeElement.get('maxTextElement');
    var min = scale.invert(minRatio);
    var max = scale.invert(maxRatio);
    var minText = scale.getText(min);
    var maxText = scale.getText(max);
    minTextElement.attr('text', minText);
    maxTextElement.attr('text', maxText);
    me._startValue = minText;
    me._endValue = maxText;

    if (me.onChange) {
      me.onChange({
        startText: minText,
        endText: maxText,
        startValue: min,
        endValue: max,
        startRadio: minRatio,
        endRadio: maxRatio
      });
    }

    chart.scale(field, Util.mix({}, getColDef(chart, field), {
      nice: false,
      min: min,
      max: max
    }));
    chart.repaint();
  };

  _proto._bindEvent = function _bindEvent() {
    var me = this;
    var rangeElement = me.rangeElement;
    rangeElement.on('sliderchange', function (ev) {
      var range = ev.range;
      var minRatio = range[0] / 100;
      var maxRatio = range[1] / 100;

      me._updateElement(minRatio, maxRatio);
    });
  };

  function Slider(cfg, chart) {
    var _this;

    _this = _Interaction.call(this, cfg, chart) || this;

    var me = _assertThisInitialized(_this);

    me._initContainer();

    me._initStyle();

    me.render();
    return _this;
  }

  _proto.clear = function clear() {
    var me = this;
    me.canvas.clear();
    me.bgChart && me.bgChart.destroy();
    me.bgChart = null;
    me.scale = null;
    me.canvas.draw();
  };

  _proto.repaint = function repaint() {
    var me = this;
    me.clear();
    me.render();
  };

  _proto.render = function render() {
    var me = this;

    me._initWidth();

    me._initCanvas();

    me._initBackground();

    me._initSlider();

    me._bindEvent();

    me.canvas.draw();
  };

  _proto.destroy = function destroy() {
    var me = this;
    clearTimeout(me.resizeTimer);
    var rangeElement = me.rangeElement;
    rangeElement.off('sliderchange');
    me.bgChart && me.bgChart.destroy();
    me.canvas.destroy();
    var container = me.domContainer;

    while (container.hasChildNodes()) {
      container.removeChild(container.firstChild);
    }

    window.removeEventListener('resize', Util.getWrapBehavior(me, '_initForceFitEvent'));
    me.destroyed = true;
  };

  return Slider;
}(Interaction);

module.exports = Slider;

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Util = __webpack_require__(0);

var Interaction = __webpack_require__(28);

var getColDef = __webpack_require__(71);

var getLimitRange = __webpack_require__(73);

var ZOOMING_TYPES = ['X', 'Y', 'XY'];
var DEFAULT_TYPE = 'X';

var Zoom = /*#__PURE__*/function (_Interaction) {
  _inheritsLoose(Zoom, _Interaction);

  var _proto = Zoom.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      processEvent: 'mousewheel',
      type: DEFAULT_TYPE,
      stepRatio: 0.05,
      stepByField: {},
      minScale: 1,
      maxScale: 4,
      catStep: 2,
      limitRange: {},
      originScaleDefsByField: {}
    });
  };

  function Zoom(cfg, chart) {
    var _this;

    _this = _Interaction.call(this, cfg, chart) || this;

    var me = _assertThisInitialized(_this);

    me.chart = chart;
    me.type = me.type.toUpperCase();
    var data = me.data = chart.get('data');
    var scales = chart.getYScales();
    var xScale = chart.getXScale();
    scales.push(xScale);
    var scaleController = chart.get('scaleController');
    scales.forEach(function (scale) {
      var field = scale.field;
      var def = scaleController.defs[field] || {};
      me.limitRange[field] = getLimitRange(data, scale);
      me.originScaleDefsByField[field] = Util.mix(def, {
        nice: !!def.nice
      });

      if (scale.isLinear) {
        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
      } else {
        me.stepByField[field] = me.catStep;
      }
    });

    if (!ZOOMING_TYPES.includes(me.type)) {
      me.type = DEFAULT_TYPE;
    }

    return _this;
  } // onZoom() { }
  // onZoomin() { }
  // onZoomout() { }


  _proto._applyScale = function _applyScale(scale, delta, minOffset, center) {
    if (minOffset === void 0) {
      minOffset = 0;
    }

    var me = this;
    var chart = me.chart,
        stepByField = me.stepByField;

    if (scale.isLinear) {
      var min = scale.min,
          max = scale.max,
          field = scale.field;
      var maxOffset = 1 - minOffset;
      var step = stepByField[field] * delta;
      var newMin = min + step * minOffset;
      var newMax = max - step * maxOffset;

      if (newMax > newMin) {
        var colDef = getColDef(chart, field); // @2019-02-28 by blue.lb 杩欓噷闇€瑕佸皢鍘熷scale鐨勯厤缃暣鍚堟柊绠楀嚭鐨勬渶澶у強鏈€灏忓€�

        chart.scale(field, Util.mix({}, colDef, {
          nice: false,
          min: newMin,
          max: newMax
        }));
      }
    } else {
      var _field = scale.field,
          values = scale.values;
      var _chart = me.chart;

      var coord = _chart.get('coord');

      var _colDef = getColDef(_chart, _field);

      var originValues = me.limitRange[_field];
      var originValuesLen = originValues.length;
      var maxScale = me.maxScale;
      var minScale = me.minScale;
      var minCount = originValuesLen / maxScale;
      var maxCount = originValuesLen / minScale;
      var valuesLength = values.length;
      var offsetPoint = coord.invertPoint(center);
      var percent = offsetPoint.x;
      var deltaCount = valuesLength - delta * this.catStep;
      var minDelta = parseInt(deltaCount * percent);
      var maxDelta = deltaCount + minDelta;

      if (delta > 0 && valuesLength >= minCount) {
        // zoom out
        var _min = minDelta;
        var _max = maxDelta;

        if (maxDelta > valuesLength) {
          _max = valuesLength - 1;
          _min = valuesLength - deltaCount;
        }

        var newValues = values.slice(_min, _max);

        _chart.scale(_field, Util.mix({}, _colDef, {
          values: newValues
        }));
      } else if (delta < 0 && valuesLength <= maxCount) {
        // zoom in
        var firstIndex = originValues.indexOf(values[0]);
        var lastIndex = originValues.indexOf(values[valuesLength - 1]);
        var minIndex = Math.max(0, firstIndex - minDelta);
        var maxIndex = Math.min(lastIndex + maxDelta, originValuesLen);

        var _newValues = originValues.slice(minIndex, maxIndex);

        _chart.scale(_field, Util.mix({}, _colDef, {
          values: _newValues
        }));
      }
    }
  };

  _proto.process = function process(ev) {
    var me = this;
    var chart = me.chart,
        type = me.type;
    var coord = chart.get('coord');
    var deltaY = ev.deltaY;
    var offsetPoint = coord.invertPoint(ev);

    if (deltaY) {
      me.onZoom && me.onZoom(deltaY, offsetPoint, me);

      if (deltaY > 0) {
        me.onZoomin && me.onZoomin(deltaY, offsetPoint, me);
      } else {
        me.onZoomout && me.onZoomout(deltaY, offsetPoint, me);
      }

      var delta = deltaY / Math.abs(deltaY);

      if (type.indexOf('X') > -1) {
        me._applyScale(chart.getXScale(), delta, offsetPoint.x, ev);
      }

      if (type.indexOf('Y') > -1) {
        var yScales = chart.getYScales();
        yScales.forEach(function (yScale) {
          me._applyScale(yScale, delta, offsetPoint.y, ev);
        });
      }
    }

    chart.repaint();
  };

  _proto.reset = function reset() {
    var me = this;
    var view = me.view,
        originScaleDefsByField = me.originScaleDefsByField;
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    scales.forEach(function (scale) {
      if (scale.isLinear) {
        var field = scale.field;
        view.scale(field, originScaleDefsByField[field]);
      }
    });
    view.repaint();
  };

  return Zoom;
}(Interaction); // G2.registerInteraction('zoom', Zoom);
// G2.registerInteraction('Zoom', Zoom);


module.exports = Zoom;

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var _html, _tooltip;

/**
 * @fileOverview G2 3.0 dark theme
 * @author sima.zhang
 */
var Util = __webpack_require__(0);

var BasicTheme = __webpack_require__(131); // tooltip 鐩稿叧 dom 鐨� css 绫诲悕


var TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';
var LEGEND_CONTAINER_CLASS = 'g2-legend';
var DarkTheme = Util.deepMix({}, BasicTheme, {
  background: {
    fill: '#1F1F1F',
    radius: 2
  },
  // 瀹瑰櫒鍖哄煙
  plotBackground: {
    fill: '#1F1F1F'
  },
  // 缁樺浘鍖哄煙
  axis: {
    top: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      line: {
        stroke: '#737373'
      },
      tickLine: {
        stroke: '#737373'
      }
    },
    bottom: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      line: {
        stroke: '#737373'
      },
      tickLine: {
        stroke: '#737373'
      }
    },
    left: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      grid: {
        lineStyle: {
          stroke: '#404040'
        }
      }
    },
    right: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      grid: {
        lineStyle: {
          stroke: '#404040'
        }
      }
    },
    circle: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      line: {
        stroke: '#737373'
      },
      tickLine: {
        stroke: '#737373'
      },
      grid: {
        lineStyle: {
          stroke: '#404040'
        }
      }
    },
    radius: {
      label: {
        textStyle: {
          fill: '#A6A6A6'
        }
      },
      line: {
        stroke: '#737373'
      },
      tickLine: {
        stroke: '#737373'
      },
      grid: {
        lineStyle: {
          stroke: '#404040'
        }
      }
    },
    helix: {
      line: {
        stroke: '#737373'
      },
      tickLine: {
        stroke: '#737373'
      }
    }
  },
  label: {
    textStyle: {
      fill: '#A6A6A6'
    }
  },
  legend: {
    right: {
      textStyle: {
        fill: '#737373'
      },
      unCheckColor: '#bfbfbf'
    },
    left: {
      textStyle: {
        fill: '#737373'
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    top: {
      textStyle: {
        fill: '#737373'
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    bottom: {
      textStyle: {
        fill: '#737373'
      },
      // 鍥句緥椤规枃鏈殑鏍峰紡
      unCheckColor: '#bfbfbf'
    },
    html: (_html = {}, _html["" + LEGEND_CONTAINER_CLASS] = {
      color: '#D9D9D9'
    }, _html),
    gradient: {
      textStyle: {
        fill: '#D9D9D9'
      },
      lineStyle: {
        stroke: '#404040'
      }
    }
  },
  tooltip: (_tooltip = {}, _tooltip["" + TOOLTIP_CONTAINER_CLASS] = {
    color: '#D9D9D9',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    boxShadow: '0px 0px 2px #000'
  }, _tooltip),
  tooltipCrosshairsRect: {
    type: 'rect',
    rectStyle: {
      fill: '#fff',
      opacity: 0.1
    }
  },
  // tooltip 杈呭姪鑳屾櫙妗嗘牱寮�
  tooltipCrosshairsLine: {
    lineStyle: {
      stroke: 'rgba(255, 255, 255, 0.45)'
    }
  },
  guide: {
    line: {
      text: {
        style: {
          fill: '#A6A6A6'
        }
      }
    },
    text: {
      style: {
        fill: '#A6A6A6'
      }
    },
    region: {
      // TODO
      style: {
        lineWidth: 0,
        // 杈呭姪妗嗙殑杈规瀹藉害
        fill: '#000',
        // 杈呭姪妗嗗～鍏呯殑棰滆壊
        fillOpacity: 0.04 // 杈呭姪妗嗙殑鑳屾櫙閫忔槑搴�

      } // 杈呭姪妗嗙殑鍥惧舰鏍峰紡灞炴€�

    }
  }
});
module.exports = DarkTheme;

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Event = __webpack_require__(135);

var Group = __webpack_require__(134);

var Timeline = __webpack_require__(332);

var renderers = __webpack_require__(337);

var Canvas = function Canvas(cfg) {
  Canvas.superclass.constructor.call(this, cfg);
};

Canvas.CFG = {
  eventEnable: true,

  /**
   * 鍍忕礌瀹藉害
   * @type {Number}
   */
  width: null,

  /**
   * 鍍忕礌楂樺害
   * @type {Number}
   */
  height: null,

  /**
   * 鐢诲竷瀹藉害
   * @type {Number}
   */
  widthCanvas: null,

  /**
   * 鐢诲竷楂樺害
   * @type {Number}
   */
  heightCanvas: null,

  /**
   * CSS瀹�
   * @type {String}
   */
  widthStyle: null,

  /**
   * CSS楂�
   * @type {String}
   */
  heightStyle: null,

  /**
   * 瀹瑰櫒DOM
   * @type {Object}
   */
  containerDOM: null,

  /**
   * 褰撳墠Canvas鐨凞OM
   * @type {Object}
   */
  canvasDOM: null,

  /**
   * 灞忓箷鍍忕礌姣�
   * @type {Number}
   */
  pixelRatio: null,

  /**
   * 娓叉煋鍣紝榛樿鏄痗anvas
   * @type {String}
   */
  renderer: 'canvas'
};
Util.extend(Canvas, Group);
Util.augment(Canvas, {
  init: function init() {
    Canvas.superclass.init.call(this);

    this._setGlobalParam();

    this._setContainer();

    this._initPainter();

    this._scale();

    if (this.get('eventEnable')) {
      this._registEvents();
    }
  },
  getEmitter: function getEmitter(element, event) {
    if (element) {
      if (Util.isEmpty(element._getEvents())) {
        var parent = element.get('parent');

        if (parent && !event.propagationStopped) {
          return this.getEmitter(parent, event);
        }
      } else {
        return element;
      }
    }
  },
  _getEventObj: function _getEventObj(type, e, point, target) {
    var event = new Event(type, e, true, true);
    event.x = point.x;
    event.y = point.y;
    event.clientX = e.clientX;
    event.clientY = e.clientY;
    event.currentTarget = target;
    event.target = target;
    return event;
  },
  _triggerEvent: function _triggerEvent(type, e) {
    var point = this.getPointByClient(e.clientX, e.clientY);
    var shape = this.getShape(point.x, point.y, e);
    var el = this.get('el');
    var emitObj;

    if (type === 'mousemove') {
      var preShape = this.get('preShape');

      if (preShape && preShape !== shape) {
        var mouseleave = this._getEventObj('mouseleave', e, point, preShape);

        emitObj = this.getEmitter(preShape, e);
        emitObj && emitObj.emit('mouseleave', mouseleave);
        el.style.cursor = 'default';
      }

      if (shape) {
        var mousemove = this._getEventObj('mousemove', e, point, shape);

        emitObj = this.getEmitter(shape, e);
        emitObj && emitObj.emit('mousemove', mousemove);

        if (preShape !== shape) {
          var mouseenter = this._getEventObj('mouseenter', e, point, shape);

          emitObj && emitObj.emit('mouseenter', mouseenter, e);
        }
      } else {
        var canvasmousemove = this._getEventObj('mousemove', e, point, this);

        this.emit('mousemove', canvasmousemove);
      }

      this.set('preShape', shape);
    } else {
      var event = this._getEventObj(type, e, point, shape || this);

      emitObj = this.getEmitter(shape, e);

      if (emitObj && emitObj !== this) {
        emitObj.emit(type, event);
      }

      this.emit(type, event);
    }

    if (shape && !shape.get('destroyed')) {
      el.style.cursor = shape.attr('cursor') || 'default';
    }
  },
  _registEvents: function _registEvents() {
    var self = this;
    var el = self.get('el');
    var events = ['mouseout', 'mouseover', 'mousemove', 'mousedown', 'mouseleave', 'mouseup', 'click', 'dblclick'];
    Util.each(events, function (event) {
      el.addEventListener(event, function (e) {
        self._triggerEvent(event, e);
      }, false);
    }); // special cases

    el.addEventListener('touchstart', function (e) {
      if (!Util.isEmpty(e.touches)) {
        self._triggerEvent('touchstart', e.touches[0]);
      }
    }, false);
    el.addEventListener('touchmove', function (e) {
      if (!Util.isEmpty(e.touches)) {
        self._triggerEvent('touchmove', e.touches[0]);
      }
    }, false);
    el.addEventListener('touchend', function (e) {
      if (!Util.isEmpty(e.changedTouches)) {
        self._triggerEvent('touchend', e.changedTouches[0]);
      }
    }, false);
  },
  _scale: function _scale() {
    var pixelRatio = this.get('pixelRatio');
    this.scale(pixelRatio, pixelRatio);
  },
  _setGlobalParam: function _setGlobalParam() {
    var pixelRatio = this.get('pixelRatio');

    if (!pixelRatio) {
      this.set('pixelRatio', Util.getRatio());
    }

    var renderer = renderers[this.get('renderer') || 'canvas'];
    this._cfg.renderer = renderer;
    this._cfg.canvas = this;
    var timeline = new Timeline(this);
    this._cfg.timeline = timeline;
  },
  _setContainer: function _setContainer() {
    var containerId = this.get('containerId');
    var containerDOM = this.get('containerDOM');

    if (!containerDOM) {
      containerDOM = document.getElementById(containerId);
      this.set('containerDOM', containerDOM);
    }

    Util.modifyCSS(containerDOM, {
      position: 'relative'
    });
  },
  _initPainter: function _initPainter() {
    var containerDOM = this.get('containerDOM');
    var painter = new this._cfg.renderer.painter(containerDOM);
    this._cfg.painter = painter;
    this._cfg.canvasDOM = this._cfg.el = painter.canvas;
    this.changeSize(this.get('width'), this.get('height'));
  },
  _resize: function _resize() {
    var canvasDOM = this.get('canvasDOM');
    var widthCanvas = this.get('widthCanvas');
    var heightCanvas = this.get('heightCanvas');
    var widthStyle = this.get('widthStyle');
    var heightStyle = this.get('heightStyle');
    canvasDOM.style.width = widthStyle;
    canvasDOM.style.height = heightStyle;
    canvasDOM.setAttribute('width', widthCanvas);
    canvasDOM.setAttribute('height', heightCanvas);
  },
  getWidth: function getWidth() {
    var pixelRatio = this.get('pixelRatio');
    var width = this.get('width');
    return width * pixelRatio;
  },
  getHeight: function getHeight() {
    var pixelRatio = this.get('pixelRatio');
    var height = this.get('height');
    return height * pixelRatio;
  },
  changeSize: function changeSize(width, height) {
    var pixelRatio = this.get('pixelRatio');
    var widthCanvas = width * pixelRatio;
    var heightCanvas = height * pixelRatio;
    this.set('widthCanvas', widthCanvas);
    this.set('heightCanvas', heightCanvas);
    this.set('widthStyle', width + 'px');
    this.set('heightStyle', height + 'px');
    this.set('width', width);
    this.set('height', height);

    this._resize();
  },

  /**
   * 灏嗙獥鍙ｅ潗鏍囪浆鍙樻垚 canvas 鍧愭爣
   * @param  {Number} clientX 绐楀彛x鍧愭爣
   * @param  {Number} clientY 绐楀彛y鍧愭爣
   * @return {Object} canvas鍧愭爣
   */
  getPointByClient: function getPointByClient(clientX, clientY) {
    var el = this.get('el');
    var pixelRatio = this.get('pixelRatio') || 1;
    var bbox = el.getBoundingClientRect();
    return {
      x: (clientX - bbox.left) * pixelRatio,
      y: (clientY - bbox.top) * pixelRatio
    };
  },
  getClientByPoint: function getClientByPoint(x, y) {
    var el = this.get('el');
    var bbox = el.getBoundingClientRect();
    var pixelRatio = this.get('pixelRatio') || 1;
    return {
      clientX: x / pixelRatio + bbox.left,
      clientY: y / pixelRatio + bbox.top
    };
  },
  draw: function draw() {
    this._cfg.painter.draw(this);
  },
  getShape: function getShape(x, y, e) {
    if (arguments.length === 3 && this._cfg.renderer.getShape) {
      return this._cfg.renderer.getShape.call(this, x, y, e);
    }

    return Canvas.superclass.getShape.call(this, x, y);
  },
  _drawSync: function _drawSync() {
    this._cfg.painter.drawSync(this);
  },
  destroy: function destroy() {
    var cfg = this._cfg;
    var containerDOM = cfg.containerDOM;
    var canvasDOM = cfg.canvasDOM;

    if (canvasDOM && containerDOM) {
      containerDOM.removeChild(canvasDOM);
    }

    cfg.timeline.stop();
    Canvas.superclass.destroy.call(this);
  }
});
module.exports = Canvas;

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var ReservedProps = {
  delay: 'delay',
  rotate: 'rotate'
};
var colorRalaredProps = {
  fill: 'fill',
  stroke: 'stroke',
  fillStyle: 'fillStyle',
  strokeStyle: 'strokeStyle'
};

function getFromAttrs(toAttrs, shape) {
  var rst = {};
  var attrs = shape._attrs;

  for (var k in toAttrs.attrs) {
    rst[k] = attrs[k];
  }

  return rst;
}

function getFormatProps(props, shape) {
  var rst = {
    matrix: null,
    attrs: {}
  };
  var attrs = shape._attrs;

  for (var k in props) {
    if (k === 'transform') {
      rst.matrix = Util.transform(shape.getMatrix(), props[k]);
    } else if (k === 'rotate') {
      rst.matrix = Util.transform(shape.getMatrix(), [['r', props[k]]]);
    } else if (k === 'matrix') {
      rst.matrix = props[k];
    } else if (colorRalaredProps[k] && /^[r,R,L,l]{1}[\s]*\(/.test(props[k])) {
      // 娓愬彉鑹蹭笉鏀寔鍔ㄧ敾
      continue;
    } else if (!ReservedProps[k] && attrs[k] !== props[k]) {
      rst.attrs[k] = props[k];
    }
  }

  return rst;
}

function checkExistedAttrs(animators, animator) {
  var delay = animator.delay;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  Util.each(animator.toAttrs, function (v, k) {
    Util.each(animators, function (animator) {
      if (delay < animator.startTime + animator.duration) {
        if (hasOwnProperty.call(animator.toAttrs, k)) {
          delete animator.toAttrs[k];
          delete animator.fromAttrs[k];
        }
      }
    });
  });

  if (animator.toMatrix) {
    Util.each(animators, function (animator) {
      if (delay < animator.startTime + animator.duration && animator.toMatrix) {
        delete animator.toMatrix;
      }
    });
  }

  return animators;
}

module.exports = {
  /**
   * 鎵ц鍔ㄧ敾
   * @param  {Object}   toProps  鍔ㄧ敾鏈€缁堢姸鎬�
   * @param  {Number}   duration 鍔ㄧ敾鎵ц鏃堕棿
   * @param  {String}   easing   鍔ㄧ敾缂撳姩鏁堟灉
   * @param  {Function} callback 鍔ㄧ敾鎵ц鍚庣殑鍥炶皟
   * @param  {Number}   delay    鍔ㄧ敾寤惰繜鏃堕棿
   */
  animate: function animate(toProps, duration, easing, callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    var self = this;
    self.set('animating', true);
    var timeline = self.get('timeline');

    if (!timeline) {
      timeline = self.get('canvas').get('timeline');
      self.setSilent('timeline', timeline);
    }

    var animators = self.get('animators') || []; // 鍒濆鍖杢ick

    if (!timeline._timer) {
      timeline.initTimer();
    }

    if (Util.isNumber(callback)) {
      delay = callback;
      callback = null;
    }

    if (Util.isFunction(easing)) {
      callback = easing;
      easing = 'easeLinear';
    } else {
      easing = easing ? easing : 'easeLinear';
    }

    var formatProps = getFormatProps(toProps, self); // 璁板綍鍔ㄧ敾灞炴€�

    var animator = {
      fromAttrs: getFromAttrs(formatProps, self),
      toAttrs: formatProps.attrs,
      fromMatrix: Util.clone(self.getMatrix()),
      toMatrix: formatProps.matrix,
      duration: duration,
      easing: easing,
      callback: callback,
      delay: delay,
      startTime: timeline.getTime(),
      id: Util.uniqueId()
    }; // 濡傛灉鍔ㄧ敾闃熷垪涓凡缁忔湁杩欎釜鍥惧舰浜�

    if (animators.length > 0) {
      // 鍏堟鏌ユ槸鍚﹂渶瑕佸悎骞跺睘鎬с€傝嫢鏈夌浉鍚岀殑鍔ㄧ敾锛屽皢璇ュ睘鎬т粠鍓嶄竴涓姩鐢讳腑鍒犻櫎,鐩存帴鐢ㄥ悗涓€涓姩鐢讳腑
      animators = checkExistedAttrs(animators, animator);
    } else {
      // 鍚﹀垯灏嗗浘褰㈡坊鍔犲埌闃熷垪
      timeline.addAnimator(self);
    }

    animators.push(animator);
    self.setSilent('animators', animators);
    self.setSilent('pause', {
      isPaused: false
    });
  },
  stopAnimate: function stopAnimate() {
    var _this = this;

    var animators = this.get('animators'); // 灏嗗姩鐢绘墽琛屽埌鏈€鍚庝竴甯э紝鎵ц鍥炶皟

    Util.each(animators, function (animator) {
      _this.attr(animator.toAttrs);

      if (animator.toMatrix) {
        _this.attr('matrix', animator.toMatrix);
      }

      if (animator.callback) {
        animator.callback();
      }
    });
    this.setSilent('animating', false);
    this.setSilent('animators', []);
  },
  pauseAnimate: function pauseAnimate() {
    var self = this;
    var timeline = self.get('timeline'); // 璁板綍涓嬫槸鍦ㄤ粈涔堟椂鍊欐殏鍋滅殑

    self.setSilent('pause', {
      isPaused: true,
      pauseTime: timeline.getTime()
    });
    return self;
  },
  resumeAnimate: function resumeAnimate() {
    var self = this;
    var timeline = self.get('timeline');
    var current = timeline.getTime();
    var animators = self.get('animators');
    var pauseTime = self.get('pause').pauseTime; // 涔嬪悗鏇存柊灞炴€ч渶瑕佽绠楀姩鐢诲凡缁忔墽琛岀殑鏃堕暱锛屽鏋滄殏鍋滀簡锛屽氨鎶婂垵濮嬫椂闂磋皟鍚�

    Util.each(animators, function (animator) {
      animator.startTime = animator.startTime + (current - pauseTime);
      animator._paused = false;
      animator._pauseTime = null;
    });
    self.setSilent('pause', {
      isPaused: false
    });
    self.setSilent('animators', animators);
    return self;
  }
};

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

module.exports = {
  canFill: false,
  canStroke: false,
  initAttrs: function initAttrs(attrs) {
    this._attrs = {
      opacity: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    };
    this.attr(Util.assign(this.getDefaultAttrs(), attrs));
    return this;
  },
  getDefaultAttrs: function getDefaultAttrs() {
    return {};
  },

  /**
   * 璁剧疆鎴栬€呰缃睘鎬э紝鏈変互涓� 4 绉嶆儏褰細
   *   - name 涓嶅瓨鍦�, 鍒欒繑鍥炲睘鎬ч泦鍚�
   *   - name 涓哄瓧绗︿覆锛寁alue 涓虹┖锛岃幏鍙栧睘鎬у€�
   *   - name 涓哄瓧绗︿覆锛寁alue 涓嶄负绌猴紝璁剧疆灞炴€у€硷紝杩斿洖 this
   *   - name 涓洪敭鍊煎锛寁alue 涓虹┖锛岃缃睘鎬у€�
   *
   * @param  {String | Object} name  灞炴€у悕
   * @param  {*} value 灞炴€у€�
   * @return {*} 灞炴€у€�
   */
  attr: function attr(name, value) {
    var self = this;

    if (arguments.length === 0) {
      return self._attrs;
    }

    if (Util.isObject(name)) {
      // self._attrs = Util.deepMix(self._attrs, name);
      for (var k in name) {
        this._setAttr(k, name[k]);
      }

      self.clearBBox();
      this._cfg.hasUpdate = true;
      return self;
    }

    if (arguments.length === 2) {
      this._setAttr(name, value);

      self.clearBBox();
      this._cfg.hasUpdate = true;
      return self;
    }

    return self._attrs[name];
  },
  _setAttr: function _setAttr(name, value) {
    var self = this;
    var attrs = this._attrs;
    attrs[name] = value;

    if (name === 'fill' || name === 'stroke') {
      attrs[name + 'Style'] = value;
      return;
    }

    if (name === 'opacity') {
      attrs.globalAlpha = value;
      return;
    }

    if (name === 'clip' && value) {
      self._setClip(value);

      return;
    }

    if (name === 'path' && self._afterSetAttrPath) {
      self._afterSetAttrPath(value);

      return;
    }

    if (name === 'transform') {
      self.transform(value);
      return;
    }

    if (name === 'rotate') {
      self.rotateAtStart(value);
    }
  },
  clearBBox: function clearBBox() {
    this.setSilent('box', null);
  },
  hasFill: function hasFill() {
    return this.canFill && this._attrs.fillStyle;
  },
  hasStroke: function hasStroke() {
    return this.canStroke && this._attrs.strokeStyle;
  },
  _setClip: function _setClip(item) {
    item._cfg.renderer = this._cfg.renderer;
    item._cfg.canvas = this._cfg.canvas;
    item._cfg.parent = this._cfg.parent;

    item.hasFill = function () {
      return true;
    };
  }
};

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var Inside = __webpack_require__(76);

var mathUtl = {
  arc: __webpack_require__(47),
  ellipse: __webpack_require__(143),
  line: __webpack_require__(48)
};
var canvas = Util.createDom('<canvas width="500" height="500"></canvas>');
var context = canvas.getContext('2d');

function isPointInPathByContext(x, y, ctx) {
  ctx.createPath(context);
  return context.isPointInPath(x, y);
}

var arc = function arc(x, y) {
  var attrs = this._attrs;
  var cx = attrs.x;
  var cy = attrs.y;
  var r = attrs.r,
      startAngle = attrs.startAngle,
      endAngle = attrs.endAngle,
      clockwise = attrs.clockwise;
  var lineWidth = this.getHitLineWidth();

  if (this.hasStroke()) {
    return Inside.arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y);
  }

  return false;
};

var circle = function circle(x, y) {
  var attrs = this._attrs;
  var cx = attrs.x;
  var cy = attrs.y;
  var r = attrs.r;
  var lineWidth = this.getHitLineWidth();
  var fill = this.hasFill();
  var stroke = this.hasStroke();

  if (fill && stroke) {
    return Inside.circle(cx, cy, r, x, y) || Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);
  }

  if (fill) {
    return Inside.circle(cx, cy, r, x, y);
  }

  if (stroke) {
    return Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);
  }

  return false;
};

var ellipse = function ellipse(x, y) {
  var attrs = this._attrs;
  var fill = this.hasFill();
  var stroke = this.hasStroke();
  var cx = attrs.x;
  var cy = attrs.y;
  var rx = attrs.rx;
  var ry = attrs.ry;
  var lineWidth = this.getHitLineWidth();
  var r = rx > ry ? rx : ry;
  var scaleX = rx > ry ? 1 : rx / ry;
  var scaleY = rx > ry ? ry / rx : 1;
  var p = [x, y, 1];
  var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  Util.mat3.scale(m, m, [scaleX, scaleY]);
  Util.mat3.translate(m, m, [cx, cy]);
  var inm = Util.mat3.invert([], m);
  Util.vec3.transformMat3(p, p, inm);

  if (fill && stroke) {
    return Inside.circle(0, 0, r, p[0], p[1]) || Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);
  }

  if (fill) {
    return Inside.circle(0, 0, r, p[0], p[1]);
  }

  if (stroke) {
    return Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);
  }

  return false;
};

var fan = function fan(x, y) {
  var self = this;
  var fill = self.hasFill();
  var stroke = self.hasStroke();
  var attrs = self._attrs;
  var cx = attrs.x;
  var cy = attrs.y;
  var rs = attrs.rs;
  var re = attrs.re;
  var startAngle = attrs.startAngle;
  var endAngle = attrs.endAngle;
  var clockwise = attrs.clockwise;
  var v1 = [1, 0];
  var subv = [x - cx, y - cy];
  var angle = Util.vec2.angleTo(v1, subv);

  function _isPointInFill() {
    var angle1 = mathUtl.arc.nearAngle(angle, startAngle, endAngle, clockwise);

    if (Util.isNumberEqual(angle, angle1)) {
      var ls = Util.vec2.squaredLength(subv);

      if (rs * rs <= ls && ls <= re * re) {
        return true;
      }
    }

    return false;
  }

  function _isPointInStroke() {
    var lineWidth = self.getHitLineWidth();
    var ssp = {
      x: Math.cos(startAngle) * rs + cx,
      y: Math.sin(startAngle) * rs + cy
    };
    var sep = {
      x: Math.cos(startAngle) * re + cx,
      y: Math.sin(startAngle) * re + cy
    };
    var esp = {
      x: Math.cos(endAngle) * rs + cx,
      y: Math.sin(endAngle) * rs + cy
    };
    var eep = {
      x: Math.cos(endAngle) * re + cx,
      y: Math.sin(endAngle) * re + cy
    };

    if (Inside.line(ssp.x, ssp.y, sep.x, sep.y, lineWidth, x, y)) {
      return true;
    }

    if (Inside.line(esp.x, esp.y, eep.x, eep.y, lineWidth, x, y)) {
      return true;
    }

    if (Inside.arcline(cx, cy, rs, startAngle, endAngle, clockwise, lineWidth, x, y)) {
      return true;
    }

    if (Inside.arcline(cx, cy, re, startAngle, endAngle, clockwise, lineWidth, x, y)) {
      return true;
    }

    return false;
  }

  if (fill && stroke) {
    return _isPointInFill() || _isPointInStroke();
  }

  if (fill) {
    return _isPointInFill();
  }

  if (stroke) {
    return _isPointInStroke();
  }

  return false;
};

var image = function image(x, y) {
  var attrs = this._attrs;

  if (this.get('toDraw') || !attrs.img) {
    return false;
  }

  if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {
    this._setAttrImg();
  }

  var rx = attrs.x;
  var ry = attrs.y;
  var width = attrs.width;
  var height = attrs.height;
  return Inside.rect(rx, ry, width, height, x, y);
};

var line = function line(x, y) {
  var attrs = this._attrs;
  var x1 = attrs.x1,
      y1 = attrs.y1,
      x2 = attrs.x2,
      y2 = attrs.y2;
  var lineWidth = this.getHitLineWidth();

  if (this.hasStroke()) {
    return Inside.line(x1, y1, x2, y2, lineWidth, x, y);
  }

  return false;
};

var path = function path(x, y) {
  var self = this;
  var segments = self.get('segments');
  var fill = self.hasFill();
  var stroke = self.hasStroke();

  function _isPointInStroke() {
    if (!Util.isEmpty(segments)) {
      var lineWidth = self.getHitLineWidth();

      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].isInside(x, y, lineWidth)) {
          return true;
        }
      }

      return false;
    }
  }

  if (fill && stroke) {
    return isPointInPathByContext(x, y, self) || _isPointInStroke();
  }

  if (fill) {
    return isPointInPathByContext(x, y, self);
  }

  if (stroke) {
    return _isPointInStroke();
  }

  return false;
};

var polygon = function polygon(x, y) {
  var self = this;
  var fill = self.hasFill();
  var stroke = self.hasStroke();

  function _isPointInStroke() {
    var attrs = self._attrs;
    var points = attrs.points;

    if (points.length < 2) {
      return false;
    }

    var lineWidth = self.getHitLineWidth();
    var outPoints = points.slice(0);

    if (points.length >= 3) {
      outPoints.push(points[0]);
    }

    return Inside.polyline(outPoints, lineWidth, x, y);
  }

  if (fill && stroke) {
    return isPointInPathByContext(x, y, self) || _isPointInStroke();
  }

  if (fill) {
    return isPointInPathByContext(x, y, self);
  }

  if (stroke) {
    return _isPointInStroke();
  }

  return false;
};

var marker = function marker(x, y) {
  var attrs = this._attrs;
  var cx = attrs.x;
  var cy = attrs.y;
  var r = attrs.radius || attrs.r;
  var lineWidth = this.getHitLineWidth();
  return Inside.circle(cx, cy, r + lineWidth / 2, x, y);
};

var polyline = function polyline(x, y) {
  var self = this;
  var attrs = self._attrs;

  if (self.hasStroke()) {
    var points = attrs.points;

    if (points.length < 2) {
      return false;
    }

    var lineWidth = attrs.lineWidth;
    return Inside.polyline(points, lineWidth, x, y);
  }

  return false;
};

var rect = function rect(x, y) {
  var self = this;
  var fill = self.hasFill();
  var stroke = self.hasStroke();

  function _isPointInStroke() {
    var attrs = self._attrs;
    var rx = attrs.x;
    var ry = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    var lineWidth = self.getHitLineWidth();

    if (radius === 0) {
      var halfWidth = lineWidth / 2;
      return Inside.line(rx - halfWidth, ry, rx + width + halfWidth, ry, lineWidth, x, y) || Inside.line(rx + width, ry - halfWidth, rx + width, ry + height + halfWidth, lineWidth, x, y) || Inside.line(rx + width + halfWidth, ry + height, rx - halfWidth, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height + halfWidth, rx, ry - halfWidth, lineWidth, x, y);
    }

    return Inside.line(rx + radius, ry, rx + width - radius, ry, lineWidth, x, y) || Inside.line(rx + width, ry + radius, rx + width, ry + height - radius, lineWidth, x, y) || Inside.line(rx + width - radius, ry + height, rx + radius, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height - radius, rx, ry + radius, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + radius, radius, 1.5 * Math.PI, 2 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + height - radius, radius, 0, 0.5 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + height - radius, radius, 0.5 * Math.PI, Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + radius, radius, Math.PI, 1.5 * Math.PI, false, lineWidth, x, y);
  }

  if (fill && stroke) {
    return isPointInPathByContext(x, y, self) || _isPointInStroke();
  }

  if (fill) {
    return isPointInPathByContext(x, y, self);
  }

  if (stroke) {
    return _isPointInStroke();
  }

  return false;
};

var text = function text(x, y) {
  var self = this;
  var box = self.getBBox();

  if (self.hasFill() || self.hasStroke()) {
    return Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y);
  }
};

var dom = function dom(x, y) {
  if (!this._cfg.el) {
    return false;
  }

  var box = this._cfg.el.getBBox();

  return Inside.box(box.x, box.x + box.width, box.y, box.y + box.height, x, y);
};

var shapes = {
  arc: arc,
  circle: circle,
  dom: dom,
  ellipse: ellipse,
  fan: fan,
  image: image,
  line: line,
  path: path,
  marker: marker,
  polygon: polygon,
  polyline: polyline,
  rect: rect,
  text: text
};
module.exports = {
  isPointInPath: function isPointInPath(x, y) {
    var shape = shapes[this.type];

    if (shape) {
      return shape.call(this, x, y);
    }

    return false;
  }
};

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var PathUtil = __webpack_require__(77);

var d3Timer = __webpack_require__(103);

var d3Ease = __webpack_require__(199);

var _require = __webpack_require__(453),
    interpolate = _require.interpolate,
    interpolateArray = _require.interpolateArray; // 鐩墠鏁翠綋鍔ㄧ敾鍙渶瑕佹暟鍊煎拰鏁扮粍鐨勫樊鍊艰绠�


var Timeline = function Timeline(canvas) {
  // 寰呮墽琛屽姩鐢荤殑闃熷垪
  this._animators = []; // 褰撳墠鏃堕棿

  this._current = 0; // 璁℃椂鍣ㄥ疄渚�

  this._timer = null; // 鐢诲竷

  this.canvas = canvas;
};

function _update(self, animator, ratio) {
  var cProps = {}; // 姝ゅ埢灞炴€�

  var toAttrs = animator.toAttrs;
  var fromAttrs = animator.fromAttrs;
  var toMatrix = animator.toMatrix;

  if (self.get('destroyed')) {
    return;
  }

  var interf; //  宸€煎嚱鏁�

  for (var k in toAttrs) {
    if (!Util.isEqual(fromAttrs[k], toAttrs[k])) {
      if (k === 'path') {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];

        if (toPath.length > fromPath.length) {
          toPath = PathUtil.parsePathString(toAttrs[k]); // 缁堢偣鐘舵€�

          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 璧峰鐘舵€�

          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);
          fromPath = PathUtil.formatPath(fromPath, toPath);
          animator.fromAttrs.path = fromPath;
          animator.toAttrs.path = toPath;
        } else if (!animator.pathFormatted) {
          toPath = PathUtil.parsePathString(toAttrs[k]);
          fromPath = PathUtil.parsePathString(fromAttrs[k]);
          fromPath = PathUtil.formatPath(fromPath, toPath);
          animator.fromAttrs.path = fromPath;
          animator.toAttrs.path = toPath;
          animator.pathFormatted = true;
        }

        cProps[k] = [];

        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];

          for (var j = 0; j < toPathPoint.length; j++) {
            if (Util.isNumber(toPathPoint[j]) && fromPathPoint && Util.isNumber(fromPathPoint[j])) {
              interf = interpolate(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }

          cProps[k].push(cPathPoint);
        }
      } else {
        interf = interpolate(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }

  if (toMatrix) {
    var mf = interpolateArray(animator.fromMatrix, toMatrix);
    var cM = mf(ratio);
    self.setMatrix(cM);
  }

  self.attr(cProps);
}

function update(shape, animator, elapsed) {
  var startTime = animator.startTime; // 濡傛灉杩樻病鏈夊紑濮嬫墽琛屾垨鏆傚仠锛屽厛涓嶆洿鏂�

  if (elapsed < startTime + animator.delay || animator.isPaused) {
    return false;
  }

  var ratio;
  var duration = animator.duration;
  var easing = animator.easing; // 宸叉墽琛屾椂闂�

  elapsed = elapsed - startTime - animator.delay;

  if (animator.toAttrs.repeat) {
    ratio = elapsed % duration / duration;
    ratio = d3Ease[easing](ratio);
  } else {
    ratio = elapsed / duration;

    if (ratio < 1) {
      ratio = d3Ease[easing](ratio);
    } else {
      shape.attr(animator.toAttrs);

      if (animator.toMatrix) {
        shape.setMatrix(animator.toMatrix);
      }

      return true;
    }
  }

  _update(shape, animator, ratio);

  return false;
}

Util.augment(Timeline, {
  initTimer: function initTimer() {
    var _this = this;

    var self = this;
    var isFinished = false;
    var shape, animators, animator;
    self._timer = d3Timer.timer(function (elapsed) {
      self._current = elapsed;

      if (_this._animators.length > 0) {
        for (var i = _this._animators.length - 1; i >= 0; i--) {
          shape = _this._animators[i];

          if (shape.get('destroyed')) {
            // 濡傛灉宸茬粡琚攢姣侊紝鐩存帴绉诲嚭闃熷垪
            self.removeAnimator(i);
            continue;
          }

          if (!shape.get('pause').isPaused) {
            animators = shape.get('animators');

            for (var j = animators.length - 1; j >= 0; j--) {
              animator = animators[j];
              isFinished = update(shape, animator, elapsed);

              if (isFinished) {
                animators.splice(j, 1);
                isFinished = false;

                if (animator.callback) {
                  animator.callback();
                }
              }
            }
          }

          if (animators.length === 0) {
            self.removeAnimator(i);
          }
        }

        _this.canvas.draw();
      }
    });
  },
  addAnimator: function addAnimator(shape) {
    this._animators.push(shape);
  },
  removeAnimator: function removeAnimator(index) {
    this._animators.splice(index, 1);
  },
  isAnimating: function isAnimating() {
    return !!this._animators.length;
  },
  stop: function stop() {
    if (this._timer) {
      this._timer.stop();
    }
  },
  stopAllAnimations: function stopAllAnimations() {
    this._animators.forEach(function (animator) {
      animator.stopAnimate();
    });

    this._animators = [];
    this.canvas.draw();
  },
  getTime: function getTime() {
    return this._current;
  }
});
module.exports = Timeline;

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1); // 鏄惁鏈敼鍙�


function isUnchanged(m) {
  return m[0] === 1 && m[1] === 0 && m[3] === 0 && m[4] === 1 && m[6] === 0 && m[7] === 0;
} // 鏄惁浠呬粎鏄痵cale


function isScale(m) {
  return m[1] === 0 && m[3] === 0 && m[6] === 0 && m[7] === 0;
}

function multiple(m1, m2) {
  if (!isUnchanged(m2)) {
    if (isScale(m2)) {
      m1[0] *= m2[0];
      m1[4] *= m2[4];
    } else {
      Util.mat3.multiply(m1, m1, m2);
    }
  }
}

module.exports = {
  initTransform: function initTransform() {},
  resetMatrix: function resetMatrix() {
    this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  },
  translate: function translate(tx, ty) {
    var matrix = this._attrs.matrix;
    Util.mat3.translate(matrix, matrix, [tx, ty]);
    this.clearTotalMatrix();
    this.attr('matrix', matrix);
    return this;
  },
  rotate: function rotate(radian) {
    var matrix = this._attrs.matrix;
    Util.mat3.rotate(matrix, matrix, radian);
    this.clearTotalMatrix();
    this.attr('matrix', matrix);
    return this;
  },
  scale: function scale(s1, s2) {
    var matrix = this._attrs.matrix;
    Util.mat3.scale(matrix, matrix, [s1, s2]);
    this.clearTotalMatrix();
    this.attr('matrix', matrix);
    return this;
  },
  rotateAtStart: function rotateAtStart(rotate) {
    var x = this._attrs.x || this._cfg.attrs.x;
    var y = this._attrs.y || this._cfg.attrs.y;

    if (Math.abs(rotate) > Math.PI * 2) {
      rotate = rotate / 180 * Math.PI;
    }

    return this.transform([['t', -x, -y], ['r', rotate], ['t', x, y]]);
  },
  move: function move(x, y) {
    var cx = this.get('x') || 0; // 褰撳墠鐨剎

    var cy = this.get('y') || 0; // 褰撳墠鐨剏

    this.translate(x - cx, y - cy);
    this.set('x', x);
    this.set('y', y);
    return this;
  },
  transform: function transform(ts) {
    var self = this;
    var matrix = this._attrs.matrix;
    Util.each(ts, function (t) {
      switch (t[0]) {
        case 't':
          self.translate(t[1], t[2]);
          break;

        case 's':
          self.scale(t[1], t[2]);
          break;

        case 'r':
          self.rotate(t[1]);
          break;

        case 'm':
          self.attr('matrix', Util.mat3.multiply([], matrix, t[1]));
          self.clearTotalMatrix();
          break;

        default:
          break;
      }
    });
    return self;
  },
  setTransform: function setTransform(ts) {
    this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);
    return this.transform(ts);
  },
  getMatrix: function getMatrix() {
    return this.attr('matrix');
  },
  setMatrix: function setMatrix(m) {
    this.attr('matrix', m);
    this.clearTotalMatrix();
    return this;
  },
  apply: function apply(v, root) {
    var m;

    if (root) {
      m = this._getMatrixByRoot(root);
    } else {
      m = this.attr('matrix');
    }

    Util.vec3.transformMat3(v, v, m);
    return this;
  },
  // 鑾峰彇鍒拌揪鎸囧畾鏍硅妭鐐圭殑鐭╅樀
  _getMatrixByRoot: function _getMatrixByRoot(root) {
    var self = this;
    root = root || self;
    var parent = self;
    var parents = [];

    while (parent !== root) {
      parents.unshift(parent);
      parent = parent.get('parent');
    }

    parents.unshift(parent);
    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    Util.each(parents, function (child) {
      Util.mat3.multiply(m, child.attr('matrix'), m);
    });
    return m;
  },

  /**
   * 搴旂敤鍒板綋鍓嶅厓绱犱笂鐨勬€荤殑鐭╅樀
   * @return {Matrix} 鐭╅樀
   */
  getTotalMatrix: function getTotalMatrix() {
    var m = this._cfg.totalMatrix;

    if (!m) {
      m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var parent = this._cfg.parent;

      if (parent) {
        var pm = parent.getTotalMatrix();
        multiple(m, pm);
      }

      multiple(m, this.attr('matrix'));
      this._cfg.totalMatrix = m;
    }

    return m;
  },
  // 娓呴櫎褰撳墠鐨勭煩闃�
  clearTotalMatrix: function clearTotalMatrix() {// this._cfg.totalMatrix = null;
  },
  invert: function invert(v) {
    var m = this.getTotalMatrix(); // 鍗曠簿灞忓箷涓嬪ぇ澶氭暟鐭╅樀娌″彉鍖�

    if (isScale(m)) {
      v[0] /= m[0];
      v[1] /= m[4];
    } else {
      var inm = Util.mat3.invert([], m);

      if (inm) {
        Util.vec3.transformMat3(v, v, inm);
      }
    }

    return this;
  },
  resetTransform: function resetTransform(context) {
    var mo = this.attr('matrix'); // 涓嶆敼鍙樻椂

    if (!isUnchanged(mo)) {
      context.transform(mo[0], mo[1], mo[3], mo[4], mo[6], mo[7]);
    }
  }
};

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  painter: __webpack_require__(335)
};

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var renderUtil = __webpack_require__(336);

var SHAPE_ATTRS = ['fillStyle', 'font', 'globalAlpha', 'lineCap', 'lineWidth', 'lineJoin', 'miterLimit', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'strokeStyle', 'textAlign', 'textBaseline', 'lineDash', 'lineDashOffset'];

var Painter =
/*#__PURE__*/
function () {
  function Painter(dom) {
    if (!dom) {
      return null;
    }

    var canvasId = Util.uniqueId('canvas_');
    var canvasDom = Util.createDom('<canvas id="' + canvasId + '"></canvas>');
    dom.appendChild(canvasDom);
    this.type = 'canvas';
    this.canvas = canvasDom;
    this.context = canvasDom.getContext('2d');
    this.toDraw = false;
    return this;
  }

  var _proto = Painter.prototype;

  _proto.beforeDraw = function beforeDraw() {
    var el = this.canvas;
    this.context && this.context.clearRect(0, 0, el.width, el.height);
  };

  _proto.draw = function draw(model) {
    var self = this;

    function drawInner() {
      self.animateHandler = Util.requestAnimationFrame(function () {
        self.animateHandler = undefined;

        if (self.toDraw) {
          drawInner();
        }
      });
      self.beforeDraw();

      try {
        self._drawGroup(model);
      } catch (ev) {
        // 缁樺埗鏃跺紓甯革紝涓柇閲嶇粯
        console.warn('error in draw canvas, detail as:');
        console.warn(ev);
        self.toDraw = false;
      }

      self.toDraw = false;
    }

    if (self.animateHandler) {
      self.toDraw = true;
    } else {
      drawInner();
    }
  };

  _proto.drawSync = function drawSync(model) {
    this.beforeDraw();

    this._drawGroup(model);
  };

  _proto._drawGroup = function _drawGroup(group) {
    if (group._cfg.removed || group._cfg.destroyed || !group._cfg.visible) {
      return;
    }

    var self = this;
    var children = group._cfg.children;
    var child = null;
    this.setContext(group);

    for (var i = 0; i < children.length; i++) {
      child = children[i];

      if (children[i].isGroup) {
        self._drawGroup(child);
      } else {
        self._drawShape(child);
      }
    }

    this.restoreContext(group);
  };

  _proto._drawShape = function _drawShape(shape) {
    if (shape._cfg.removed || shape._cfg.destroyed || !shape._cfg.visible) {
      return;
    }

    this.setContext(shape);
    shape.drawInner(this.context);
    this.restoreContext(shape);
    shape._cfg.attrs = shape._attrs;
    shape._cfg.hasUpdate = false;
  };

  _proto.setContext = function setContext(shape) {
    var context = this.context;
    var clip = shape._attrs.clip;
    context.save();

    if (clip) {
      // context.save();
      clip.resetTransform(context);
      clip.createPath(context);
      context.clip(); // context.restore();
    }

    this.resetContext(shape);
    shape.resetTransform(context);
  };

  _proto.restoreContext = function restoreContext() {
    this.context.restore();
  };

  _proto.resetContext = function resetContext(shape) {
    var context = this.context;
    var elAttrs = shape._attrs; // var canvas = this.get('canvas');

    if (!shape.isGroup) {
      for (var k in elAttrs) {
        if (SHAPE_ATTRS.indexOf(k) > -1) {
          // 闈瀋anvas灞炴€т笉闄勫姞
          var v = elAttrs[k];

          if (k === 'fillStyle') {
            v = renderUtil.parseStyle(v, shape, context);
          }

          if (k === 'strokeStyle') {
            v = renderUtil.parseStyle(v, shape, context);
          }

          if (k === 'lineDash' && context.setLineDash) {
            if (Util.isArray(v)) {
              context.setLineDash(v);
            } else if (Util.isString(v)) {
              context.setLineDash(v.split(' '));
            }
          } else {
            context[k] = v;
          }
        }
      }
    }
  };

  return Painter;
}();

module.exports = Painter;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/ig;
var numColorCache = {};

function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  Util.each(arr, function (item) {
    item = item.split(':');
    gradient.addColorStop(item[0], item[1]);
  });
}

function parseLineGradient(color, self, context) {
  var arr = regexLG.exec(color);
  var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var box = self.getBBox();
  var start;
  var end;

  if (angle >= 0 && angle < 0.5 * Math.PI) {
    start = {
      x: box.minX,
      y: box.minY
    };
    end = {
      x: box.maxX,
      y: box.maxY
    };
  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box.maxX,
      y: box.minY
    };
    end = {
      x: box.minX,
      y: box.maxY
    };
  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
    start = {
      x: box.maxX,
      y: box.maxY
    };
    end = {
      x: box.minX,
      y: box.minY
    };
  } else {
    start = {
      x: box.minX,
      y: box.maxY
    };
    end = {
      x: box.maxX,
      y: box.minY
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}

function parseRadialGradient(color, self, context) {
  var arr = regexRG.exec(color);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4]; // 鐜崐寰勪负0鏃讹紝榛樿鏃犳笎鍙橈紝鍙栨笎鍙樺簭鍒楃殑鏈€鍚庝竴涓鑹�

  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(':')[1];
  }

  var box = self.getBBox();
  var width = box.maxX - box.minX;
  var height = box.maxY - box.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, fr * r, box.minX + width / 2, box.minY + height / 2, r);
  addStop(steps, gradient);
  return gradient;
}

function parsePattern(color, self, context) {
  if (self.get('patternSource') && self.get('patternSource') === color) {
    return self.get('pattern');
  }

  var pattern;
  var img;
  var arr = regexPR.exec(color);
  var repeat = arr[1];
  var source = arr[2]; // Function to be called when pattern loads

  function onload() {
    // Create pattern
    pattern = context.createPattern(img, repeat);
    self.setSilent('pattern', pattern); // be a cache

    self.setSilent('patternSource', color);
  }

  switch (repeat) {
    case 'a':
      repeat = 'repeat';
      break;

    case 'x':
      repeat = 'repeat-x';
      break;

    case 'y':
      repeat = 'repeat-y';
      break;

    case 'n':
      repeat = 'no-repeat';
      break;

    default:
      repeat = 'no-repeat';
  }

  img = new Image(); // If source URL is not a data URL

  if (!source.match(/^data:/i)) {
    // Set crossOrigin for this image
    img.crossOrigin = 'Anonymous';
  }

  img.src = source;

  if (img.complete) {
    onload();
  } else {
    img.onload = onload; // Fix onload() bug in IE9

    img.src = img.src;
  }

  return pattern;
}

module.exports = {
  parsePath: function parsePath(path) {
    path = path || [];

    if (Util.isArray(path)) {
      return path;
    }

    if (Util.isString(path)) {
      path = path.match(regexTags);
      Util.each(path, function (item, index) {
        item = item.match(regexDot);

        if (item[0].length > 1) {
          var tag = item[0].charAt(0);
          item.splice(1, 0, item[0].substr(1));
          item[0] = tag;
        }

        Util.each(item, function (sub, i) {
          if (!isNaN(sub)) {
            item[i] = +sub;
          }
        });
        path[index] = item;
      });
      return path;
    }
  },
  parseStyle: function parseStyle(color, self, context) {
    if (Util.isString(color)) {
      if (color[1] === '(' || color[2] === '(') {
        if (color[0] === 'l') {
          // regexLG.test(color)
          return parseLineGradient(color, self, context);
        } else if (color[0] === 'r') {
          // regexRG.test(color)
          return parseRadialGradient(color, self, context);
        } else if (color[0] === 'p') {
          // regexPR.test(color)
          return parsePattern(color, self, context);
        }
      }

      return color;
    }
  },
  numberToColor: function numberToColor(num) {
    // 澧炲姞缂撳瓨
    var color = numColorCache[num];

    if (!color) {
      var str = num.toString(16);

      for (var i = str.length; i < 6; i++) {
        str = '0' + str;
      }

      color = '#' + str;
      numColorCache[num] = color;
    }

    return color;
  }
};

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  canvas: __webpack_require__(334),
  svg: __webpack_require__(345)
};

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/9.
 */
var Util = __webpack_require__(1);

var Gradient = __webpack_require__(341);

var Shadow = __webpack_require__(343);

var Arrow = __webpack_require__(339);

var Clip = __webpack_require__(340);

var Pattern = __webpack_require__(342);

var Defs =
/*#__PURE__*/
function () {
  function Defs(canvas) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    var id = Util.uniqueId('defs_');
    el.id = id;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }

  var _proto = Defs.prototype;

  _proto.find = function find(type, attr) {
    var children = this.children;
    var result = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].match(type, attr)) {
        result = children[i].id;
        break;
      }
    }

    return result;
  };

  _proto.findById = function findById(id) {
    var children = this.children;
    var flag = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].id === id) {
        flag = children[i];
        break;
      }
    }

    return flag;
  };

  _proto.add = function add(item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };

  _proto.getDefaultArrow = function getDefaultArrow(attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;

    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }

    var arrow = new Arrow(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    return arrow.id;
  };

  _proto.addGradient = function addGradient(cfg) {
    var gradient = new Gradient(cfg);
    this.el.appendChild(gradient.el);
    this.add(gradient);
    return gradient.id;
  };

  _proto.addArrow = function addArrow(attrs, name) {
    var arrow = new Arrow(attrs, name);
    this.el.appendChild(arrow.el);
    return arrow.id;
  };

  _proto.addShadow = function addShadow(cfg) {
    var shadow = new Shadow(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };

  _proto.addPattern = function addPattern(cfg) {
    var pattern = new Pattern(cfg);
    this.el.appendChild(pattern.el);
    this.add(pattern);
    return pattern.id;
  };

  _proto.addClip = function addClip(cfg) {
    var clip = new Clip(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };

  return Defs;
}();

module.exports = Defs;

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/11.
 */
var Util = __webpack_require__(1);

var Arrow =
/*#__PURE__*/
function () {
  function Arrow(attrs, type) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    var id = Util.uniqueId('marker_');
    el.setAttribute('id', id);
    var shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    shape.setAttribute('stroke', 'none');
    shape.setAttribute('fill', attrs.stroke || '#000');
    el.appendChild(shape);
    el.setAttribute('overflow', 'visible');
    el.setAttribute('orient', 'auto-start-reverse');
    this.el = el;
    this.child = shape;
    this.id = id;
    this.cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];
    this.stroke = attrs.stroke || '#000';

    if (this.cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this._setMarker(attrs.lineWidth, shape);
    }

    return this;
  }

  var _proto = Arrow.prototype;

  _proto.match = function match() {
    return false;
  };

  _proto._setDefaultPath = function _setDefaultPath(type, el) {
    var parent = this.el;
    el.setAttribute('d', 'M0,0 L6,3 L0,6 L3,3Z');
    parent.setAttribute('refX', 3);
    parent.setAttribute('refY', 3);
  };

  _proto._setMarker = function _setMarker(r, el) {
    var parent = this.el;
    var path = this.cfg.path;
    var d = this.cfg.d;

    if (Util.isArray(path)) {
      path = path.map(function (segment) {
        return segment.join(' ');
      }).join('');
    }

    el.setAttribute('d', path);
    parent.appendChild(el);

    if (d) {
      parent.setAttribute('refX', d / r);
    }
  };

  _proto.update = function update(fill) {
    var child = this.child;

    if (child.attr) {
      child.attr('fill', fill);
    } else {
      child.setAttribute('fill', fill);
    }
  };

  return Arrow;
}();

module.exports = Arrow;

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/14.
 */
var Util = __webpack_require__(1);

var Clip =
/*#__PURE__*/
function () {
  function Clip(cfg) {
    this.type = 'clip';
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    this.el = el;
    this.id = Util.uniqueId('clip_');
    el.id = this.id;
    var shapeEl = cfg._cfg.el; // just in case the clip shape is also a shape needs to be drawn

    el.appendChild(shapeEl.cloneNode(true));
    this.cfg = cfg;
    return this;
  }

  var _proto = Clip.prototype;

  _proto.match = function match() {
    return false;
  };

  _proto.remove = function remove() {
    var el = this.el;
    el.parentNode.removeChild(el);
  };

  return Clip;
}();

module.exports = Clip;

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/9.
 */
var Util = __webpack_require__(1);

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/ig;

function addStop(steps) {
  var arr = steps.match(regexColorStop);

  if (!arr) {
    return '';
  }

  var stops = '';
  arr.sort(function (a, b) {
    a = a.split(':');
    b = b.split(':');
    return Number(a[0]) - Number(b[0]);
  });
  Util.each(arr, function (item) {
    item = item.split(':');
    stops += "<stop offset=\"" + item[0] + "\" stop-color=\"" + item[1] + "\"></stop>";
  });
  return stops;
}

function parseLineGradient(color, el) {
  var arr = regexLG.exec(color);
  var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;

  if (angle >= 0 && angle < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute('x1', start.x);
  el.setAttribute('y1', start.y);
  el.setAttribute('x2', x);
  el.setAttribute('y2', y);
  el.innerHTML = addStop(steps);
}

function parseRadialGradient(color, self) {
  var arr = regexRG.exec(color);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self.setAttribute('cx', cx);
  self.setAttribute('cy', cy);
  self.setAttribute('r', r);
  self.innerHTML = addStop(steps);
}

var Gradient =
/*#__PURE__*/
function () {
  function Gradient(cfg) {
    var el = null;
    var id = Util.uniqueId('gradient_');

    if (cfg.toLowerCase()[0] === 'l') {
      el = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
      parseLineGradient(cfg, el);
    } else {
      el = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
      parseRadialGradient(cfg, el);
    }

    el.setAttribute('id', id);
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    return this;
  }

  var _proto = Gradient.prototype;

  _proto.match = function match(type, attr) {
    return this.cfg === attr;
  };

  return Gradient;
}();

module.exports = Gradient;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/9.
 */
var Util = __webpack_require__(1);

var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;

var Pattern =
/*#__PURE__*/
function () {
  function Pattern(cfg) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
    el.setAttribute('patternUnits', 'userSpaceOnUse');
    var child = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    el.appendChild(child);
    var id = Util.uniqueId('pattern_');
    el.id = id;
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    var arr = regexPR.exec(cfg);
    var source = arr[2];
    child.setAttribute('href', source);
    var img = new Image();

    if (!source.match(/^data:/i)) {
      img.crossOrigin = 'Anonymous';
    }

    img.src = source;

    function onload() {
      console.log(img.width, img.height);
      el.setAttribute('width', img.width);
      el.setAttribute('height', img.height);
    }

    if (img.complete) {
      onload();
    } else {
      img.onload = onload; // Fix onload() bug in IE9

      img.src = img.src;
    }

    return this;
  }

  var _proto = Pattern.prototype;

  _proto.match = function match(type, attr) {
    return this.cfg === attr;
  };

  return Pattern;
}();

module.exports = Pattern;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by Elaine on 2018/5/10.
 */
var Util = __webpack_require__(1);

var ATTR_MAP = {
  shadowColor: 'color',
  shadowOpacity: 'opacity',
  shadowBlur: 'blur',
  shadowOffsetX: 'dx',
  shadowOffsetY: 'dy'
};
var SHADOW_DIMENSION = {
  x: '-40%',
  y: '-40%',
  width: '200%',
  height: '200%'
};

var Shadow =
/*#__PURE__*/
function () {
  function Shadow(cfg) {
    this.type = 'filter';
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'filter'); // expand the filter region to fill in shadows

    Util.each(SHADOW_DIMENSION, function (v, k) {
      el.setAttribute(k, v);
    });
    this.el = el;
    this.id = Util.uniqueId('filter_');
    this.el.id = this.id;
    this.cfg = cfg;

    this._parseShadow(cfg, el);

    return this;
  }

  var _proto = Shadow.prototype;

  _proto.match = function match(type, cfg) {
    if (this.type !== type) {
      return false;
    }

    var flag = true;
    var config = this.cfg;
    Util.each(Object.keys(config), function (attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };

  _proto.update = function update(name, value) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value;

    this._parseShadow(config, this.el);

    return this;
  };

  _proto._parseShadow = function _parseShadow(config, el) {
    var child = "<feDropShadow \n      dx=\"" + (config.dx || 0) + "\" \n      dy=\"" + (config.dy || 0) + "\" \n      stdDeviation=\"" + (config.blur ? config.blur / 10 : 0) + "\"\n      flood-color=\"" + (config.color ? config.color : '#000') + "\"\n      flood-opacity=\"" + (config.opacity ? config.opacity : 1) + "\"\n      />";
    el.innerHTML = child;
  };

  return Shadow;
}();

module.exports = Shadow;

/***/ }),
/* 344 */
/***/ (function(module, exports) {

var TAG_MAP = {
  svg: 'svg',
  circle: 'circle',
  rect: 'rect',
  text: 'text',
  path: 'path',
  foreignObject: 'foreignObject',
  polygon: 'polygon',
  ellipse: 'ellipse',
  image: 'image'
};

module.exports = function getShape(x, y, e) {
  var target = e.target || e.srcElement;

  if (!TAG_MAP[target.tagName]) {
    var parent = target.parentNode;

    while (parent && !TAG_MAP[parent.tagName]) {
      parent = parent.parentNode;
    }

    target = parent;
  }

  if (this._cfg.el === target) {
    return this;
  }

  return this.find(function (item) {
    return item._cfg && item._cfg.el === target;
  });
};

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  painter: __webpack_require__(346),
  getShape: __webpack_require__(344)
};

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var Util = __webpack_require__(1);

var _require = __webpack_require__(37),
    parseRadius = _require.parseRadius;

var Marker = __webpack_require__(74);

var Defs = __webpack_require__(338);

var SHAPE_TO_TAGS = {
  rect: 'path',
  circle: 'circle',
  line: 'line',
  path: 'path',
  marker: 'path',
  text: 'text',
  polygon: 'polygon',
  image: 'image',
  ellipse: 'ellipse',
  dom: 'foreignObject',
  fan: 'path',
  group: 'g'
};
var LETTER_SPACING = 0.3;
var SVG_ATTR_MAP = {
  opacity: 'opacity',
  fillStyle: 'fill',
  strokeOpacity: 'stroke-opacity',
  fillOpacity: 'fill-opacity',
  strokeStyle: 'stroke',
  x: 'x',
  y: 'y',
  r: 'r',
  width: 'width',
  height: 'height',
  x1: 'x1',
  x2: 'x2',
  y1: 'y1',
  y2: 'y2',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  lineWidth: 'stroke-width',
  lineDash: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset',
  miterLimit: 'stroke-miterlimit',
  font: 'font',
  fontSize: 'font-size',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  fontFamily: 'font-family',
  startArrow: 'marker-start',
  endArrow: 'marker-end',
  path: 'd',
  class: 'class',
  id: 'id',
  style: 'style',
  preserveAspectRatio: 'preserveAspectRatio'
};
var BASELINE_MAP = {
  top: 'before-edge',
  middle: 'central',
  bottom: 'after-edge',
  alphabetic: 'baseline',
  hanging: 'hanging'
};
var ANCHOR_MAP = {
  left: 'left',
  start: 'left',
  center: 'middle',
  right: 'end',
  end: 'end'
};

var Painter =
/*#__PURE__*/
function () {
  function Painter(dom) {
    if (!dom) {
      return null;
    }

    var svgId = Util.uniqueId('canvas_');
    var canvasDom = Util.createDom("<svg id=\"" + svgId + "\"></svg>");
    dom.appendChild(canvasDom);
    this.type = 'svg';
    this.canvas = canvasDom;
    this.context = new Defs(canvasDom);
    this.toDraw = false;
    return this;
  }

  var _proto = Painter.prototype;

  _proto.draw = function draw(model) {
    var self = this;

    function drawInner() {
      self.animateHandler = Util.requestAnimationFrame(function () {
        self.animateHandler = undefined;

        if (self.toDraw) {
          drawInner();
        }
      });

      try {
        model.resetMatrix();

        self._drawGroup(model, false);
      } catch (ev) {
        // 缁樺埗鏃跺紓甯革紝涓柇閲嶇粯
        console.warn('error in draw canvas, detail as:');
        console.warn(ev);
        self.toDraw = false;
      }

      self.toDraw = false;
    }

    if (self.animateHandler) {
      self.toDraw = true;
    } else {
      drawInner();
    }
  };

  _proto.drawSync = function drawSync(model) {
    this._drawChildren(model, false);
  };

  _proto._drawGroup = function _drawGroup(model, redraw) {
    var cfg = model._cfg;

    if (cfg.removed || cfg.destroyed) {
      return;
    }
    /**
     * FIXME redraw: 涓轰簡浣垮厓绱犵疆椤剁殑涓存椂瑙ｅ喅鏂规
     * 濡傛灉鐩存帴灏哾om鍏冪礌閲嶆帓鍙互瑙ｅ喅閮ㄥ垎闂銆備絾鏄鏋滈噸鎺掑悗鐨刧roup涓湁鏂板鐨剆hape锛岀疆椤舵晥鏋滃氨娌℃湁浜�
     * 鎵€浠ュ彧鑳藉垹闄ゅ師鏈夎妭鐐癸紝鏂板鑺傜偣浠ュ強鎵€鏈夊瓙鑺傜偣銆傝繖鏃跺€欏摢鎬晄hape鏈塭l锛屼篃闇€瑕佸垽鏂竴涓嬫槸鍚﹂渶瑕侀噸缁�
     */


    if (!cfg.el && cfg.attrs) {
      redraw = true;
    }

    if (cfg.tobeRemoved) {
      Util.each(cfg.tobeRemoved, function (item) {
        if (item.parentNode) {
          item.parentNode.removeChild(item);
        }
      });
      cfg.tobeRemoved = [];
    }

    this._drawShape(model, redraw);

    if (cfg.children && cfg.children.length > 0) {
      this._drawChildren(model, redraw);
    }
  };

  _proto._drawChildren = function _drawChildren(parent, redraw) {
    var self = this;
    var children = parent._cfg.children;
    var shape; // 闃叉鍦ㄧ敾children鐨勬椂鍊欙紝鐖秅roup宸茬粡琚玠estroy

    if (!children) {
      return;
    }

    if (parent._cfg.el && !redraw) {
      // FIXME 杩欒竟鏄负浜嗚В鍐充竴涓猤roup涓湁鍏冪礌宸茬粡鐢熸垚el锛岃繕鏈変竴浜涙病鐢熸垚el鏃讹紝娌＄敓鎴恊l鐨勭疆搴曟晥鏋滀笉work
      var childLen = parent._cfg.el.childNodes.length + 1;

      if (childLen !== 0 && childLen !== children.length) {
        redraw = true;
      }
    }

    for (var i = 0; i < children.length; i++) {
      shape = children[i];

      if (shape.isGroup) {
        self._drawGroup(shape, redraw);
      } else {
        self._drawShape(shape, redraw);
      }
    }
  };

  _proto._drawShape = function _drawShape(model, redraw) {
    var self = this;
    var attrs = model._attrs;
    var cfg = model._cfg;
    var el = cfg.el; // 鍒犻櫎

    if (cfg.removed || cfg.destroyed) {
      if (el) {
        el.parentNode.removeChild(cfg.el);
      }

      return;
    } // 閲嶇粯鑺傜偣


    if (redraw && el) {
      el.parentNode && el.parentNode.removeChild(el);
      el = null;
    } // 鏂板鑺傜偣


    if (!el && cfg.parent) {
      self._createDom(model);

      self._updateShape(model);
    }

    el = cfg.el;

    if (cfg.visible === false) {
      el.setAttribute('visibility', 'hidden');
      return;
    }

    if (cfg.visible && el.hasAttribute('visibility')) {
      el.removeAttribute('visibility');
    } // 鏇存柊


    if (cfg.hasUpdate) {
      self._updateShape(model);
    }

    if (attrs.clip && attrs.clip._cfg.hasUpdate) {
      self._updateShape(attrs.clip);
    }
  };

  _proto._updateShape = function _updateShape(model) {
    var self = this;
    var attrs = model._attrs;
    var formerAttrs = model._cfg.attrs;

    if (!formerAttrs) {
      return;
    }

    if (!model._cfg.el) {
      self._createDom(model);
    }

    if ('clip' in attrs) {
      this._setClip(model, attrs.clip);
    }

    if ('shadowOffsetX' in attrs || 'shadowOffsetY' in attrs || 'shadowBlur' in attrs || 'shadowColor' in attrs) {
      this._setShadow(model);
    }

    if (model.type === 'text') {
      self._updateText(model);

      return;
    }

    if (model.type === 'fan') {
      self._updateFan(model);
    }

    if (model.type === 'marker') {
      model._cfg.el.setAttribute('d', self._assembleMarker(attrs));
    }

    if (model.type === 'rect') {
      model._cfg.el.setAttribute('d', self._assembleRect(attrs));
    }

    for (var key in attrs) {
      if (attrs[key] !== formerAttrs[key]) {
        self._setAttribute(model, key, attrs[key]);
      }
    }

    model._cfg.attrs = Util.deepMix({}, model._attrs);
    model._cfg.hasUpdate = false;
  };

  _proto._setAttribute = function _setAttribute(model, name, value) {
    var type = model.type;
    var attrs = model._attrs;
    var el = model._cfg.el;
    var defs = this.context; // 璁＄畻marker璺緞

    if ((type === 'marker' || type === 'rect') && ~['x', 'y', 'radius', 'r'].indexOf(name)) {
      return;
    } // 鍦嗗拰妞渾涓嶆槸x, y锛� 鏄痗x, cy銆� marker鐨剎,y 鐢ㄤ簬璁＄畻marker鐨勮矾寰勶紝涓嶉渶瑕佸啓鍒癲om


    if (~['circle', 'ellipse'].indexOf(type) && ~['x', 'y'].indexOf(name)) {
      el.setAttribute('c' + name, parseInt(value, 10));
      return;
    } // 澶氳竟褰�


    if (type === 'polygon' && name === 'points') {
      if (!value || value.length === 0) {
        value = '';
      }

      if (Util.isArray(value)) {
        value = value.map(function (point) {
          return point[0] + ',' + point[1];
        });
        value = value.join(' ');
      }

      el.setAttribute('points', value);
      return;
    } // 璁剧疆path


    if (name === 'path' && Util.isArray(value)) {
      el.setAttribute('d', this._formatPath(value));
      return;
    } // 璁剧疆鍥剧墖


    if (name === 'img') {
      this._setImage(model, value);

      return;
    }

    if (name === 'transform') {
      if (!value) {
        el.removeAttribute('transform');
        return;
      }

      this._setTransform(model);

      return;
    }

    if (name === 'rotate') {
      if (!value) {
        el.removeAttribute('transform');
        return;
      }

      this._setTransform(model);

      return;
    }

    if (name === 'matrix') {
      this._setTransform(model);

      return;
    }

    if (name === 'fillStyle' || name === 'strokeStyle') {
      this._setColor(model, name, value);

      return;
    }

    if (name === 'clip') {
      return;
    }

    if (~name.indexOf('Arrow')) {
      name = SVG_ATTR_MAP[name];

      if (!value) {
        model._cfg[name] = null;
        el.removeAttribute(name);
      } else {
        var id = null;

        if (typeof value === 'boolean') {
          id = defs.getDefaultArrow(attrs, name);
        } else {
          id = defs.addArrow(attrs, name);
        }

        el.setAttribute(name, "url(#" + id + ")");
        model._cfg[name] = id;
      }

      return;
    } // foreignObject


    if (name === 'html') {
      if (typeof value === 'string') {
        el.innerHTML = value;
      } else {
        el.innerHTML = '';
        el.appendChild(value);
      }
    }

    if (SVG_ATTR_MAP[name]) {
      el.setAttribute(SVG_ATTR_MAP[name], value);
    }
  };

  _proto._createDom = function _createDom(model) {
    var type = SHAPE_TO_TAGS[model.type];
    var attrs = model._attrs;

    if (!type) {
      throw new Error('the type' + model.type + 'is not supported by svg');
    }

    var shape = document.createElementNS('http://www.w3.org/2000/svg', type);
    model._cfg.el = shape;

    if (model._cfg.parent) {
      model._cfg.parent.get('el').appendChild(shape);
    }

    model._cfg.attrs = {};

    if (model.type === 'text') {
      shape.setAttribute('paint-order', 'stroke');
      shape.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');
    } else {
      if (!attrs.stroke && !attrs.strokeStyle) {
        shape.setAttribute('stroke', 'none');
      }

      if (!attrs.fill && !attrs.fillStyle) {
        shape.setAttribute('fill', 'none');
      }
    }

    return shape;
  };

  _proto._assembleMarker = function _assembleMarker(attrs) {
    var r = attrs.r;

    if (typeof attrs.r === 'undefined') {
      r = attrs.radius;
    }

    if (isNaN(Number(attrs.x)) || isNaN(Number(attrs.y)) || isNaN(Number(r))) {
      return '';
    }

    var d = '';

    if (typeof attrs.symbol === 'function') {
      d = attrs.symbol(attrs.x, attrs.y, r);
    } else {
      d = Marker.Symbols[attrs.symbol || 'circle'](attrs.x, attrs.y, r);
    }

    if (Util.isArray(d)) {
      d = d.map(function (path) {
        return path.join(' ');
      }).join('');
    }

    return d;
  };

  _proto._assembleRect = function _assembleRect(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    var radius = attrs.radius;

    if (!radius) {
      return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
    }

    var r = parseRadius(radius);

    if (Util.isArray(radius)) {
      if (radius.length === 1) {
        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
      } else if (radius.length === 2) {
        r.r1 = r.r3 = radius[0];
        r.r2 = r.r4 = radius[1];
      } else if (radius.length === 3) {
        r.r1 = radius[0];
        r.r2 = r.r4 = radius[1];
        r.r3 = radius[2];
      } else {
        r.r1 = radius[0];
        r.r2 = radius[1];
        r.r3 = radius[2];
        r.r4 = radius[3];
      }
    } else {
      r.r1 = r.r2 = r.r3 = r.r4 = radius;
    }

    var d = [["M " + (x + r.r1) + "," + y], ["l " + (w - r.r1 - r.r2) + ",0"], ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2], ["l 0," + (h - r.r2 - r.r3)], ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3], ["l " + (r.r3 + r.r4 - w) + ",0"], ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4], ["l 0," + (r.r4 + r.r1 - h)], ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1], ['z']];
    return d.join(' ');
  };

  _proto._formatPath = function _formatPath(value) {
    value = value.map(function (path) {
      return path.join(' ');
    }).join('');

    if (~value.indexOf('NaN')) {
      return '';
    }

    return value;
  };

  _proto._setTransform = function _setTransform(model) {
    var matrix = model._attrs.matrix;
    var el = model._cfg.el;
    var transform = [];

    for (var i = 0; i < 9; i += 3) {
      transform.push(matrix[i] + ',' + matrix[i + 1]);
    }

    transform = transform.join(',');

    if (transform.indexOf('NaN') === -1) {
      el.setAttribute('transform', "matrix(" + transform + ")");
    } else {
      console.warn('invalid matrix:', matrix);
    }
  };

  _proto._setImage = function _setImage(model, img) {
    var attrs = model._attrs;
    var el = model._cfg.el;

    if (Util.isString(img)) {
      el.setAttribute('href', img);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        el.setAttribute('width', img.width);
        model._attrs.width = img.width;
      }

      if (!attrs.height) {
        el.setAttribute('height', img.height);
        model._attrs.height = img.height;
      }

      el.setAttribute('href', img.src);
    } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
      el.setAttribute('href', img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement('canvas');
      canvas.setAttribute('width', img.width);
      canvas.setAttribute('height', img.height);
      canvas.getContext('2d').putImageData(img, 0, 0);

      if (!attrs.width) {
        el.setAttribute('width', img.width);
        model._attrs.width = img.width;
      }

      if (!attrs.height) {
        el.setAttribute('height', img.height);
        model._attrs.height = img.height;
      }

      el.setAttribute('href', canvas.toDataURL());
    }
  };

  _proto._updateFan = function _updateFan(model) {
    function getPoint(angle, radius, center) {
      return {
        x: radius * Math.cos(angle) + center.x,
        y: radius * Math.sin(angle) + center.y
      };
    }

    var attrs = model._attrs;
    var cfg = model._cfg;
    var center = {
      x: attrs.x,
      y: attrs.y
    };
    var d = [];
    var startAngle = attrs.startAngle;
    var endAngle = attrs.endAngle;

    if (Util.isNumberEqual(endAngle - startAngle, Math.PI * 2)) {
      endAngle -= 0.00001;
    }

    var outerStart = getPoint(startAngle, attrs.re, center);
    var outerEnd = getPoint(endAngle, attrs.re, center);
    var fa = endAngle > startAngle ? 1 : 0;
    var fs = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
    var rs = attrs.rs;
    var re = attrs.re;
    var innerStart = getPoint(startAngle, attrs.rs, center);
    var innerEnd = getPoint(endAngle, attrs.rs, center);

    if (attrs.rs > 0) {
      d.push("M " + outerEnd.x + "," + outerEnd.y);
      d.push("L " + innerEnd.x + "," + innerEnd.y);
      d.push("A " + rs + "," + rs + ",0," + fs + "," + (fa === 1 ? 0 : 1) + "," + innerStart.x + "," + innerStart.y);
      d.push("L " + outerStart.x + " " + outerStart.y);
    } else {
      d.push("M " + center.x + "," + center.y);
      d.push("L " + outerStart.x + "," + outerStart.y);
    }

    d.push("A " + re + "," + re + ",0," + fs + "," + fa + "," + outerEnd.x + "," + outerEnd.y);

    if (attrs.rs > 0) {
      d.push("L " + innerEnd.x + "," + innerEnd.y);
    } else {
      d.push('Z');
    }

    cfg.el.setAttribute('d', d.join(' '));
  };

  _proto._updateText = function _updateText(model) {
    var self = this;
    var attrs = model._attrs;
    var formerAttrs = model._cfg.attrs;
    var el = model._cfg.el;

    this._setFont(model);

    for (var attr in attrs) {
      if (attrs[attr] !== formerAttrs[attr]) {
        if (attr === 'text') {
          self._setText(model, "" + attrs[attr]);

          continue;
        }

        if (attr === 'fillStyle' || attr === 'strokeStyle') {
          this._setColor(model, attr, attrs[attr]);

          continue;
        }

        if (attr === 'matrix') {
          this._setTransform(model);

          continue;
        }

        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], attrs[attr]);
        }
      }
    }

    model._cfg.attrs = Object.assign({}, model._attrs);
    model._cfg.hasUpdate = false;
  };

  _proto._setFont = function _setFont(model) {
    var el = model.get('el');
    var attrs = model._attrs;
    var fontSize = attrs.fontSize;
    el.setAttribute('alignment-baseline', BASELINE_MAP[attrs.textBaseline] || 'baseline');
    el.setAttribute('text-anchor', ANCHOR_MAP[attrs.textAlign] || 'left');

    if (fontSize && +fontSize < 12) {
      // 灏忎簬 12 鍍忕礌鐨勬枃鏈繘琛� scale 澶勭悊
      attrs.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      model.transform([['t', -attrs.x, -attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', attrs.x, attrs.y]]);
    }
  };

  _proto._setText = function _setText(model, text) {
    var el = model._cfg.el;
    var baseline = model._attrs.textBaseline || 'bottom';

    if (!text) {
      el.innerHTML = '';
    } else if (~text.indexOf('\n')) {
      var x = model._attrs.x;
      var textArr = text.split('\n');
      var textLen = textArr.length - 1;
      var arr = '';
      Util.each(textArr, function (segment, i) {
        if (i === 0) {
          if (baseline === 'alphabetic') {
            arr += "<tspan x=\"" + x + "\" dy=\"" + -textLen + "em\">" + segment + "</tspan>";
          } else if (baseline === 'top') {
            arr += "<tspan x=\"" + x + "\" dy=\"0.9em\">" + segment + "</tspan>";
          } else if (baseline === 'middle') {
            arr += "<tspan x=\"" + x + "\" dy=\"" + -(textLen - 1) / 2 + "em\">" + segment + "</tspan>";
          } else if (baseline === 'bottom') {
            arr += "<tspan x=\"" + x + "\" dy=\"-" + (textLen + LETTER_SPACING) + "em\">" + segment + "</tspan>";
          } else if (baseline === 'hanging') {
            arr += "<tspan x=\"" + x + "\" dy=\"" + (-(textLen - 1) - LETTER_SPACING) + "em\">" + segment + "</tspan>";
          }
        } else {
          arr += "<tspan x=\"" + x + "\" dy=\"1em\">" + segment + "</tspan>";
        }
      });
      el.innerHTML = arr;
    } else {
      el.innerHTML = text;
    }
  };

  _proto._setClip = function _setClip(model, value) {
    var el = model._cfg.el;

    if (!value) {
      el.removeAttribute('clip-path');
      return;
    }

    if (!el.hasAttribute('clip-path')) {
      this._createDom(value);

      this._updateShape(value);

      var id = this.context.addClip(value);
      el.setAttribute('clip-path', "url(#" + id + ")");
    } else if (value._cfg.hasUpdate) {
      this._updateShape(value);
    }
  };

  _proto._setColor = function _setColor(model, name, value) {
    var el = model._cfg.el;
    var defs = this.context;

    if (!value) {
      el.setAttribute(SVG_ATTR_MAP[name], 'none');
      return;
    }

    value = value.trim();

    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = defs.find('gradient', value);

      if (!id) {
        id = defs.addGradient(value);
      }

      el.setAttribute(SVG_ATTR_MAP[name], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var _id = defs.find('pattern', value);

      if (!_id) {
        _id = defs.addPattern(value);
      }

      el.setAttribute(SVG_ATTR_MAP[name], "url(#" + _id + ")");
    } else {
      el.setAttribute(SVG_ATTR_MAP[name], value);
    }
  };

  _proto._setShadow = function _setShadow(model) {
    var el = model._cfg.el;
    var attrs = model._attrs;
    var cfg = {
      dx: attrs.shadowOffsetX,
      dy: attrs.shadowOffsetY,
      blur: attrs.shadowBlur,
      color: attrs.shadowColor
    };

    if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
      el.removeAttribute('filter');
    } else {
      var id = this.context.find('filter', cfg);

      if (!id) {
        id = this.context.addShadow(cfg, this);
      }

      el.setAttribute('filter', "url(#" + id + ")");
    }
  };

  return Painter;
}();

module.exports = Painter;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var Shape = __webpack_require__(7);

Shape.Arc = __webpack_require__(136);
Shape.Circle = __webpack_require__(137);
Shape.Dom = __webpack_require__(138);
Shape.Ellipse = __webpack_require__(139);
Shape.Fan = __webpack_require__(140);
Shape.Image = __webpack_require__(141);
Shape.Line = __webpack_require__(142);
Shape.Marker = __webpack_require__(74);
Shape.Path = __webpack_require__(145);
Shape.Polygon = __webpack_require__(146);
Shape.Polyline = __webpack_require__(147);
Shape.Rect = __webpack_require__(148);
Shape.Text = __webpack_require__(149);
module.exports = Shape;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(78);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(78);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */
function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];

  return out;
}

/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];

  var len1 = x1 * x1 + y1 * y1;
  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(78);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2];
  // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x;
  // var uuv = vec3.cross([], qvec, uv);
  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx;
  // vec3.scale(uv, uv, 2 * w);
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  // vec3.scale(uuv, uuv, 2);
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  // return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 鑷姩璁＄畻鏁板瓧鍧愭爣杞�
 * @author dxq613@gmail.com
 */
var isNil = __webpack_require__(6);

var isNumber = __webpack_require__(11);

var AutoUtil = __webpack_require__(152);

var MIN_COUNT = 5;
var MAX_COUNT = 7;
var SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];
var SNAP_ARRAY = [0, 1, 2, 4, 5, 10];
var EPS = 1e-12;

module.exports = function (info) {
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var minTickInterval = info.minTickInterval;
  var ticks = [];
  var minCount = info.minCount || MIN_COUNT;
  var maxCount = info.maxCount || MAX_COUNT;
  var isFixedCount = minCount === maxCount; // 鏄惁闄愬畾姝讳簡涓暟

  var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 闄愬畾鐨勬渶灏忓€�

  var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 闄愬畾鏈€澶у€�

  var avgCount = (minCount + maxCount) / 2;
  var count = avgCount; // 鐢ㄦ埛浼犲叆鐨勯€艰繎鏁扮粍

  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 濡傛灉闄愬畾澶у皬鑼冨洿锛屽悓鏃跺ぇ灏忚寖鍥寸瓑浜庣敤鎴蜂紶鍏ョ殑鑼冨洿锛屽悓鏃堕檺瀹氫簡涓暟锛宨nterval 鎸夌収涓暟鍧囧垎

  if (min === minLimit && max === maxLimit && isFixedCount) {
    interval = (max - min) / (count - 1);
  }

  if (isNil(min)) {
    min = 0;
  }

  if (isNil(max)) {
    max = 0;
  }

  if (Math.abs(max - min) < EPS) {
    if (min === 0) {
      max = 1;
    } else {
      if (min > 0) {
        min = 0;
      } else {
        max = 0;
      }
    }

    if (max - min < 5 && !interval && max - min >= 1) {
      interval = 1;
    }
  }

  if (isNil(interval)) {
    // 璁＄畻闂磋窛
    var temp = (max - min) / (avgCount - 1);
    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');

    if (maxCount !== minCount) {
      count = parseInt((max - min) / interval, 10);

      if (count > maxCount) {
        count = maxCount;
      }

      if (count < minCount) {
        count = minCount;
      } // 涓嶇‘瀹歵ick鐨勪釜鏁版椂锛屼娇寰梩ick鍋忓皬


      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');
    }
  } // interval should not be less than minTickInterval


  if (isNumber(minTickInterval) && interval < minTickInterval) {
    interval = minTickInterval;
  }

  if (info.interval || maxCount !== minCount) {
    // 鏍℃ max 鍜� min
    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 鍚戜笂閫艰繎

    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 鍚戜笅閫艰繎

    count = Math.round((max - min) / interval);
    min = AutoUtil.fixedBase(min, interval); // 褰搈in涓鸿礋鏁扮殑鏃跺€欙紝fixedBase鍚庯紝min鍙兘浼氬ぇ浜巑inLimit锛屽鑷存渶缁堜骇鍑虹殑tick鏄ぇ浜巑inLimit鐨勶紝鎵€浠ュ繀椤昏繘琛屼慨姝�

    max = AutoUtil.fixedBase(max, interval);
    var prevMin = null;

    while (min > minLimit && minLimit > -Infinity && (prevMin === null || min < prevMin)) {
      // 淇濊瘉璁＄畻鍑烘潵鐨勫埢搴︽渶灏忓€� min锛� 涓嶅ぇ浜庢暟鎹渶灏忓€� min
      prevMin = min;
      min = AutoUtil.fixedBase(min - interval, interval);
    }
  } else {
    avgCount = parseInt(avgCount, 10); // 鍙栨暣

    var avg = (max + min) / 2;
    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');
    var sideCount = Math.floor((avgCount - 2) / 2);
    var maxTick = avgTick + sideCount * interval;
    var minTick;

    if (avgCount % 2 === 0) {
      minTick = avgTick - sideCount * interval;
    } else {
      minTick = avgTick - (sideCount + 1) * interval;
    }

    var prevMaxTick = null; // 濡傛灉鍑忓幓intervl, fixBase鍚庯紝鏂扮殑minTick娌℃湁澶т簬涔嬪墠鐨勫€硷紝灏遍€€鍑猴紝闃叉姝诲惊鐜�

    while (maxTick < max && (prevMaxTick === null || maxTick > prevMaxTick)) {
      // 淇濊瘉璁＄畻鍑烘潵鐨勫埢搴︽渶澶у€� maxTick 涓嶅皬浜庢暟鎹渶澶у€� max
      prevMaxTick = maxTick;
      maxTick = AutoUtil.fixedBase(maxTick + interval, interval);
    }

    var prevMinTick = null; // 濡傛灉鍑忓幓intervl, fixBase鍚庯紝鏂扮殑minTick娌℃湁灏忎簬涔嬪墠鐨勫€硷紝灏遍€€鍑猴紝闃叉姝诲惊鐜�

    while (minTick > min && (prevMinTick === null || minTick < prevMinTick)) {
      // 淇濊瘉璁＄畻鍑烘潵鐨勫埢搴︽渶灏忓€� minTick 涓嶅ぇ浜庢暟鎹渶灏忓€� min
      prevMinTick = minTick;
      minTick = AutoUtil.fixedBase(minTick - interval, interval); // 闃叉瓒呭父娴偣鏁拌绠楅棶棰�
    }

    max = maxTick;
    min = minTick;
  }

  max = Math.min(max, maxLimit);
  min = Math.max(min, minLimit);
  ticks.push(min);

  for (var i = 1; i < count; i++) {
    var tickValue = AutoUtil.fixedBase(interval * i + min, interval);

    if (tickValue < max) {
      ticks.push(tickValue);
    }
  }

  if (ticks[ticks.length - 1] < max) {
    ticks.push(max);
  }

  return {
    min: min,
    max: max,
    interval: interval,
    count: count,
    ticks: ticks
  };
};

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 璁＄畻鏃堕棿鍧愭爣杞�
 * @author dxq613@gmail.com
 */
var AutoUtil = __webpack_require__(152);

var isNil = __webpack_require__(6);

var MAX_COUNT = 6;
var SNAP_ARRAY = [1, 2, 4, 6, 8, 12];
var MINUTE_MS = 60 * 1000;
var HOUR_MS = 3600 * 1000;
var DAY_MS = 24 * 3600 * 1000;

function getYear(date) {
  return new Date(date).getFullYear();
}

function createYear(year) {
  return new Date(year, 0, 1).getTime();
}

function getMonth(date) {
  return new Date(date).getMonth();
}

function diffMonth(min, max) {
  var minYear = getYear(min);
  var maxYear = getYear(max);
  var minMonth = getMonth(min);
  var maxMonth = getMonth(max);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}

function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}

function diffDay(min, max) {
  return Math.ceil((max - min) / DAY_MS);
}

function diffHour(min, max) {
  return Math.ceil((max - min) / HOUR_MS);
}

function diffMinus(min, max) {
  return Math.ceil((max - min) / (60 * 1000));
}

module.exports = function (info) {
  var minInterval = info.minInterval;
  var ticks = [];
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var count; // 濡傛灉鏈€澶у€煎拰鏈€灏忓€肩浉绛夛紝鍒欒缃渶澶у€煎ぇ浜庢渶灏忓€间竴澶�

  if (max === min) {
    max = min + DAY_MS;
  } // 璁＄畻闂磋窛


  if (isNil(interval)) {
    var innerTime = max - min;
    var dms = DAY_MS; // 澶╀唬琛ㄧ殑绉�

    var yms = 365 * dms; // 骞翠唬琛ㄧ殑绉�

    interval = parseInt(innerTime / (info.maxCount || MAX_COUNT), 10);

    if (minInterval && minInterval > interval) {
      interval = minInterval;
    }

    var yfactor = interval / yms;
    var minYear = getYear(min); // 澶т簬鍗婂勾

    if (yfactor > 0.51) {
      var year = Math.ceil(yfactor); // interval = year * yms;

      var maxYear = getYear(max);

      for (var i = minYear; i <= maxYear + year; i = i + year) {
        ticks.push(createYear(i));
      }

      interval = null;
    } else if (yfactor > 0.0834) {
      // 澶т簬涓€涓湀
      var month = Math.ceil(yfactor / 0.0834);
      var mmMoth = getMonth(min);
      var dMonths = diffMonth(min, max);

      for (var _i = 0; _i <= dMonths + month; _i = _i + month) {
        ticks.push(creatMonth(minYear, _i + mmMoth));
      }

      interval = null;
    } else if (interval > dms * 0.5) {
      // 澶т簬涓€澶�
      var date = new Date(min);

      var _year = date.getFullYear();

      var _month = date.getMonth(min);

      var mday = date.getDate();
      var day = Math.ceil(interval / dms);
      var ddays = diffDay(min, max);
      interval = day * dms;

      for (var _i2 = 0; _i2 < ddays + day; _i2 = _i2 + day) {
        ticks.push(new Date(_year, _month, mday + _i2).getTime());
      }
    } else if (interval > HOUR_MS) {
      // 澶т簬涓€涓皬鏃�
      var _date = new Date(min);

      var _year2 = _date.getFullYear();

      var _month2 = _date.getMonth(min);

      var _day = _date.getDate();

      var hour = _date.getHours();

      var hours = AutoUtil.snapTo(SNAP_ARRAY, Math.ceil(interval / HOUR_MS));
      var dHours = diffHour(min, max);
      interval = hours * HOUR_MS;

      for (var _i3 = 0; _i3 <= dHours + hours; _i3 = _i3 + hours) {
        ticks.push(new Date(_year2, _month2, _day, hour + _i3).getTime());
      }
    } else if (interval > MINUTE_MS) {
      // 鏈€灏忓崟浣嶆槸鍒嗛挓
      var dMinus = diffMinus(min, max);
      var minutes = Math.ceil(interval / MINUTE_MS);
      interval = minutes * MINUTE_MS;

      for (var _i4 = 0; _i4 <= dMinus + minutes; _i4 = _i4 + minutes) {
        ticks.push(min + _i4 * MINUTE_MS);
      }
    } else {
      if (interval < 1000) {
        interval = 1000;
      }

      min = Math.floor(min / 1000) * 1000;
      var dSeconds = Math.ceil((max - min) / 1000);
      var seconds = Math.ceil(interval / 1000);
      interval = seconds * 1000;

      for (var _i5 = 0; _i5 < dSeconds + seconds; _i5 = _i5 + seconds) {
        ticks.push(min + _i5 * 1000);
      }
    }
  }

  if (!ticks.length) {
    min = Math.floor(min / 1000) * 1000;
    max = Math.ceil(max / 1000) * 1000;
    count = (max - min) / interval;

    for (var _i6 = 0; _i6 <= count; _i6++) {
      ticks.push(AutoUtil.fixedBase(interval * _i6 + min, interval));
    }
  }

  return {
    max: max,
    min: min,
    interval: interval,
    ticks: ticks,
    count: ticks.length
  };
};

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Base = __webpack_require__(26);

var isNumber = __webpack_require__(11);

var Identity =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Identity, _Base);

  function Identity() {
    return _Base.apply(this, arguments) || this;
  }

  var _proto = Identity.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Base.prototype._initDefaultCfg.call(this);

    this.isIdentity = true;
    this.type = 'identity';
    /**
     * 甯搁噺鍊�
     * @type {*}
     */

    this.value = null;
  }
  /**
   * @override
   */
  ;

  _proto.getText = function getText() {
    return this.value.toString();
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    if (this.value !== value && isNumber(value)) {
      return value;
    }

    return this.range[0];
  }
  /**
   * @override
   */
  ;

  _proto.invert = function invert() {
    return this.value;
  };

  return Identity;
}(Base);

Base.Identity = Identity;
module.exports = Identity;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 浣跨敤搴﹂噺锛岃繘琛宭og杞崲
 * @author dxq613@gmail.com
 */
var each = __webpack_require__(2);

var Base = __webpack_require__(26);

var Linear = __webpack_require__(51); // 璁＄畻log


function log(a, b) {
  if (a === 1) {
    return 1;
  }

  return Math.log(b) / Math.log(a);
}
/**
 * 搴﹂噺鐨刲og璁＄畻
 * @class Scale.Log
 */


var Log =
/*#__PURE__*/
function (_Linear) {
  _inheritsLoose(Log, _Linear);

  function Log() {
    return _Linear.apply(this, arguments) || this;
  }

  var _proto = Log.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Linear.prototype._initDefaultCfg.call(this);

    this.type = 'log';
    /**
     * @override
     * log 鐨勫潗鏍囩偣鐨勪釜鏁版帶鍒跺湪10涓互涓�
     * @type {Number}
     */

    this.tickCount = 10;
    /**
     * 杩涜log璁＄畻鐨勫熀鏁�
     * @type {Number}
     */

    this.base = 2; // 鏈€灏忕殑tick锛屼粎鍐呴儴浣跨敤

    this._minTick = null;
  }
  /**
   * @override
   */
  ;

  _proto.calculateTicks = function calculateTicks() {
    var self = this;
    var base = self.base;
    var minTick;

    if (self.min < 0) {
      throw new Error('The minimum value must be greater than zero!');
    }

    var maxTick = log(base, self.max);

    if (self.min > 0) {
      minTick = Math.floor(log(base, self.min));
    } else {
      var values = self.values;
      var positiveMin = self.max; // 鏌ユ壘澶т簬0鐨勭涓€涓€�, 濡傛灉閮藉皬浜�0锛岄粯璁や负1

      each(values, function (value) {
        if (value > 0 && value < positiveMin) {
          positiveMin = value;
        }
      });

      if (positiveMin === self.max) {
        positiveMin = self.max / base;
      }

      if (positiveMin > 1) {
        positiveMin = 1;
      }

      minTick = Math.floor(log(base, positiveMin));
      self._minTick = minTick;
      self.positiveMin = positiveMin;
    }

    var count = maxTick - minTick;
    var tickCount = self.tickCount;
    var avg = Math.ceil(count / tickCount);
    var ticks = [];

    for (var i = minTick; i < maxTick + avg; i = i + avg) {
      ticks.push(Math.pow(base, i));
    }

    if (self.min === 0) {
      ticks.unshift(0);
    }

    return ticks;
  } // 鑾峰彇搴﹂噺璁＄畻鏃讹紝value鍗犵殑瀹氫箟鍩熺櫨鍒嗘瘮
  ;

  _proto._getScalePercent = function _getScalePercent(value) {
    var max = this.max;
    var min = this.min;

    if (max === min) {
      return 0;
    } // 濡傛灉鍊煎皬浜庣瓑浜�0锛屽垯鎸夌収0澶勭悊


    if (value <= 0) {
      return 0;
    }

    var base = this.base;
    var positiveMin = this.positiveMin; // 濡傛灉min == 0, 鍒欐牴鎹瘮0澶х殑鏈€灏忓€硷紝璁＄畻姣斾緥鍏崇郴銆傝繖涓渶灏忓€间綔涓哄潗鏍囪酱涓婄殑绗簩涓猼ick锛岀涓€涓槸0浣嗘槸涓嶆樉绀�

    if (positiveMin) {
      min = positiveMin * 1 / base;
    }

    var percent; // 濡傛灉鏁板€煎皬浜庢灏忓€硷紝閭ｄ箞灏辫绠� value / 娆″皬鍊� 鍗犳暣浣撶殑姣斾緥

    if (value < positiveMin) {
      percent = value / positiveMin / (log(base, max) - log(base, min));
    } else {
      percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
    }

    return percent;
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    var percent = this._getScalePercent(value);

    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  }
  /**
   * @override
   */
  ;

  _proto.invert = function invert(value) {
    var base = this.base;
    var max = log(base, this.max);
    var rangeMin = this.rangeMin();
    var range = this.rangeMax() - rangeMin;
    var min;
    var positiveMin = this.positiveMin;

    if (positiveMin) {
      if (value === 0) {
        return 0;
      }

      min = log(base, positiveMin / base);
      var appendPercent = 1 / (max - min) * range; // 0 鍒� positiveMin鐨勫崰姣�

      if (value < appendPercent) {
        // 钀藉埌 0 - positiveMin 涔嬮棿
        return value / appendPercent * positiveMin;
      }
    } else {
      min = log(base, this.min);
    }

    var percent = (value - rangeMin) / range;
    var tmp = percent * (max - min) + min;
    return Math.pow(base, tmp);
  };

  return Log;
}(Linear);

Base.Log = Log;
module.exports = Log;

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 浣跨敤pow杩涜搴﹂噺璁＄畻
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(26);

var Linear = __webpack_require__(51); // 姹備互a涓烘骞傦紝缁撴灉涓篵鐨勫熀鏁帮紝濡� x^^a = b;姹倄


function calBase(a, b) {
  var e = Math.E;
  var value = Math.pow(e, Math.log(b) / a); // 浣跨敤鎹㈠簳鍏紡姹傚簳

  return value;
}
/**
 * 搴﹂噺鐨凱ow璁＄畻
 * @class Scale.Log
 */


var Pow =
/*#__PURE__*/
function (_Linear) {
  _inheritsLoose(Pow, _Linear);

  function Pow() {
    return _Linear.apply(this, arguments) || this;
  }

  var _proto = Pow.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Linear.prototype._initDefaultCfg.call(this);

    this.type = 'pow';
    /**
     * @override
     * pow 鐨勫潗鏍囩偣鐨勪釜鏁版帶鍒跺湪10涓互涓�
     * @type {Number}
     */

    this.tickCount = 10;
    /**
     * 杩涜pow璁＄畻鐨勫熀鏁�
     * @type {Number}
     */

    this.exponent = 2;
  }
  /**
   * @override
   */
  ;

  _proto.calculateTicks = function calculateTicks() {
    var self = this;
    var exponent = self.exponent;
    var min;
    var max = Math.ceil(calBase(exponent, self.max));

    if (self.min >= 0) {
      min = Math.floor(calBase(exponent, self.min));
    } else {
      min = 0;
    }

    if (min > max) {
      var tmp = max;
      max = min;
      min = tmp;
    }

    var count = max - min;
    var tickCount = self.tickCount;
    var avg = Math.ceil(count / tickCount);
    var ticks = [];

    for (var i = min; i < max + avg; i = i + avg) {
      ticks.push(Math.pow(i, exponent));
    }

    return ticks;
  } // 鑾峰彇搴﹂噺璁＄畻鏃讹紝value鍗犵殑瀹氫箟鍩熺櫨鍒嗘瘮
  ;

  _proto._getScalePercent = function _getScalePercent(value) {
    var max = this.max;
    var min = this.min;

    if (max === min) {
      return 0;
    }

    var exponent = this.exponent;
    var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
    return percent;
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    var percent = this._getScalePercent(value);

    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  }
  /**
   * @override
   */
  ;

  _proto.invert = function invert(value) {
    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    var exponent = this.exponent;
    var max = calBase(exponent, this.max);
    var min = calBase(exponent, this.min);
    var tmp = percent * (max - min) + min;
    return Math.pow(tmp, exponent);
  };

  return Pow;
}(Linear);

Base.Pow = Pow;
module.exports = Pow;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview 鏃堕棿鏁版嵁浣滀负鍒嗙被绫诲瀷
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(26);

var Category = __webpack_require__(153);

var fecha = __webpack_require__(222);

var catAuto = __webpack_require__(151);

var TimeUtil = __webpack_require__(52);

var each = __webpack_require__(2);

var isNumber = __webpack_require__(11);

var isObject = __webpack_require__(39);

var isString = __webpack_require__(15);
/**
 * 搴﹂噺鐨勬瀯閫犲嚱鏁�
 * @class Scale.TimeCategory
 */


var TimeCategory =
/*#__PURE__*/
function (_Category) {
  _inheritsLoose(TimeCategory, _Category);

  function TimeCategory() {
    return _Category.apply(this, arguments) || this;
  }

  var _proto = TimeCategory.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Category.prototype._initDefaultCfg.call(this);

    this.type = 'timeCat';
    /**
     * 鏄惁闇€瑕佹帓搴忥紝榛樿杩涜鎺掑簭
     * @type {Boolean}
     */

    this.sortable = true;
    this.tickCount = 5;
    /**
     * 鏃堕棿鏍煎紡鍖�
     * @type {String}
     */

    this.mask = 'YYYY-MM-DD';
  };

  _proto.init = function init() {
    var self = this;
    var values = this.values; // 閽堝鏃堕棿鍒嗙被绫诲瀷锛屼細灏嗘椂闂寸粺涓€杞崲涓烘椂闂存埑

    each(values, function (v, i) {
      values[i] = self._toTimeStamp(v);
    });

    if (this.sortable) {
      // 鍏佽鎺掑簭
      values.sort(function (v1, v2) {
        return v1 - v2;
      });
    }

    if (!self.ticks) {
      self.ticks = this.calculateTicks();
    }
  }
  /**
   * 璁＄畻 ticks
   * @return {array} 杩斿洖 ticks 鏁扮粍
   */
  ;

  _proto.calculateTicks = function calculateTicks() {
    var self = this;
    var count = self.tickCount;
    var ticks;

    if (count) {
      var temp = catAuto({
        maxCount: count,
        data: self.values,
        isRounding: self.isRounding
      });
      ticks = temp.ticks;
    } else {
      ticks = self.values;
    }

    return ticks;
  }
  /**
   * @override
   */
  ;

  _proto.translate = function translate(value) {
    value = this._toTimeStamp(value);
    var index = this.values.indexOf(value);

    if (index === -1) {
      if (isNumber(value) && value < this.values.length) {
        index = value;
      } else {
        index = NaN;
      }
    }

    return index;
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var index = this.translate(value);
    var percent;

    if (this.values.length === 1 || isNaN(index)) {
      // is index is NAN should not be set as 0
      percent = index;
    } else if (index > -1) {
      percent = index / (this.values.length - 1);
    } else {
      percent = 0;
    }

    return rangeMin + percent * (rangeMax - rangeMin);
  }
  /**
   * @override
   */
  ;

  _proto.getText = function getText(value) {
    var result = '';
    var index = this.translate(value);

    if (index > -1) {
      result = this.values[index];
    } else {
      result = value;
    }

    var formatter = this.formatter;
    result = parseInt(result, 10);
    result = formatter ? formatter(result) : fecha.format(result, this.mask);
    return result;
  }
  /**
   * @override
   */
  ;

  _proto.getTicks = function getTicks() {
    var self = this;
    var ticks = this.ticks;
    var rst = [];
    each(ticks, function (tick) {
      var obj;

      if (isObject(tick)) {
        obj = tick;
      } else {
        obj = {
          text: isString(tick) ? tick : self.getText(tick),
          value: self.scale(tick),
          tickValue: tick // 鐢ㄤ簬鍧愭爣杞翠笂鏂囨湰鍔ㄧ敾鏃剁‘瀹氬墠鍚庡抚鐨勫搴斿叧绯�

        };
      }

      rst.push(obj);
    });
    return rst;
  } // 灏嗘椂闂磋浆鎹负鏃堕棿鎴�
  ;

  _proto._toTimeStamp = function _toTimeStamp(value) {
    return TimeUtil.toTimeStamp(value);
  };

  return TimeCategory;
}(Category);

Base.TimeCat = TimeCategory;
module.exports = TimeCategory;

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */
var fecha = __webpack_require__(222);

var each = __webpack_require__(2);

var isNil = __webpack_require__(6);

var isString = __webpack_require__(15);

var Base = __webpack_require__(26);

var Linear = __webpack_require__(51);

var timeAuto = __webpack_require__(352);

var TimeUtil = __webpack_require__(52);
/**
 * 鏃堕棿搴﹂噺鐨勬瀯閫犲嚱鏁�
 * @class Scale.Time
 */


var Time =
/*#__PURE__*/
function (_Linear) {
  _inheritsLoose(Time, _Linear);

  function Time() {
    return _Linear.apply(this, arguments) || this;
  }

  var _proto = Time.prototype;

  _proto._initDefaultCfg = function _initDefaultCfg() {
    _Linear.prototype._initDefaultCfg.call(this);

    this.type = 'time';
    this.mask = 'YYYY-MM-DD';
  }
  /**
   * @override
   */
  ;

  _proto.init = function init() {
    var self = this;
    var values = self.values;

    if (values && values.length) {
      // 閲嶆柊璁＄畻鏈€澶ф渶灏忓€�
      var timeStamps = [];
      var min = Infinity; // 鏈€灏忓€�

      var secondMin = min; // 娆″皬鍊�

      var max = 0; // 浣跨敤涓€涓惊鐜紝璁＄畻min,max,secondMin

      each(values, function (v) {
        var timeStamp = self._toTimeStamp(v);

        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v);
        }

        if (min > timeStamp) {
          secondMin = min;
          min = timeStamp;
        } else if (secondMin > timeStamp) {
          secondMin = timeStamp;
        }

        if (max < timeStamp) {
          max = timeStamp;
        }

        timeStamps.push(timeStamp);
      }); // 瀛樺湪澶氫釜鍊兼椂锛岃缃渶灏忛棿璺�

      if (values.length > 1) {
        self.minTickInterval = secondMin - min;
      }

      if (isNil(self.min) || self._toTimeStamp(self.min) > min) {
        self.min = min;
      }

      if (isNil(self.max) || self._toTimeStamp(self.max) < max) {
        self.max = max;
      }
    }

    _Linear.prototype.init.call(this);
  };

  _proto.calculateTicks = function calculateTicks() {
    var self = this;
    var min = self.min;
    var max = self.max;
    var count = self.tickCount;
    var interval = self.tickInterval;
    var tmp = timeAuto({
      min: min,
      max: max,
      minCount: count,
      maxCount: count,
      interval: interval,
      minInterval: self.minTickInterval
    });
    return tmp.ticks;
  }
  /**
   * @override
   */
  ;

  _proto.getText = function getText(value) {
    var formatter = this.formatter;
    value = this.translate(value);
    value = formatter ? formatter(value) : fecha.format(value, this.mask);
    return value;
  }
  /**
   * @override
   */
  ;

  _proto.scale = function scale(value) {
    if (isString(value)) {
      value = this.translate(value);
    }

    return _Linear.prototype.scale.call(this, value);
  }
  /**
   * @override
   */
  ;

  _proto.translate = function translate(value) {
    return this._toTimeStamp(value);
  } // 灏嗘椂闂磋浆鎹负鏃堕棿鎴�
  ;

  _proto._toTimeStamp = function _toTimeStamp(value) {
    return TimeUtil.toTimeStamp(value);
  };

  return Time;
}(Linear);

Base.Time = Time;
module.exports = Time;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var filter = __webpack_require__(82);
var contains = __webpack_require__(53);

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to inspect.
 * @param {Array} values The values to exclude.
 * @return {Array} Returns the new array of filtered values.
 * @example
 * difference([2, 1], [2, 3]);  // => [1]
 */
var difference = function difference(arr) {
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  return filter(arr, function (value) {
    return !contains(values, value);
  });
};

module.exports = difference;

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(14);
var isPlainObject = __webpack_require__(40);
var isMatch = __webpack_require__(177);

function find(arr, predicate) {
  var _predicate = void 0;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (isPlainObject(predicate)) {
    _predicate = function _predicate(a) {
      return isMatch(a, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}

module.exports = find;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(6);
var isArray = __webpack_require__(4);

var firstValue = function firstValue(data, name) {
  var rst = null;
  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];
    if (!isNil(value)) {
      if (isArray(value)) {
        rst = value[0];
      } else {
        rst = value;
      }
      break;
    }
  }
  return rst;
};

module.exports = firstValue;

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @param {Array} result The array to return.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
 */
var flattenDeep = function flattenDeep(arr) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!isArray(arr)) {
    result.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], result);
    }
  }
  return result;
};

module.exports = flattenDeep;

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var each = __webpack_require__(2);

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
 */
var flatten = function flatten(arr) {
  if (!isArray(arr)) {
    return arr;
  }
  var result = [];
  each(arr, function (item) {
    if (isArray(item)) {
      each(item, function (subItem) {
        result.push(subItem);
      });
    } else {
      result.push(item);
    }
  });
  return result;
};

module.exports = flatten;

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

var filter = __webpack_require__(82);
var isArray = __webpack_require__(4);

var getRange = function getRange(values) {
  // 瀛樺湪 NaN 鏃讹紝min,max 鍒ゅ畾浼氬嚭闂
  values = filter(values, function (v) {
    return !isNaN(v);
  });
  if (!values.length) {
    // 濡傛灉娌℃湁鏁板€煎垯鐩存帴杩斿洖0
    return {
      min: 0,
      max: 0
    };
  }
  if (isArray(values[0])) {
    var tmp = [];
    for (var i = 0; i < values.length; i++) {
      tmp = tmp.concat(values[i]);
    }
    values = tmp;
  }
  var max = Math.max.apply(null, values);
  var min = Math.min.apply(null, values);
  return {
    min: min,
    max: max
  };
};

module.exports = getRange;

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  contains: __webpack_require__(53),
  difference: __webpack_require__(358),
  find: __webpack_require__(359),
  firstValue: __webpack_require__(360),
  flatten: __webpack_require__(362),
  flattenDeep: __webpack_require__(361),
  getRange: __webpack_require__(363),
  merge: __webpack_require__(54),
  pull: __webpack_require__(156),
  pullAt: __webpack_require__(155),
  reduce: __webpack_require__(365),
  remove: __webpack_require__(366),
  sortBy: __webpack_require__(367),
  union: __webpack_require__(368),
  uniq: __webpack_require__(157),
  valuesOfKey: __webpack_require__(79)
};

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var isPlainObject = __webpack_require__(40);
var each = __webpack_require__(2);

var reduce = function reduce(arr, fn, init) {
  if (!isArray(arr) && !isPlainObject(arr)) {
    return arr;
  }
  var result = init;
  each(arr, function (data, i) {
    result = fn(result, data, i);
  });
  return result;
};

module.exports = reduce;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);
var pullAt = __webpack_require__(155);

var remove = function remove(arr, predicate) {
  /**
   * const arr = [1, 2, 3, 4]
   * const evens = remove(arr, n => n % 2 == 0)
   * console.log(arr) // => [1, 3]
   * console.log(evens) // => [2, 4]
   */
  var result = [];
  if (!isArrayLike(arr)) {
    return result;
  }
  var i = -1;
  var indexes = [];
  var length = arr.length;

  while (++i < length) {
    var value = arr[i];
    if (predicate(value, i, arr)) {
      result.push(value);
      indexes.push(i);
    }
  }
  pullAt(arr, indexes);
  return result;
};

module.exports = remove;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var isString = __webpack_require__(15);
var isFunction = __webpack_require__(14);
var isArray = __webpack_require__(4);

function sortBy(arr, key) {
  var comparer = void 0;
  if (isFunction(key)) {
    comparer = function comparer(a, b) {
      return key(a) - key(b);
    };
  } else {
    var keys = [];
    if (isString(key)) {
      keys.push(key);
    } else if (isArray(key)) {
      keys = key;
    }
    comparer = function comparer(a, b) {
      for (var i = 0; i < keys.length; i += 1) {
        var prop = keys[i];
        if (a[prop] > b[prop]) {
          return 1;
        }
        if (a[prop] < b[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }

  arr.sort(comparer);
  return arr;
}

module.exports = sortBy;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var toArray = __webpack_require__(57);
var uniq = __webpack_require__(157);

var union = function union() {
  var result = [];
  var sources = toArray(arguments);
  each(sources, function (arr) {
    result = result.concat(arr);
  });
  return uniq(result);
};

module.exports = union;

/***/ }),
/* 369 */
/***/ (function(module, exports) {


function debounce(func, wait, immediate) {
  var timeout = void 0;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}

module.exports = debounce;

/***/ }),
/* 370 */
/***/ (function(module, exports) {

/**
 * 娣诲姞浜嬩欢鐩戝惉鍣�
 * @param  {Object} target DOM瀵硅薄
 * @param  {String} eventType 浜嬩欢鍚�
 * @param  {Funtion} callback 鍥炶皟鍑芥暟
 * @return {Object} 杩斿洖瀵硅薄
 */
module.exports = function addEventListener(target, eventType, callback) {
  if (target) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  }
};

/***/ }),
/* 371 */
/***/ (function(module, exports) {


module.exports = function getBoundingClientRect(node, defaultValue) {
  if (node && node.getBoundingClientRect) {
    var rect = node.getBoundingClientRect();
    var top = document.documentElement.clientTop;
    var left = document.documentElement.clientLeft;
    return {
      top: rect.top - top,
      bottom: rect.bottom - top,
      left: rect.left - left,
      right: rect.right - left
    };
  }
  return defaultValue || null;
};

/***/ }),
/* 372 */
/***/ (function(module, exports) {

/**
 * 鑾峰彇楂樺害
 * @param  {HTMLElement} el dom鑺傜偣
 * @param  {Number} defaultValue 榛樿鍊�
 * @return {Number} 楂樺害
 */
module.exports = function getHeight(el, defaultValue) {
  var height = this.getStyle(el, 'height', defaultValue);
  if (height === 'auto') {
    height = el.offsetHeight;
  }
  return parseFloat(height);
};

/***/ }),
/* 373 */
/***/ (function(module, exports) {

/**
 * 鑾峰彇澶栧眰楂樺害
 * @param  {HTMLElement} el dom鑺傜偣
 * @param  {Number} defaultValue 榛樿鍊�
 * @return {Number} 楂樺害
 */
module.exports = function getOuterHeight(el, defaultValue) {
  var height = this.getHeight(el, defaultValue);
  var bTop = parseFloat(this.getStyle(el, 'borderTopWidth')) || 0;
  var pTop = parseFloat(this.getStyle(el, 'paddingTop')) || 0;
  var pBottom = parseFloat(this.getStyle(el, 'paddingBottom')) || 0;
  var bBottom = parseFloat(this.getStyle(el, 'borderBottomWidth')) || 0;
  return height + bTop + bBottom + pTop + pBottom;
};

/***/ }),
/* 374 */
/***/ (function(module, exports) {

/**
 * 鑾峰彇澶栧眰瀹藉害
 * @param  {HTMLElement} el dom鑺傜偣
 * @param  {Number} defaultValue 榛樿鍊�
 * @return {Number} 瀹藉害
 */
module.exports = function getOuterWidth(el, defaultValue) {
  var width = this.getWidth(el, defaultValue);
  var bLeft = parseFloat(this.getStyle(el, 'borderLeftWidth')) || 0;
  var pLeft = parseFloat(this.getStyle(el, 'paddingLeft')) || 0;
  var pRight = parseFloat(this.getStyle(el, 'paddingRight')) || 0;
  var bRight = parseFloat(this.getStyle(el, 'borderRightWidth')) || 0;
  return width + bLeft + bRight + pLeft + pRight;
};

/***/ }),
/* 375 */
/***/ (function(module, exports) {


module.exports = function getRatio() {
  return window.devicePixelRatio ? window.devicePixelRatio : 2;
};

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(6);

/**
 * 鑾峰彇鏍峰紡
 * @param  {Object} dom DOM鑺傜偣
 * @param  {String} name 鏍峰紡鍚�
 * @param  {Any} defaultValue 榛樿鍊�
 * @return {String} 灞炴€у€�
 */
module.exports = function getStyle(dom, name, defaultValue) {
  try {
    if (window.getComputedStyle) {
      return window.getComputedStyle(dom, null)[name];
    }
    return dom.currentStyle[name];
  } catch (e) {
    if (!isNil(defaultValue)) {
      return defaultValue;
    }
    return null;
  }
};

/***/ }),
/* 377 */
/***/ (function(module, exports) {

/**
 * 鑾峰彇瀹藉害
 * @param  {HTMLElement} el  dom鑺傜偣
 * @param  {Number} defaultValue 榛樿鍊�
 * @return {Number} 瀹藉害
 */
module.exports = function getWidth(el, defaultValue) {
  var width = this.getStyle(el, 'width', defaultValue);
  if (width === 'auto') {
    width = el.offsetWidth;
  }
  return parseFloat(width);
};

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  addEventListener: __webpack_require__(370),
  createDom: __webpack_require__(159),
  getBoundingClientRect: __webpack_require__(371),
  getHeight: __webpack_require__(372),
  getOuterHeight: __webpack_require__(373),
  getOuterWidth: __webpack_require__(374),
  getRatio: __webpack_require__(375),
  getStyle: __webpack_require__(376),
  getWidth: __webpack_require__(377),
  modifyCSS: __webpack_require__(160),
  requestAnimationFrame: __webpack_require__(161)
};

/***/ }),
/* 379 */
/***/ (function(module, exports) {

/**
 * 鑾峰彇灏佽鐨勪簨浠�
 * @protected
 * @param  {Object} obj   瀵硅薄
 * @param  {String} action 浜嬩欢鍚嶇О
 * @return {Function}        杩斿洖浜嬩欢澶勭悊鍑芥暟
 */
function getWrapBehavior(obj, action) {
  return obj['_wrap_' + action];
}

module.exports = getWrapBehavior;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  getWrapBehavior: __webpack_require__(379),
  wrapBehavior: __webpack_require__(381)
};

/***/ }),
/* 381 */
/***/ (function(module, exports) {

/**
 * 灏佽浜嬩欢锛屼究浜庝娇鐢ㄤ笂涓嬫枃this,鍜屼究浜庤В闄や簨浠舵椂浣跨敤
 * @protected
 * @param  {Object} obj   瀵硅薄
 * @param  {String} action 浜嬩欢鍚嶇О
 * @return {Function}        杩斿洖浜嬩欢澶勭悊鍑芥暟
 */
function wrapBehavior(obj, action) {
  if (obj['_wrap_' + action]) {
    return obj['_wrap_' + action];
  }
  var method = function method(e) {
    obj[action](e);
  };
  obj['_wrap_' + action] = method;
  return method;
}

module.exports = wrapBehavior;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

var number2color = __webpack_require__(383);

module.exports = {
  number2color: number2color,
  numberToColor: number2color,
  parsePath: __webpack_require__(384),
  parseRadius: __webpack_require__(385)
};

/***/ }),
/* 383 */
/***/ (function(module, exports) {

var numColorCache = {};

module.exports = function numberToColor(num) {
  // 澧炲姞缂撳瓨
  var color = numColorCache[num];
  if (!color) {
    var str = num.toString(16);
    for (var i = str.length; i < 6; i++) {
      str = '0' + str;
    }
    color = '#' + str;
    numColorCache[num] = color;
  }
  return color;
};

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var isString = __webpack_require__(15);
var each = __webpack_require__(2);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;

module.exports = function parsePath(path) {
  path = path || [];
  if (isArray(path)) {
    return path;
  }

  if (isString(path)) {
    path = path.match(regexTags);
    each(path, function (item, index) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each(item, function (sub, i) {
        if (!isNaN(sub)) {
          item[i] = +sub;
        }
      });
      path[index] = item;
    });
    return path;
  }
};

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);

module.exports = function parseRadius(radius) {
  var r1 = 0,
      r2 = 0,
      r3 = 0,
      r4 = 0;
  if (isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1: r1,
    r2: r2,
    r3: r3,
    r4: r4
  };
};

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(21);

var indexOf = function indexOf(arr, obj) {
  if (!isArrayLike(arr)) {
    return -1;
  }
  var m = Array.prototype.indexOf;
  if (m) {
    return m.call(arr, obj);
  }
  var index = -1;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index = i;
      break;
    }
  }
  return index;
};

module.exports = indexOf;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(14);
var isEqual = __webpack_require__(83);
/**
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [fn] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * isEqualWith(array, other, customizer);  // => true
 */

var isEqualWith = function isEqualWith(value, other, fn) {
  if (!isFunction(fn)) {
    return isEqual(value, other);
  }
  return !!fn(value, other);
};

module.exports = isEqualWith;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isArrayLike = __webpack_require__(21);

var map = function map(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  each(arr, function (value, index) {
    result.push(func(value, index));
  });
  return result;
};

module.exports = map;

/***/ }),
/* 389 */
/***/ (function(module, exports) {

var fixedBase = function fixedBase(v, base) {
  var str = base.toString();
  var index = str.indexOf('.');
  if (index === -1) {
    return Math.round(v);
  }
  var length = str.substr(index + 1).length;
  if (length > 20) {
    length = 20;
  }
  return parseFloat(v.toFixed(length));
};

module.exports = fixedBase;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

var isNumberEqual = __webpack_require__(55);

module.exports = {
  clamp: __webpack_require__(84),
  fixedBase: __webpack_require__(389),
  isDecimal: __webpack_require__(391),
  isEven: __webpack_require__(392),
  isInteger: __webpack_require__(393),
  isNegative: __webpack_require__(394),
  isNumberEqual: isNumberEqual,
  isOdd: __webpack_require__(395),
  isPositive: __webpack_require__(396),
  maxBy: __webpack_require__(168),
  minBy: __webpack_require__(397),
  mod: __webpack_require__(169),
  snapEqual: isNumberEqual,
  toDegree: __webpack_require__(170),
  toInt: __webpack_require__(171),
  toInteger: __webpack_require__(171),
  toRadian: __webpack_require__(172)
};

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isDecimal = function isDecimal(num) {
  return isNumber(num) && num % 1 !== 0;
};

module.exports = isDecimal;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isEven = function isEven(num) {
  return isNumber(num) && num % 2 === 0;
};

module.exports = isEven;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isInteger = Number.isInteger ? Number.isInteger : function (num) {
  return isNumber(num) && num % 1 === 0;
};

module.exports = isInteger;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isNagative = function isNagative(num) {
  return isNumber(num) && num < 0;
};

module.exports = isNagative;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isOdd = function isOdd(num) {
  return isNumber(num) && num % 2 !== 0;
};

module.exports = isOdd;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(11);

var isPositive = function isPositive(num) {
  return isNumber(num) && num > 0;
};

module.exports = isPositive;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var isFunction = __webpack_require__(14);
var each = __webpack_require__(2);
/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * minBy(objects, 'n');
 * // => { 'n': 1 }
 */
var minBy = function minBy(arr, fn) {
  if (!isArray(arr)) {
    return undefined;
  }
  var min = arr[0];
  var minData = void 0;
  if (isFunction(fn)) {
    minData = fn(arr[0]);
  } else {
    minData = arr[0][fn];
  }
  var data = void 0;
  each(arr, function (val) {
    if (isFunction(fn)) {
      data = fn(val);
    } else {
      data = val[fn];
    }
    if (data < minData) {
      min = val;
      minData = data;
    }
  });
  return min;
};

module.exports = minBy;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(176);

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var contains = __webpack_require__(53);
var values = __webpack_require__(179);

module.exports = function (obj, value) {
  return contains(values(obj), value);
};

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  forIn: __webpack_require__(398),
  has: __webpack_require__(176),
  hasKey: __webpack_require__(399),
  hasValue: __webpack_require__(400),
  keys: __webpack_require__(178),
  isMatch: __webpack_require__(177),
  values: __webpack_require__(179)
};

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var isEqual = __webpack_require__(406);

function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;
  if (add < min) {
    min = add;
    type = 'add';
  }
  if (del < min) {
    min = del;
    type = 'del';
  }
  return {
    type: type,
    min: min
  };
}

/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * 璁＄畻涓ゆ潯path鐨勭紪杈戣窛绂�
 */
var levenshteinDistance = function levenshteinDistance(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment = void 0,
      targetSegment = void 0;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = { min: j };
  }

  for (var _i = 1; _i <= sourceLen; _i++) {
    sourceSegment = source[_i - 1];
    for (var _j = 1; _j <= targetLen; _j++) {
      targetSegment = target[_j - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[_i - 1][_j].min + 1;
      var add = dist[_i][_j - 1].min + 1;
      var modify = dist[_i - 1][_j - 1].min + temp;
      dist[_i][_j] = getMinDiff(del, add, modify);
    }
  }
  return dist;
};

module.exports = function fillPathByDiff(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  // 濡傛灉source鍜宼arget涓嶆槸瀹屽叏涓嶇浉绛�
  if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
    // 鑾峰彇浠巗ource鍒皌arget鎵€闇€鏀瑰姩
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index = minPos;
      if (diffMatrix[i][index].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index].type });
      }
    }
    // 瀵箂ource杩涜澧炲垹path
    for (var _i2 = changes.length - 1; _i2 >= 0; _i2--) {
      index = changes[_i2].index;
      if (changes[_i2].type === 'add') {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }

  // source灏鹃儴琛ラ綈
  sourceLen = source.length;
  if (sourceLen < targetLen) {
    for (var _i3 = 0; _i3 < targetLen - sourceLen; _i3++) {
      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
    }
  }
  return source;
};

/***/ }),
/* 403 */
/***/ (function(module, exports) {

function decasteljau(points, t) {
  var left = [];
  var right = [];

  function recurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points.length - 1; i++) {
        if (i === 0) {
          left.push(points[0]);
        }
        if (i === points.length - 2) {
          right.push(points[i + 1]);
        }
        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }
      recurse(middlePoints, t);
    }
  }
  if (points.length) {
    recurse(points, t);
  }
  return { left: left, right: right.reverse() };
}

function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end[0] === 'A') {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === 'C') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === 'S' || end[0] === 'Q') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }

  var leftSegments = points;
  var t = 1 / count;

  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function (segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push('C');
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push('Q');
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push('L');
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}

function splitSegment(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === 'M') {
      temp[0] = 'L';
    }
    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
}

module.exports = function fillPath(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === 'M') {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var _i = 0; _i < targetLen; _i++) {
    var index = Math.floor(ratio * _i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function (filled, count, i) {
    if (i === sourceLen) {
      return filled.concat(source[sourceLen]);
    }
    return filled.concat(splitSegment(source[i], source[i + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
    filled.push('Z');
  }
  return filled;
};

/***/ }),
/* 404 */
/***/ (function(module, exports) {

/*
 * 鎶藉彇pathSegment涓殑鍏抽敭鐐�
 * M,L,A,Q,H,V涓€涓鐐�
 * Q, S鎶藉彇涓€涓鐐癸紝涓€涓帶鍒剁偣
 * C鎶藉彇涓€涓鐐癸紝涓や釜鎺у埗鐐�
 */
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case 'M':
      points.push([segment[1], segment[2]]);
      break;
    case 'L':
      points.push([segment[1], segment[2]]);
      break;
    case 'A':
      points.push([segment[6], segment[7]]);
      break;
    case 'Q':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case 'T':
      points.push([segment[1], segment[2]]);
      break;
    case 'C':
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case 'S':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case 'H':
      points.push([segment[1], segment[1]]);
      break;
    case 'V':
      points.push([segment[1], segment[1]]);
      break;
    default:

  }
  return points;
}

// 灏嗕袱涓偣鍧囧垎鎴恈ount涓偣
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index = void 0;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);
    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    }
  }
  return result;
}

module.exports = function formatPath(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points = void 0;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      // 鑾峰彇fromPath鐨刾athSegment鐨勭鐐癸紝鏍规嵁toPath鐨勬寚浠ゅ鍏舵敼閫�
      points = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case 'M':
          fromPath[i] = ['M'].concat(points[0]);
          break;
        case 'L':
          fromPath[i] = ['L'].concat(points[0]);
          break;
        case 'A':
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case 'Q':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        case 'T':
          fromPath[i] = ['T'].concat(points[0]);
          break;
        case 'C':
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        case 'S':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {


var pathIntersection = __webpack_require__(407);
var path2absolute = __webpack_require__(183);
var path2curve = __webpack_require__(184);
var catmullRom2Bezier = __webpack_require__(180);

module.exports = {
  catmullRom2Bezier: catmullRom2Bezier,
  catmullRomToBezier: catmullRom2Bezier,
  fillPath: __webpack_require__(403),
  fillPathByDiff: __webpack_require__(402),
  formatPath: __webpack_require__(404),
  intersection: pathIntersection,
  pathIntersection: pathIntersection,
  parsePathArray: __webpack_require__(181),
  parsePathString: __webpack_require__(182),
  pathToAbsolute: path2absolute,
  path2absolute: path2absolute,
  pathTocurve: path2curve,
  path2curve: path2curve,
  rectPath: __webpack_require__(185)
};

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);

module.exports = function isEqual(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each(obj1, function (item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4);
var rectPath = __webpack_require__(185);
var pathTocurve = __webpack_require__(184);

var base3 = function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};

var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};

var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a = void 0;
  var b = void 0;
  var c = void 0;
  var t = void 0;

  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + sqrtb2ac) / (2 * a);
    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }
    var t2 = (-b - sqrtb2ac) / (2 * a);
    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length;
  var jlen = j;
  var mt = void 0;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;

  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};

var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};

var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};

var box = function box(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x: x,
    y: y,
    width: width,
    w: width,
    height: height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(' ')
  };
};

var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};

var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!isArray(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};

var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  // (mx > nx || my < ny) && (alpha += 180);
  return {
    x: x,
    y: y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha: alpha
  };
};

var interHelper = function interHelper(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var _i = 0; _i < n2 + 1; _i++) {
    var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));
    dots2.push({
      x: _d.x,
      y: _d.y,
      t: _i / n2
    });
  }
  for (var _i2 = 0; _i2 < n1; _i2++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[_i2];
      var di1 = dots1[_i2 + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res++;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }
  return res;
};

var interPathHelper = function interPathHelper(path1, path2, justCount) {
  path1 = pathTocurve(path1);
  path2 = pathTocurve(path2);
  var x1 = void 0;
  var y1 = void 0;
  var x2 = void 0;
  var y2 = void 0;
  var x1m = void 0;
  var y1m = void 0;
  var x2m = void 0;
  var y2m = void 0;
  var bez1 = void 0;
  var bez2 = void 0;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];
    if (pi[0] === 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};

module.exports = function pathIntersection(path1, path2) {
  return interPathHelper(path1, path2);
};

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(2);
var isPlaineObject = __webpack_require__(40);

var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 * pick(object, ['a', 'c']);  // => { 'a': 1, 'c': 3 }
 */

var pick = function pick(object, keys) {
  if (object === null || !isPlaineObject(object)) {
    return {};
  }
  var result = {};
  each(keys, function (key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

module.exports = pick;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {


var strUtil = {
  lc: __webpack_require__(410),
  lowerCase: __webpack_require__(186),
  lowerFirst: __webpack_require__(187),
  substitute: __webpack_require__(411),
  uc: __webpack_require__(412),
  upperCase: __webpack_require__(188),
  upperFirst: __webpack_require__(189)
};

module.exports = strUtil;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(186);

/***/ }),
/* 411 */
/***/ (function(module, exports) {

var substitute = function substitute(str, o) {
  if (!str || !o) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
    if (match.charAt(0) === '\\') {
      return match.slice(1);
    }
    return o[name] === undefined ? '' : o[name];
  });
};

module.exports = substitute;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(188);

/***/ }),
/* 413 */
/***/ (function(module, exports) {


function throttle(func, wait, options) {
  var timeout = void 0,
      context = void 0,
      args = void 0,
      result = void 0;
  var previous = 0;
  if (!options) options = {};

  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function throttled() {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function () {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}

module.exports = throttle;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(17);

var checkType = {
  getType: __webpack_require__(190),
  isArray: __webpack_require__(4),
  isArrayLike: __webpack_require__(21),
  isBoolean: __webpack_require__(191),
  isFunction: __webpack_require__(14),
  isNil: __webpack_require__(6),
  isNull: __webpack_require__(417),
  isNumber: __webpack_require__(11),
  isObject: __webpack_require__(39),
  isObjectLike: __webpack_require__(86),
  isPlainObject: __webpack_require__(40),
  isPrototype: __webpack_require__(193),
  isType: isType,
  isUndefined: __webpack_require__(419),
  isString: __webpack_require__(15),
  isRegExp: __webpack_require__(418),
  isDate: __webpack_require__(192),
  isArguments: __webpack_require__(415),
  isError: __webpack_require__(416)
};

module.exports = checkType;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 鏄惁鏄弬鏁扮被鍨�
 *
 * @param {Object} value 娴嬭瘯鐨勫€�
 * @return {Boolean}
 */
var isType = __webpack_require__(17);

var isArguments = function isArguments(value) {
  return isType(value, 'Arguments');
};

module.exports = isArguments;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 鏄惁鏄弬鏁扮被鍨�
 *
 * @param {Object} value 娴嬭瘯鐨勫€�
 * @return {Boolean}
 */
var isType = __webpack_require__(17);

var isError = function isError(value) {
  return isType(value, 'Error');
};

module.exports = isError;

/***/ }),
/* 417 */
/***/ (function(module, exports) {

var isNull = function isNull(value) {
  return value === null;
};

module.exports = isNull;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(17);

var isRegExp = function isRegExp(str) {
  return isType(str, 'RegExp');
};

module.exports = isRegExp;

/***/ }),
/* 419 */
/***/ (function(module, exports) {

var isUndefined = function isUndefined(value) {
  return value === undefined;
};

module.exports = isUndefined;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Base2.default.generateBaseTypedComponent('Axis'); /**
                                                                      * Axis Component
                                                                      */

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(42);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(545);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Empty Component
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 鐢� g2 鍒涘缓 chart 涓€寮€濮嬫病鏈夋暟鎹紝鏈夋暟鎹椂瀵瑰綋鍓� chart 鏇存柊鏁版嵁鏃讹紝浼氭湁闂銆�
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 鍥犳鐢ㄤ簡 Empty 浣滀负鏃犳暟鎹� chart锛孭ureChart 浣滀负鏈夋暟鎹殑 chart銆�
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


(0, _warning2.default)(_react2.default.PureComponent, '`React.PureComponent` needs React >=15.3.0');

// react 15.3.0 浠ヤ笅涓嶆敮鎸� PureComponent 灏卞仛涓€涓吋瀹�

var Empty = function (_ref) {
  _inherits(Empty, _ref);

  function Empty() {
    _classCallCheck(this, Empty);

    return _possibleConstructorReturn(this, (Empty.__proto__ || Object.getPrototypeOf(Empty)).apply(this, arguments));
  }

  _createClass(Empty, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          placeholder = _props.placeholder;


      return _react2.default.createElement(
        'div',
        { style: { width: width, height: height } },
        placeholder
      );
    }
  }]);

  return Empty;
}(_react2.default.PureComponent || _react2.default.Component);

Empty.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  placeholder: _propTypes2.default.node
};
Empty.defaultProps = {
  width: '100%',
  placeholder: _react2.default.createElement(
    'div',
    { style: { position: 'relative', top: '48%', textAlign: 'center' } },
    '\u6682\u65E0\u6570\u636E'
  )
};
exports.default = Empty;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(42);

var _react2 = _interopRequireDefault(_react);

var _purechart = __webpack_require__(423);

var _purechart2 = _interopRequireDefault(_purechart);

var _empty = __webpack_require__(421);

var _empty2 = _interopRequireDefault(_empty);

var _ErrorBoundary = __webpack_require__(425);

var _ErrorBoundary2 = _interopRequireDefault(_ErrorBoundary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Chart Component
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

function hasSource(source) {
  var flag = true;

  if (source == null || source.length === 0 || source.rows && source.rows.length === 0) {
    flag = false;
  }

  return !!flag;
}

var Chart = function (_ref) {
  _inherits(Chart, _ref);

  function Chart() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Chart);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Chart.__proto__ || Object.getPrototypeOf(Chart)).call.apply(_ref2, [this].concat(args))), _this), _this._refCallback = function (c) {
      if (c) {
        _this.chart = c.getG2Instance();
      }
    }, _this.hasViewSource = function () {
      var hasViewSource = false;
      _react2.default.Children.map(_this.props.children, function (child) {
        if (!hasViewSource && child && typeof child.type === 'function' && child.type.name === 'View' && child.props.data && hasSource(child.props.data)) {
          hasViewSource = true;
        }
      });
      return hasViewSource;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Chart, [{
    key: 'getG2Instance',
    value: function getG2Instance() {
      return this.chart;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          data = _props.data,
          width = _props.width,
          height = _props.height,
          placeholder = _props.placeholder,
          className = _props.className,
          style = _props.style;

      return _react2.default.createElement(
        'div',
        { className: className, style: style },
        hasSource(data) || this.hasViewSource() || !placeholder ? _react2.default.createElement(_purechart2.default, _extends({ ref: this._refCallback }, this.props)) : _react2.default.createElement(_empty2.default, {
          width: width,
          height: height,
          placeholder: placeholder === true ? undefined : placeholder
        })
      );
    }
  }]);

  return Chart;
}(_react2.default.PureComponent || _react2.default.Component);

var BChart = function (_React$Component) {
  _inherits(BChart, _React$Component);

  function BChart() {
    _classCallCheck(this, BChart);

    return _possibleConstructorReturn(this, (BChart.__proto__ || Object.getPrototypeOf(BChart)).apply(this, arguments));
  }

  _createClass(BChart, [{
    key: 'render',
    value: function render() {
      // 鈥榳idthErrorBoundary鈥欏唴閮╝pi锛屼笉瀵瑰
      // eslint-disable-next-line react/prop-types
      var _props2 = this.props,
          widthErrorBoundary = _props2.widthErrorBoundary,
          cfg = _objectWithoutProperties(_props2, ['widthErrorBoundary']);

      if (widthErrorBoundary === false) {
        return _react2.default.createElement(Chart, cfg);
      }
      return _react2.default.createElement(
        _ErrorBoundary2.default,
        null,
        _react2.default.createElement(Chart, cfg)
      );
    }
  }]);

  return BChart;
}(_react2.default.Component);

exports.default = BChart;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(42);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _processor = __webpack_require__(436);

var _processor2 = _interopRequireDefault(_processor);

var _resizeObserverPolyfill = __webpack_require__(543);

var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

var _lodash = __webpack_require__(538);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/no-unused-prop-types: "off" */


var PureChart = function (_Component) {
  _inherits(PureChart, _Component);

  function PureChart(props) {
    _classCallCheck(this, PureChart);

    var _this = _possibleConstructorReturn(this, (PureChart.__proto__ || Object.getPrototypeOf(PureChart)).call(this, props));

    _initialiseProps.call(_this);

    _this.name = 'Chart';
    _this.gId = 0;
    _this.id = _this.createId();
    _this.g2Processor = new _processor2.default();
    _this.forceFit = (0, _lodash2.default)(function () {
      if (!_this.chart) return;
      _this.chart.forceFit();
    }, 300);
    return _this;
  }

  _createClass(PureChart, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        addElement: this.addElement,
        updateElement: this.updateElement,
        deleteElement: this.deleteElement,
        createId: this.createId,
        getParentInfo: this.getParentInfo,
        getViewId: this.getViewId
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      // 寮傛缁樺埗
      this.addElement(this.name, this.id, _extends({}, this.props, {
        container: this.containerWrap
      }));
      this.chart = this.g2Processor.createG2Instance();
      this.notifyG2Instance();
      //  ResizeObserver style warning
      if (this.props.forceFit) {
        var ro = new _resizeObserverPolyfill2.default(this.forceFit);
        ro.observe(this.containerWrap);
        this.observe = ro;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateElement(this.name, this.id, _extends({}, this.props, {
        container: this.containerWrap
      }));
      var newChart = this.g2Processor.batchedUpdate();
      if (this.chart !== newChart) {
        this.chart = newChart;
        this.notifyG2Instance();
      }
      if (this.props.forceUpdate) {
        this.chart.forceFit();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.g2Processor.destory();
      this.chart = null;
      if (this.forceFit) {
        this.forceFit.cancel();
      }
      if (this.observe) {
        this.observe.unobserve(this.containerWrap);
      }
      this.containerWrap = null;
    }
  }, {
    key: 'getG2Instance',
    value: function getG2Instance() {
      return this.chart;
    }
  }, {
    key: 'notifyG2Instance',
    value: function notifyG2Instance() {
      if (this.props.onGetG2Instance) {
        this.props.onGetG2Instance(this.chart);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { ref: this.refHandle },
        this.props.children
      );
    }
  }]);

  return PureChart;
}(_react.Component);

PureChart.propTypes = {
  data: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.object), _propTypes2.default.object]),
  scale: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array]),
  animate: _propTypes2.default.bool,
  width: _propTypes2.default.number,
  height: _propTypes2.default.number.isRequired,
  onGetG2Instance: _propTypes2.default.func,
  forceFit: _propTypes2.default.bool,
  forceUpdate: _propTypes2.default.bool
};
PureChart.childContextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.getViewId = function () {};

  this.getParentInfo = function () {
    return {
      id: _this2.id,
      name: _this2.name
    };
  };

  this.createId = function () {
    _this2.gId += 1;
    return _this2.gId;
  };

  this.addElement = function (name, id, props, parentInfo, viewId) {
    return _this2.g2Processor.addElement(name, id, props, parentInfo, viewId);
  };

  this.updateElement = function (name, id, props, parentInfo, viewId) {
    _this2.g2Processor.updateElement(name, id, props, parentInfo, viewId);
  };

  this.deleteElement = function (name, id, parentInfo) {
    _this2.g2Processor.deleteElement(name, id, parentInfo);
  };

  this.refHandle = function (cw) {
    // chart container wrap for reset operation
    if (!_this2.containerWrap) {
      _this2.containerWrap = cw;
    }
  };
};

exports.default = PureChart;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Base2.default.generateBaseTypedComponent('Coord'); /**
                                                                       * Coord Component
                                                                       */

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(42);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ErrorBoundary = function (_React$Component) {
  _inherits(ErrorBoundary, _React$Component);

  function ErrorBoundary(props) {
    _classCallCheck(this, ErrorBoundary);

    var _this = _possibleConstructorReturn(this, (ErrorBoundary.__proto__ || Object.getPrototypeOf(ErrorBoundary)).call(this, props));

    _this.state = { hasError: false };
    return _this;
  }

  _createClass(ErrorBoundary, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      if (this.state.hasError) {
        // 鍦╱pdate鍓嶉噸缃甧rror鏍囪
        // 涓洪【鍙奟eact16.3涔嬪墠鐨勭敤鎴凤紝鍥犳娌℃湁灏嗚閫昏緫鏀惧湪getDerivedStateFromProps閲�
        this.setState({ hasError: false });
      }
      return true;
    }
  }, {
    key: 'componentDidCatch',
    value: function componentDidCatch() {
      this.setState({ hasError: true });
    }
  }, {
    key: 'unstable_handleError',
    value: function unstable_handleError() {
      this.setState({ hasError: true });
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.state.hasError) {
        return _react2.default.createElement(
          'h1',
          null,
          'bizcharts error.'
        );
      }
      return this.props.children;
    }
  }]);

  return ErrorBoundary;
}(_react2.default.Component);

exports.default = ErrorBoundary;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(285);

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Base2.default.generateBaseTypedComponent('Facet');

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(292);

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Geom Component
 */
exports.default = _Base2.default.generateBaseTypedComponent('Geom');

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Guide = _Base2.default.generateBaseTypedComponent('Guide'); /*
                                                                Components:
                                                                  Guide
                                                                  Guide.Line
                                                                  Guide.Image
                                                                  Guide.Text
                                                                  Guide.Region
                                                                  Guide.Arc
                                                                  Guide.Html
                                                                  Guide.RegionFilter
                                                                  Guide.DataMarker
                                                                  Guide.DataRegion
                                                                */


Guide.Line = _Base2.default.generateBaseTypedComponent('GuideLine');
Guide.Image = _Base2.default.generateBaseTypedComponent('GuideImage');
Guide.Text = _Base2.default.generateBaseTypedComponent('GuideText');
Guide.Region = _Base2.default.generateBaseTypedComponent('GuideRegion');
Guide.Html = _Base2.default.generateBaseTypedComponent('GuideHtml');
Guide.Arc = _Base2.default.generateBaseTypedComponent('GuideArc');
Guide.RegionFilter = _Base2.default.generateBaseTypedComponent('GuideRegionFilter');
Guide.DataMarker = _Base2.default.generateBaseTypedComponent('GuideDataMarker');
Guide.DataRegion = _Base2.default.generateBaseTypedComponent('GuideDataRegion');

exports.default = Guide;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _invariant = __webpack_require__(537);

var _invariant2 = _interopRequireDefault(_invariant);

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Label Component
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var Label = function (_BaseComponent) {
  _inherits(Label, _BaseComponent);

  function Label(props) {
    _classCallCheck(this, Label);

    return _possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).call(this, props, 'Label'));
  }

  _createClass(Label, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var parentInfo = this.context.getParentInfo();
      (0, _invariant2.default)(parentInfo.name === 'Geom', '`<Label />` must be wrapped in `<Geom />`');

      this.id = this.context.createId();

      this.context.addElement(this.name, this.id, this.props, this.context.getParentInfo(), this.context.getViewId());
    }
  }]);

  return Label;
}(_Base2.default);

Label.contextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
Label.childContextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
exports.default = Label;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Legend Component
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var Legend = function (_BaseComponent) {
  _inherits(Legend, _BaseComponent);

  function Legend(props) {
    _classCallCheck(this, Legend);

    return _possibleConstructorReturn(this, (Legend.__proto__ || Object.getPrototypeOf(Legend)).call(this, props, 'Legend'));
  }

  return Legend;
}(_Base2.default);

Legend.contextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
Legend.childContextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
Legend.defaultProps = {
  visible: true
};
exports.default = Legend;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Base2.default.generateBaseTypedComponent('Tooltip'); /**
                                                                         * Tooltip Component
                                                                         */

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Base = __webpack_require__(24);

var _Base2 = _interopRequireDefault(_Base);

var _propTypes = __webpack_require__(29);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * View Component
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var View = function (_BaseComponent) {
  _inherits(View, _BaseComponent);

  function View(props) {
    _classCallCheck(this, View);

    var _this = _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, props, 'View'));

    _this.getViewId = function () {
      return _this.id;
    };

    return _this;
  }

  _createClass(View, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        addElement: this.context.addElement,
        updateElement: this.context.updateElement,
        deleteElement: this.context.deleteElement,
        createId: this.context.createId,
        getParentInfo: this.getParentInfo,
        getViewId: this.getViewId
      };
    }
  }]);

  return View;
}(_Base2.default);

View.contextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
View.childContextTypes = {
  addElement: _propTypes2.default.func,
  updateElement: _propTypes2.default.func,
  deleteElement: _propTypes2.default.func,
  createId: _propTypes2.default.func,
  getParentInfo: _propTypes2.default.func,
  getViewId: _propTypes2.default.func
};
exports.default = View;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addFuncMap = {
  Chart: 'addChart',
  Coord: 'addCoord',
  Geom: 'addGeom',
  Axis: 'addAxis',
  Tooltip: 'addTooltip',
  Legend: 'addLegend',
  Label: 'addLabel',
  View: 'addView',
  Guide: 'addGuide',
  GuideLine: 'addGuideLine',
  GuideImage: 'addGuideImage',
  GuideText: 'addGuideText',
  GuideRegion: 'addGuideRegion',
  GuideHtml: 'addGuideHtml',
  GuideArc: 'addGuideArc',
  GuideRegionFilter: 'addGuideRegionFilter',
  GuideDataMarker: 'addGuideDataMarker',
  GuideDataRegion: 'addGuideDataRegion',
  Facet: 'addFacet'
};

var iAdd = {
  addElement: function addElement(name, config, elemInfo) {
    this[addFuncMap[name]](config, elemInfo, elemInfo.id, elemInfo.viewId, elemInfo.parentInfo);
  },
  getConfigContainer: function getConfigContainer(viewContainer, vId) {
    if (vId) {
      if (!viewContainer.views) {
        viewContainer.views = {};
      }
      viewContainer = viewContainer.views[vId];
      if (!viewContainer) {
        viewContainer = {};
        viewContainer.views[vId] = viewContainer;
      }
    }

    return viewContainer;
  },
  addUniqueElement: function addUniqueElement(config, name, elemInfo, id, vId) {
    var configContainer = this.getConfigContainer(config, vId);

    if (configContainer[name]) {
      // error
    }
    configContainer[name] = elemInfo;

    return id;
  },
  addChart: function addChart(config, elemInfo, id) {
    return this.addUniqueElement(config, 'chart', elemInfo, id, null);
  },
  addView: function addView(configContainer, elemInfo, id) {
    if (!configContainer.views) {
      configContainer.views = {};
    }
    configContainer.views[id] = elemInfo;

    return id;
  },
  addAxis: function addAxis(config, elemInfo, id, vId) {
    var configContainer = this.getConfigContainer(config, vId);

    if (!configContainer.axises) {
      configContainer.axises = {};
    }
    configContainer.axises[id] = elemInfo;

    return id;
  },
  addCoord: function addCoord(config, elemInfo, id, vId) {
    return this.addUniqueElement(config, 'coord', elemInfo, id, vId);
  },
  addGeom: function addGeom(config, elemInfo, id, vId, isLabel) {
    var configContainer = this.getConfigContainer(config, vId);

    if (!configContainer.geoms) {
      configContainer.geoms = {};
    }

    if (configContainer.geoms[id]) {
      if (isLabel) {
        configContainer.geoms[id].label = elemInfo.label;
      } else {
        if (!configContainer.geoms[id].label) {
          console.log('geom label error');
        }
        elemInfo.label = configContainer.geoms[id].label;
        configContainer.geoms[id] = elemInfo;
      }
    } else {
      configContainer.geoms[id] = elemInfo;
    }

    return id;
  },
  addLabel: function addLabel(config, elemInfo, id, vId, parentInfo) {
    var configContainer = this.getConfigContainer(config, vId);

    if (!configContainer.geoms) {
      configContainer.geoms = {};
    }
    this.addGeom(config, { label: elemInfo }, parentInfo.id, vId, true);

    return id;
  },
  addTooltip: function addTooltip(config, elemInfo, id, vId) {
    return this.addUniqueElement(config, 'tooltip', elemInfo, id, vId);
  },
  addFacet: function addFacet(config, elemInfo, id, vId) {
    return this.addUniqueElement(config, 'facet', elemInfo, id, vId);
  },
  addLegend: function addLegend(config, elemInfo, id, vId) {
    var configContainer = this.getConfigContainer(config, vId);

    if (!configContainer.legends) {
      configContainer.legends = {};
    }

    configContainer.legends[id] = elemInfo;

    return id;
  },
  addGuide: function addGuide(config, elemInfo, id, vId) {
    return this.addUniqueElement(config, 'guide', elemInfo, id, vId);
  },
  addTypedGuide: function addTypedGuide(config, name, elemInfo, id, vId, parentInfo) {
    var configContainer = this.getConfigContainer(config, vId);
    var guide = configContainer.guide;
    if (!guide) {
      this.addUniqueElement('guide', {}, parentInfo.id, vId);
      guide = configContainer.guide;
    }
    if (!guide.elements) {
      guide.elements = {};
    }

    elemInfo.type = name;
    guide.elements[id] = elemInfo;

    return id;
  },
  addGuideLine: function addGuideLine(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'line', props, id, vId, parentInfo);
  },
  addGuideImage: function addGuideImage(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'image', props, id, vId, parentInfo);
  },
  addGuideText: function addGuideText(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'text', props, id, vId, parentInfo);
  },
  addGuideRegion: function addGuideRegion(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'region', props, id, vId, parentInfo);
  },
  addGuideHtml: function addGuideHtml(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'html', props, id, vId, parentInfo);
  },
  addGuideArc: function addGuideArc(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'arc', props, id, vId, parentInfo);
  },
  addGuideRegionFilter: function addGuideRegionFilter(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'regionFilter', props, id, vId, parentInfo);
  },
  addGuideDataMarker: function addGuideDataMarker(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'dataMarker', props, id, vId, parentInfo);
  },
  addGuideDataRegion: function addGuideDataRegion(config, props, id, vId, parentInfo) {
    this.addTypedGuide(config, 'dataRegion', props, id, vId, parentInfo);
  }
};

exports.default = iAdd;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var deleteFuncMap = {
  Chart: 'deleteChart',
  Coord: 'deleteCoord',
  Geom: 'deleteGeom',
  Axis: 'deleteAxis',
  Tooltip: 'deleteTooltip',
  Legend: 'deleteLegend',
  Label: 'deleteLabel',
  View: 'deleteView',
  Guide: 'deleteGuide',
  GuideLine: 'deleteTypedGuide',
  GuideImage: 'deleteTypedGuide',
  GuideText: 'deleteTypedGuide',
  GuideRegion: 'deleteTypedGuide',
  GuideHtml: 'deleteTypedGuide',
  GuideArc: 'deleteTypedGuide',
  Facet: 'deleteFacet'
};

var reExecuteDeleteElements = {
  Geom: true,
  Label: true,
  Facet: true
};

var iDelete = {
  deleteAxis: function deleteAxis(chart, config, id) {
    var axisConfig = config.axises[id].props;
    chart.axis(axisConfig.name, false);
  },
  deleteTooltip: function deleteTooltip(chart) {
    chart.tooltip(false);
  },
  deleteCoord: function deleteCoord(chart) {
    chart.coord('rect', {});
  },
  deleteLegend: function deleteLegend(chart, config, id) {
    var legendConfig = config.legends[id].props;
    chart.legend.apply(chart, _toConsumableArray(legendConfig.name ? [legendConfig.name, false] : [false]));
  },
  deleteGuide: function deleteGuide(chart) {
    chart.guide().clear();
  },
  deleteView: function deleteView(chart, config, id) {
    if (!config.views[id].g2Instance) return;
    chart.removeView(config.views[id].g2Instance);
    delete config.views[id].g2Instance;
  },
  deleteViewElement: function deleteViewElement(chart, config, deleteInfos, elementInfos) {
    var _this = this;

    // 娆℃ā鍧楀彧澶勭悊鍏冪礌鐨勫垹闄わ紝灏嗗垹闄ゅ悓姝ュ埌 g2銆�
    // 鍥犳姝ゅ鍙渶瑕佸皢view destory 鎺夛紝濡傛灉闇€瑕佸垯閲嶅缓銆�
    Object.keys(deleteInfos).forEach(function (id) {
      var elementInfo = elementInfos[id];
      var viewId = elementInfo.viewId;
      if (viewId) {
        if (reExecuteDeleteElements[elementInfo.name]) {
          config.views[viewId].needReExecute = true;
        } else if (config.views[viewId].g2Instance && _this[deleteFuncMap[elementInfo.name]]) {
          _this[deleteFuncMap[elementInfo.name]](config.views[viewId].g2Instance, config.views[viewId], elementInfo.id);
        }
      }
    });
  },
  needReExecute: function needReExecute(deleteInfos, elementInfos) {
    for (var id in deleteInfos) {
      if (reExecuteDeleteElements[elementInfos[id].name] && !elementInfos[id].viewId) {
        return true;
      }
    }
    return false;
    // return Object.keys(deleteInfos).find((id) => {
    //   return reExecuteDeleteElements[elementInfos[id].name] && !elementInfos[id].viewId;
    // });
  },
  synchronizeG2Delete: function synchronizeG2Delete(chart, config, deleteInfos, elementInfos) {
    var _this2 = this;

    Object.keys(deleteInfos).forEach(function (id) {
      var funName = deleteFuncMap[elementInfos[id].name];
      if (_this2[funName] && !elementInfos[id].viewId) {
        _this2[funName](chart, config, id);
      }
    });

    this.deleteViewElement(chart, config, deleteInfos, elementInfos);
  }
};

exports.default = iDelete;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _shared = __webpack_require__(88);

var _common = __webpack_require__(195);

var _common2 = _interopRequireDefault(_common);

var _g2Creator = __webpack_require__(197);

var _g2Creator2 = _interopRequireDefault(_g2Creator);

var _configMerge = __webpack_require__(87);

var _configMerge2 = _interopRequireDefault(_configMerge);

var _event = __webpack_require__(196);

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
// import interfaceEs6 from 'interface-es6';


var COORD_FUNC_PROPS = _common2.default.COORD_FUNC_PROPS;
var GEOM_FUNC_PROPS = _common2.default.GEOM_FUNC_PROPS;

var iUpdate = {
  needRebuildChart: function needRebuildChart(config) {
    if (config.chart.props == null || config.chart.updateProps == null) return false;
    var chartProps = config.chart.props;
    var nextChartProps = config.chart.updateProps;

    if (!_shared.Util.shallowEqual(chartProps.padding, nextChartProps.padding) || !_shared.Util.shallowEqual(chartProps.background, nextChartProps.background) || !_shared.Util.shallowEqual(chartProps.plotBackground, nextChartProps.plotBackground) || !_shared.Util.shallowEqual(chartProps.pixelRatio, nextChartProps.pixelRatio)) return true;

    return false;
  },
  needReExecute: function needReExecute(config) {
    var geoms = config.geoms;

    if (geoms == null) return false;

    for (var id in geoms) {
      if (geoms[id].props && geoms[id].updateProps && (geoms[id].props.type !== geoms[id].updateProps.type || geoms[id].props.color && !geoms[id].updateProps.color || geoms[id].props.size && !geoms[id].updateProps.size || geoms[id].props.shape && !geoms[id].updateProps.shape)) return true;
    }
    return false;
    // return Object.keys(geoms).find((id) => {
    //   if (!geoms[id].props || !geoms[id].updateProps) return false;
    //   return geoms[id].props.type !== geoms[id].updateProps.type;
    // });
  },
  needRepaint: function needRepaint(config) {
    var chartConfig = config.chart;
    var data = chartConfig.props.data;
    var nextData = chartConfig.updateProps.data;

    return data === nextData;
  },
  synchronizeG2Update: function synchronizeG2Update(chart, config) {
    this.updateChart(chart, config.chart);
    this.updateAxises(chart, config.axises);
    this.updateTooltip(chart, config);
    this.updateCoord(chart, config);
    this.updateLegends(chart, config.legends);
    this.updateGeoms(chart, config.geoms);
    this.updateGuide(chart, config.guide);
    this.updateFacet(chart, config);
    this.updateViews(chart, config);
  },
  updateChart: function updateChart(chart, chartConfig) {
    if (!chartConfig) return;

    var props = chartConfig.props;
    var nextProps = chartConfig.updateProps;
    var width = props.width,
        height = props.height,
        animate = props.animate,
        data = props.data,
        scale = props.scale;
    var nextWidth = nextProps.width,
        nextHeight = nextProps.height,
        nextAnimate = nextProps.animate,
        nextData = nextProps.data,
        nextScale = nextProps.scale;


    if (data !== nextData) {
      chart.changeData(nextData);
    }

    if (!_shared.Util.shallowEqual(scale, nextScale)) {
      if (_shared.Util.isArray(nextScale)) {
        chart.scale(nextScale[0], nextScale[1]);
      } else {
        chart.scale(nextScale);
      }
    }

    if (animate !== nextAnimate) {
      chart.animate(nextAnimate);
    }

    if (width !== nextWidth && height !== nextHeight) {
      chart.changeSize(nextWidth, nextHeight);
    } else if (width !== nextWidth) {
      chart.changeWidth(nextWidth);
    } else if (height !== nextHeight) {
      chart.changeHeight(nextHeight);
    }

    _event2.default.updateEvents(chart, _event2.default.chartEvents, chartConfig.props, nextProps);
    _event2.default.updateBaseEvents(chart, chartConfig.updateProps, nextProps);
  },
  updateAxis: function updateAxis(chart, axisConfig) {
    var _axisConfig$props = axisConfig.props,
        name = _axisConfig$props.name,
        visible = _axisConfig$props.visible,
        others = _objectWithoutProperties(_axisConfig$props, ['name', 'visible']);

    var _axisConfig$updatePro = axisConfig.updateProps,
        nextName = _axisConfig$updatePro.name,
        nextVisible = _axisConfig$updatePro.visible,
        nextOthers = _objectWithoutProperties(_axisConfig$updatePro, ['name', 'visible']);

    // warning(name === nextName, '`name` propertry should not be changed in `<Axis />`');

    if (visible !== nextVisible) {
      chart.axis(name, !!nextVisible);
    }

    // todo others have g2Instance
    if (!_shared.Util.shallowEqual(others, nextOthers)) {
      chart.axis(name, nextOthers);
    }
  },
  updateAxises: function updateAxises(chart, axises) {
    if (!axises) return;
    for (var id in axises) {
      if (axises[id] && axises[id].props && axises[id].updateProps) {
        this.updateAxis(chart, axises[id]);
      }
    }
  },
  updateTooltip: function updateTooltip(chart, config) {
    if (!config.tooltip) return;
    var props = config.tooltip.props;
    var nextProps = config.tooltip.updateProps;

    if (props == null && nextProps == null) {
      return;
    }

    if (!_shared.Util.shallowEqual(props, nextProps)) {
      chart.tooltip(_extends({}, nextProps));
    }
  },
  updateCoord: function updateCoord(chart, config) {
    var coordConfig = config.coord;
    if (!coordConfig) return;

    var props = coordConfig.props;
    var nextProps = coordConfig.updateProps;

    if (props == null || nextProps == null) {
      return;
    }

    // type can not be in coord's second param.
    var nextAttrs = _shared.Util.without(nextProps, COORD_FUNC_PROPS.concat(['type']));

    if (!_shared.Util.shallowEqual(props, nextProps)) {
      var g2Instance = chart.coord(nextProps.type, nextAttrs);
      coordConfig.g2Instance = g2Instance;
      _shared.Prop.init(COORD_FUNC_PROPS, nextProps, function (value, key) {
        if (key === 'reflect') {
          _shared.Util.each(value, function (v) {
            return g2Instance[key](v);
          });
        } else if (key === 'transpose') {
          if (value[0] === true) g2Instance[key].apply(g2Instance, _toConsumableArray(value));
        } else {
          g2Instance[key].apply(g2Instance, _toConsumableArray(value));
        }
      });
    }
  },
  updateLegend: function updateLegend(chart, legendConfig) {
    var props = legendConfig.props;
    var nextProps = legendConfig.updateProps;

    if (!nextProps) return;

    if (_shared.Util.shallowEqual(props, nextProps)) {
      return;
    }

    var name = nextProps.name,
        visible = nextProps.visible,
        cfg = _objectWithoutProperties(nextProps, ['name', 'visible']);

    var arg = !visible ? visible : cfg;

    chart.legend.apply(chart, _toConsumableArray(name ? [name, arg] : [arg]));
  },
  updateLegends: function updateLegends(chart, legends) {
    if (legends == null) {
      return;
    }

    for (var id in legends) {
      if (legends[id]) {
        this.updateLegend(chart, legends[id]);
      }
    }
  },
  updateLabel: function updateLabel(geom, props, nextProps) {
    if (props == null || nextProps == null) {
      return;
    }

    var content = props.content,
        others = _objectWithoutProperties(props, ['content']);

    var nextContent = nextProps.content,
        nextOthers = _objectWithoutProperties(nextProps, ['content']);

    if (!_shared.Util.shallowEqual(others, nextOthers) || !_shared.Util.shallowEqual(content, nextContent)) {
      if (_shared.Util.isArray(nextContent)) {
        geom.label(nextContent[0], nextContent[1], nextOthers);
      } else {
        geom.label(nextContent, nextOthers);
      }
    }
  },
  updateGeom: function updateGeom(chart, geomConfig) {
    var props = geomConfig.props;
    var nextProps = geomConfig.updateProps;

    if (!props || !nextProps) return;

    if (props.type !== nextProps.type) {
      // needReExecute chart
      return;
    }
    var geom = geomConfig.g2Instance;
    if (_shared.Util.shallowEqual(props, nextProps)) {
      if (geomConfig.label) {
        this.updateLabel(geom, geomConfig.label.props, geomConfig.label.updateProps);
      }
      return;
    }

    var adjust = props.adjust,
        attrs = _objectWithoutProperties(props, ['adjust']);

    var nextAdjust = nextProps.adjust,
        nextAttrs = _objectWithoutProperties(nextProps, ['adjust']);

    if (adjust || nextAdjust) {
      geom.adjust(nextAdjust);
    }
    _shared.Prop.update(GEOM_FUNC_PROPS, attrs, nextAttrs, function (value, key) {
      geom[key].apply(geom, _toConsumableArray(value));
    });

    if (geomConfig.label) {
      this.updateLabel(geom, geomConfig.label.props, geomConfig.label.updateProps);
    }
  },
  updateGeoms: function updateGeoms(chart, geoms) {
    if (geoms == null) {
      return false;
    }

    for (var id in geoms) {
      if (geoms[id]) {
        this.updateGeom(chart, geoms[id]);
      }
    }

    return false;
  },
  isTypedGuideChanged: function isTypedGuideChanged(config) {
    if (!_shared.Util.shallowEqual(config.props, config.updateProps)) {
      return true;
    }

    return false;
  },
  updateGuide: function updateGuide(chart, guide) {
    if (!guide || !guide.elements) {
      return;
    }

    var guides = guide.elements;
    var needRebuildGuide = false;

    for (var id in guides) {
      if (guides[id]) {
        if (guides[id].updateProps || this.isTypedGuideChanged(guides[id])) {
          needRebuildGuide = true;
          break;
        }
      }
    }

    if (needRebuildGuide) {
      _configMerge2.default.mergeGuide(guide, true);
      chart.guide().clear();
      _g2Creator2.default.guide(chart, guide);
    }
  },
  updateView: function updateView(chart, viewInfo) {
    if (!viewInfo || !viewInfo.props || !viewInfo.updateProps || viewInfo.parentInfo.name === 'Facet') {
      return;
    }
    var view = viewInfo.g2Instance;
    var props = viewInfo.props;
    var nextProps = viewInfo.updateProps;
    /*
       Others object must exclude geoms property.
       Because geoms property will cover the g2 view' inner geoms property.
    */
    var scale = props.scale,
        data = props.data,
        animate = props.animate,
        axis = props.axis,
        filter = props.filter;
    var nextScale = nextProps.scale,
        nextAnimate = nextProps.animate,
        nextData = nextProps.data,
        nextAxis = nextProps.axis,
        nextFilter = nextProps.filter;


    if (animate !== nextAnimate) {
      view.animate(nextAnimate);
    }

    if (data !== nextData) {
      view.changeData(nextData);
    }

    if (!_shared.Util.shallowEqual(scale, nextScale)) {
      view.scale(nextScale);
    }

    if (!_shared.Util.shallowEqual(filter, nextFilter)) {
      nextFilter.forEach(function (filterArg) {
        view.filter(filterArg[0], filterArg[1]);
      });
    }

    if (axis !== nextAxis) {
      view.axis(nextAxis);
    }

    this.updateCoord(view, viewInfo);
    this.updateAxises(view, viewInfo.axises);
    this.updateGeoms(view, viewInfo.geoms);
    this.updateGuide(view, viewInfo.guide);
  },
  updateViews: function updateViews(chart, config) {
    var views = config.views;

    if (!views) return;

    for (var id in views) {
      var curView = views[id];
      if (curView && (curView.needReExecute || this.needReExecute(curView))) {
        _g2Creator2.default.synchronizeG2View(curView.g2Instance, curView);
        views[id].needReExecute = false;
      } else {
        this.updateView(chart, curView);
      }
    }
  },
  updateFacet: function updateFacet(chart, config) {
    var facetConfig = config.facet;
    if (!facetConfig) return;
    var props = facetConfig.props;
    var nextProps = facetConfig.updateProps;
    if (props == null || nextProps == null) return;

    var type = props.type,
        others = _objectWithoutProperties(props, ['type']);

    var nextType = nextProps.type,
        nextOthers = _objectWithoutProperties(nextProps, ['type']);

    if (type !== nextType || !_shared.Util.shallowEqual(others, nextOthers)) {
      facetConfig.props = nextProps;
      _g2Creator2.default.facet(chart, config);
    }
  }
};

exports.default = iUpdate;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _configAdd = __webpack_require__(433);

var _configAdd2 = _interopRequireDefault(_configAdd);

var _configMerge = __webpack_require__(87);

var _configMerge2 = _interopRequireDefault(_configMerge);

var _g2Update = __webpack_require__(435);

var _g2Update2 = _interopRequireDefault(_g2Update);

var _g2Delete = __webpack_require__(434);

var _g2Delete2 = _interopRequireDefault(_g2Delete);

var _g2Creator = __webpack_require__(197);

var _g2Creator2 = _interopRequireDefault(_g2Creator);

var _shared = __webpack_require__(88);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Processor = function () {
  function Processor() {
    _classCallCheck(this, Processor);

    this.config = {};
    this.elementInfos = {};
    this.added = false;
    this.initedG2 = false;
    this.updated = false;
    this.deleted = false;
    this.deleteInfos = {};
  }

  _createClass(Processor, [{
    key: 'calUpdateFlag',
    value: function calUpdateFlag(name, id) {
      /* eslint-disable  no-unused-vars */
      var _elementInfos$id$prop = this.elementInfos[id].props,
          children = _elementInfos$id$prop.children,
          props = _objectWithoutProperties(_elementInfos$id$prop, ['children']);

      var _elementInfos$id$upda = this.elementInfos[id].updateProps,
          nextChildren = _elementInfos$id$upda.children,
          nextProps = _objectWithoutProperties(_elementInfos$id$upda, ['children']);
      /* eslint-enable */


      if (name === 'Chart' || name === 'View') {
        var data = props.data,
            otherProps = _objectWithoutProperties(props, ['data']);

        var nextData = nextProps.data,
            nextOtherProps = _objectWithoutProperties(nextProps, ['data']);

        if (data !== nextData || !_shared.Util.isEqual(otherProps, nextOtherProps)) {
          this.updated = true;
        }
      } else if (!_shared.Util.isEqual(props, nextProps)) {
        this.updated = true;
      }
    }
  }, {
    key: 'addElement',
    value: function addElement(name, id, props, parentInfo, viewId) {
      if (!this.chart && this.initedG2) return;
      this.added = true;
      this.elementInfos[id] = {
        id: id,
        viewId: viewId,
        parentInfo: parentInfo,
        name: name,
        props: _extends({}, props)
      };
      if (parentInfo && !this.elementInfos[parentInfo.id]) {
        this.elementInfos[parentInfo.id] = {
          id: parentInfo.id,
          name: parentInfo.name
        };
      }

      _configAdd2.default.addElement(name, this.config, this.elementInfos[id]);
    }
  }, {
    key: 'updateElement',
    value: function updateElement(name, id, props) {
      this.elementInfos[id].updateProps = _extends({}, props);
      this.calUpdateFlag(name, id);
    }
  }, {
    key: 'deleteElement',
    value: function deleteElement(name, id) {
      if (!this.chart) return;

      this.deleteInfos[id] = id;
      this.deleted = true;
    }
  }, {
    key: 'createG2Instance',
    value: function createG2Instance() {
      var config = this.config;

      var chart = _g2Creator2.default.createChart(config, this.elementInfos);
      _g2Creator2.default.executeChartConfig(chart, config, this.elementInfos);
      _g2Creator2.default.synchronizeG2Add(chart, config, this.elementInfos);

      chart.render();

      this.chart = chart;
      this.initedG2 = true;
      this.resetStates();
      return chart;
    }
  }, {
    key: 'destory',
    value: function destory() {
      this.chart.destroy();
      this.chart = null;
    }
  }, {
    key: 'resetStates',
    value: function resetStates() {
      var elems = this.elementInfos;
      // eslint-disable-next-line guard-for-in
      for (var id in elems) {
        if (elems[id].updateProps) delete elems[id].updateProps;
        if (this.deleteInfos[id]) {
          delete elems[id];
        }
      }
      this.added = false;
      this.updated = false;
      this.deleteInfos = {};
    }
  }, {
    key: 'reExecuteChart',
    value: function reExecuteChart() {
      this.chart.clear();
      _configMerge2.default.merge(this.config, this.deleteInfos, this.elementInfos, true);
      _g2Creator2.default.executeChartConfig(this.chart, this.config, this.elementInfos);
      _g2Creator2.default.synchronizeG2Add(this.chart, this.config, this.elementInfos);
      this.chart.repaint();
      this.resetStates();
      return this.chart;
    }
  }, {
    key: 'batchedUpdate',
    value: function batchedUpdate() {
      if (this.chart == null) return null;
      if (this.config.chart.props.forceUpdate || _g2Update2.default.needRebuildChart(this.config)) {
        _configMerge2.default.merge(this.config, this.deleteInfos, this.elementInfos, true);
        this.chart.destroy();
        this.chart = 'destroy';
        return this.createG2Instance();
      }
      if (_g2Delete2.default.needReExecute(this.deleteInfos, this.elementInfos) || _g2Update2.default.needReExecute(this.config)) {
        this.reExecuteChart();
        return this.chart;
      }

      if (this.deleted) {
        _g2Delete2.default.synchronizeG2Delete(this.chart, this.config, this.deleteInfos, this.elementInfos);
        _configMerge2.default.mergeDelete(this.config, this.deleteInfos, this.elementInfos);
      }

      if (this.added) {
        _g2Creator2.default.synchronizeG2Add(this.chart, this.config);
      }
      if (this.updated) {
        _g2Update2.default.synchronizeG2Update(this.chart, this.config);
      }
      // if (g2Update.needRepaint(this.config) && (this.added || this.deleted || this.updated)) {
      if (this.added || this.deleted || this.updated) {
        this.chart.repaint();
      }

      _configMerge2.default.mergeUpdate(this.config, false);
      this.resetStates();

      return this.chart;
    }
  }]);

  return Processor;
}();

exports.default = Processor;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = __webpack_require__(58);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  init: function init() {
    var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var props = arguments[1];
    var callback = arguments[2];

    _util2.default.each(keys, function (key) {
      var value = props[key];
      if (value !== undefined) {
        if (!_util2.default.isArray(value)) {
          value = [value];
        }
        callback(value, key);
      }
    });
  },
  update: function update(keys, props, nextProps, callback) {
    var value = void 0;
    var nextValue = void 0;
    _util2.default.each(keys, function (key) {
      value = props[key];
      nextValue = nextProps[key];
      if (!_util2.default.shallowEqual(nextValue, value)) {
        if (!_util2.default.isArray(nextValue)) {
          nextValue = [nextValue];
        }
        callback(nextValue, key);
      }
    });
  }
}; /**
    * prop function
    */

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * themes
 */
exports.default = {};

/***/ }),
/* 439 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cubehelix;
/* unused harmony export Cubehelix */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_js__ = __webpack_require__(198);




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* Rgb */])) o = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["b" /* rgbConvert */])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * __WEBPACK_IMPORTED_MODULE_2__math_js__["a" /* rad2deg */] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Cubehelix, cubehelix, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color_js__["c" /* Color */], {
  brighter: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color_js__["d" /* brighter */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color_js__["d" /* brighter */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color_js__["e" /* darker */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color_js__["e" /* darker */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * __WEBPACK_IMPORTED_MODULE_2__math_js__["b" /* deg2rad */],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new __WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* Rgb */](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),
/* 440 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export gray */
/* harmony export (immutable) */ __webpack_exports__["b"] = lab;
/* unused harmony export Lab */
/* unused harmony export lch */
/* harmony export (immutable) */ __webpack_exports__["a"] = hcl;
/* unused harmony export Hcl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_js__ = __webpack_require__(198);




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* Rgb */])) o = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["b" /* rgbConvert */])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Lab, lab, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color_js__["c" /* Color */], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new __WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* Rgb */](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * __WEBPACK_IMPORTED_MODULE_2__math_js__["a" /* rad2deg */];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * __WEBPACK_IMPORTED_MODULE_2__math_js__["b" /* deg2rad */];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["a" /* default */])(Hcl, hcl, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__define_js__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color_js__["c" /* Color */], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),
/* 441 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 442 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dispatch_js__ = __webpack_require__(441);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__dispatch_js__["a"]; });



/***/ }),
/* 443 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = bounceIn;
/* harmony export (immutable) */ __webpack_exports__["a"] = bounceOut;
/* harmony export (immutable) */ __webpack_exports__["c"] = bounceInOut;
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),
/* 445 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = circleIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = circleOut;
/* harmony export (immutable) */ __webpack_exports__["a"] = circleInOut;
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),
/* 446 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cubicIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = cubicOut;
/* harmony export (immutable) */ __webpack_exports__["a"] = cubicInOut;
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),
/* 447 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),
/* 448 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = expIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = expOut;
/* harmony export (immutable) */ __webpack_exports__["a"] = expInOut;
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}


/***/ }),
/* 449 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = linear;
function linear(t) {
  return +t;
}


/***/ }),
/* 450 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),
/* 451 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = quadIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = quadOut;
/* harmony export (immutable) */ __webpack_exports__["a"] = quadInOut;
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),
/* 452 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = sinIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = sinOut;
/* harmony export (immutable) */ __webpack_exports__["a"] = sinInOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),
/* 453 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_value__ = __webpack_require__(92);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return __WEBPACK_IMPORTED_MODULE_0__src_value__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_array__ = __webpack_require__(200);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return __WEBPACK_IMPORTED_MODULE_1__src_array__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_basis__ = __webpack_require__(91);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return __WEBPACK_IMPORTED_MODULE_2__src_basis__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__ = __webpack_require__(201);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_date__ = __webpack_require__(203);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return __WEBPACK_IMPORTED_MODULE_4__src_date__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_number__ = __webpack_require__(59);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return __WEBPACK_IMPORTED_MODULE_5__src_number__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_object__ = __webpack_require__(204);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return __WEBPACK_IMPORTED_MODULE_6__src_object__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_round__ = __webpack_require__(459);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return __WEBPACK_IMPORTED_MODULE_7__src_round__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_string__ = __webpack_require__(206);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return __WEBPACK_IMPORTED_MODULE_8__src_string__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_transform_index__ = __webpack_require__(461);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_zoom__ = __webpack_require__(463);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return __WEBPACK_IMPORTED_MODULE_10__src_zoom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_rgb__ = __webpack_require__(205);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_hsl__ = __webpack_require__(456);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_lab__ = __webpack_require__(457);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return __WEBPACK_IMPORTED_MODULE_13__src_lab__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_hcl__ = __webpack_require__(455);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(454);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_quantize__ = __webpack_require__(458);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return __WEBPACK_IMPORTED_MODULE_16__src_quantize__["a"]; });



















/***/ }),
/* 454 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cubehelixLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(41);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* cubehelix */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* cubehelix */])(end)).h),
          s = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
          l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
          opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["a"] = (cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["b" /* hue */]));
var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 455 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hclLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(41);



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* hcl */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* hcl */])(end)).h),
        c = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.c, end.c),
        l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (hcl(__WEBPACK_IMPORTED_MODULE_1__color__["b" /* hue */]));
var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 456 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hslLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(41);



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(end)).h),
        s = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
        l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (hsl(__WEBPACK_IMPORTED_MODULE_1__color__["b" /* hue */]));
var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 457 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = lab;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(41);



function lab(start, end) {
  var l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* lab */])(start)).l, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* lab */])(end)).l),
      a = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.a, end.a),
      b = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.b, end.b),
      opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),
/* 458 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),
/* 459 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
});


/***/ }),
/* 460 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["b"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),
/* 461 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return interpolateTransformSvg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(462);



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["a" /* parseCss */], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["b" /* parseSvg */], ", ", ")", ")");


/***/ }),
/* 462 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCss;
/* harmony export (immutable) */ __webpack_exports__["b"] = parseSvg;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decompose__ = __webpack_require__(460);


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* identity */];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* default */])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* identity */];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* identity */];
  value = value.matrix;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* default */])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),
/* 463 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ __webpack_exports__["a"] = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 鈮� u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),
/* 464 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export cubehelixLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(32);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* cubehelix */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* cubehelix */])(end)).h),
          s = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.s, end.s),
          l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.l, end.l),
          opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* unused harmony default export */ var _unused_webpack_default_export = (cubehelix(__WEBPACK_IMPORTED_MODULE_1__color_js__["b" /* hue */]));
var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */]);


/***/ }),
/* 465 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),
/* 466 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hclLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(32);



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* hcl */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* hcl */])(end)).h),
        c = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.c, end.c),
        l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.l, end.l),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var _unused_webpack_default_export = (hcl(__WEBPACK_IMPORTED_MODULE_1__color_js__["b" /* hue */]));
var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */]);


/***/ }),
/* 467 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hslLong */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(32);



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(start)).h, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(end)).h),
        s = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.s, end.s),
        l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.l, end.l),
        opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var _unused_webpack_default_export = (hsl(__WEBPACK_IMPORTED_MODULE_1__color_js__["b" /* hue */]));
var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */]);


/***/ }),
/* 468 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__color_js__ = __webpack_require__(32);


/* unused harmony default export */ var _unused_webpack_default_export = (function(a, b) {
  var i = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__color_js__["b" /* hue */])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),
/* 469 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(32);



function lab(start, end) {
  var l = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])((start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* lab */])(start)).l, (end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* lab */])(end)).l),
      a = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.a, end.a),
      b = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.b, end.b),
      opacity = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),
/* 470 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),
/* 471 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),
/* 472 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),
/* 473 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["b"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),
/* 474 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return interpolateTransformSvg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_js__ = __webpack_require__(475);



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(xa, xb)}, {i: i - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(xa, xb)}, {i: i - 2, x: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__number_js__["a" /* default */])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse_js__["a" /* parseCss */], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse_js__["b" /* parseSvg */], ", ", ")", ")");


/***/ }),
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCss;
/* harmony export (immutable) */ __webpack_exports__["b"] = parseSvg;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decompose_js__ = __webpack_require__(473);


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["a" /* identity */];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decompose_js__["b" /* default */])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["a" /* identity */];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose_js__["a" /* identity */];
  value = value.matrix;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__decompose_js__["b" /* default */])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),
/* 476 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* unused harmony default export */ var _unused_webpack_default_export = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 鈮� u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),
/* 477 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 478 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__select__ = __webpack_require__(215);



/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__select__["a" /* default */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name).call(document.documentElement));
});


/***/ }),
/* 479 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = local;
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),
/* 480 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(62);



/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  var event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])();
  if (event.changedTouches) event = event.changedTouches[0];
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, event);
});


/***/ }),
/* 481 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(18);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["b" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["b" /* Selection */]([selector == null ? [] : selector], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 482 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(61);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var create = typeof name === "function" ? name : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),
/* 483 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(97);


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),
/* 484 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),
/* 485 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),
/* 486 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["a"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),
/* 487 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__enter__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(477);




var keyPrefix = "$"; // Protect against keys like 鈥淿_proto__鈥�.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["b" /* EnterNode */](parent, data[i]);
    }
  }

  // Put any non-null nodes that don鈥檛 fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["b" /* EnterNode */](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});


/***/ }),
/* 488 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),
/* 489 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(102);


function dispatchEvent(node, type, params) {
  var window = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),
/* 490 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),
/* 491 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return !this.node();
});


/***/ }),
/* 492 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(18);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["b" /* Selection */](this._exit || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});


/***/ }),
/* 493 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matcher__ = __webpack_require__(214);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__matcher__["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 494 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),
/* 495 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(100);



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, before) {
  var create = typeof name === "function" ? name : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),
/* 496 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),
/* 497 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(lower);
});


/***/ }),
/* 498 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);


/* harmony default export */ __webpack_exports__["a"] = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](merges, this._parents);
});


/***/ }),
/* 499 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),
/* 500 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});


/***/ }),
/* 501 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),
/* 502 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),
/* 503 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(raise);
});


/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(remove);
});


/***/ }),
/* 505 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(100);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 506 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectorAll__ = __webpack_require__(219);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__selectorAll__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](subgroups, parents);
});


/***/ }),
/* 507 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});


/***/ }),
/* 508 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["b" /* Selection */](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(62);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touch);
    }
  }

  return null;
});


/***/ }),
/* 511 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(62);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches) {
  if (touches == null) touches = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touches[i]);
  }

  return points;
});


/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(104);


/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer_js__["d" /* Timer */], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__timer_js__["a" /* now */])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});


/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer_js__ = __webpack_require__(104);


/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer_js__["d" /* Timer */];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),
/* 514 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__ = __webpack_require__(13);



var root = [null];

/* harmony default export */ __webpack_exports__["a"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__["d" /* SCHEDULED */] && schedule.name === name) {
        return new __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["b" /* Transition */]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),
/* 515 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index_js__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_index_js__ = __webpack_require__(27);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return __WEBPACK_IMPORTED_MODULE_1__transition_index_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__active_js__ = __webpack_require__(514);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "active", function() { return __WEBPACK_IMPORTED_MODULE_2__active_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interrupt_js__ = __webpack_require__(220);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return __WEBPACK_IMPORTED_MODULE_3__interrupt_js__["a"]; });






/***/ }),
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__interrupt_js__ = __webpack_require__(517);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transition_js__ = __webpack_require__(518);




__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.interrupt = __WEBPACK_IMPORTED_MODULE_1__interrupt_js__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.transition = __WEBPACK_IMPORTED_MODULE_2__transition_js__["a" /* default */];


/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interrupt_js__ = __webpack_require__(220);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return this.each(function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interrupt_js__["a" /* default */])(this, name);
  });
});


/***/ }),
/* 518 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_ease__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_timer__ = __webpack_require__(103);





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: __WEBPACK_IMPORTED_MODULE_2_d3_ease__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["now"])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var id,
      timing;

  if (name instanceof __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["b" /* Transition */]) {
    id = name._id, name = name._name;
  } else {
    id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__transition_index_js__["c" /* newId */])(), (timing = defaultTiming).time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__transition_schedule_js__["h" /* default */])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__transition_index_js__["b" /* Transition */](groups, this._parents, name, id);
});


/***/ }),
/* 519 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate_js__ = __webpack_require__(221);





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["namespace"])(name), i = fullname === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["e" /* interpolateTransformSvg */] : __WEBPACK_IMPORTED_MODULE_3__interpolate_js__["a" /* default */];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__tween_js__["b" /* tweenValue */])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),
/* 521 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


function delayFunction(id, value) {
  return function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["g" /* init */])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["g" /* init */])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(this.node(), id).delay;
});


/***/ }),
/* 522 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


function durationFunction(id, value) {
  return function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(this.node(), id).duration;
});


/***/ }),
/* 523 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(this.node(), id).ease;
});


/***/ }),
/* 524 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we鈥檙e done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
});


/***/ }),
/* 525 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(27);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index_js__["b" /* Transition */](subgroups, this._parents, this._name, this._id);
});


/***/ }),
/* 526 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(27);


/* harmony default export */ __webpack_exports__["a"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index_js__["b" /* Transition */](merges, this._parents, this._name, this._id);
});


/***/ }),
/* 527 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule_js__ = __webpack_require__(13);


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? __WEBPACK_IMPORTED_MODULE_0__schedule_js__["g" /* init */] : __WEBPACK_IMPORTED_MODULE_0__schedule_js__["e" /* set */];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we鈥檙e done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__schedule_js__["f" /* get */])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),
/* 528 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),
/* 529 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(13);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["h" /* default */])(subgroup[i], name, id, i, subgroup, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["f" /* get */])(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index_js__["b" /* Transition */](subgroups, this._parents, name, id);
});


/***/ }),
/* 530 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(13);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["f" /* get */])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["h" /* default */])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index_js__["b" /* Transition */](subgroups, parents, name, id);
});


/***/ }),
/* 531 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(22);


var Selection = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),
/* 532 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tween_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__interpolate_js__ = __webpack_require__(221);






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
        string1 = (this.style.removeProperty(name), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__schedule_js__["e" /* set */])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we鈥檙e done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["a" /* interpolateTransformCss */] : __WEBPACK_IMPORTED_MODULE_4__interpolate_js__["a" /* default */];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__tween_js__["b" /* tweenValue */])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),
/* 533 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),
/* 534 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tween_js__ = __webpack_require__(63);


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__tween_js__["b" /* tweenValue */])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),
/* 535 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),
/* 536 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__schedule_js__ = __webpack_require__(13);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__index_js__["c" /* newId */])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__schedule_js__["f" /* get */])(node, id0);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__schedule_js__["h" /* default */])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index_js__["b" /* Transition */](groups, this._parents, name, id1);
});


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(225)))

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(223);
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(224);
var assign = __webpack_require__(539);

var ReactPropTypesSecret = __webpack_require__(223);
var checkPropTypes = __webpack_require__(540);

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.0
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),
/* 543 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(225)))

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports, __webpack_require__(22), __webpack_require__(515)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) :
	(factory((global.venn = {}),global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Transition) { 'use strict';

var SMALL = 1e-10;

/** Returns the intersection area of a bunch of circles (where each circle
 is an object having an x,y and radius property) */
function intersectionArea(circles, stats) {
    // get all the intersection points of the circles
    var intersectionPoints = getIntersectionPoints(circles);

    // filter out points that aren't included in all the circles
    var innerPoints = intersectionPoints.filter(function (p) {
        return containedInCircles(p, circles);
    });

    var arcArea = 0, polygonArea = 0, arcs = [], i;

    // if we have intersection points that are within all the circles,
    // then figure out the area contained by them
    if (innerPoints.length > 1) {
        // sort the points by angle from the center of the polygon, which lets
        // us just iterate over points to get the edges
        var center = getCenter(innerPoints);
        for (i = 0; i < innerPoints.length; ++i ) {
            var p = innerPoints[i];
            p.angle = Math.atan2(p.x - center.x, p.y - center.y);
        }
        innerPoints.sort(function(a,b) { return b.angle - a.angle;});

        // iterate over all points, get arc between the points
        // and update the areas
        var p2 = innerPoints[innerPoints.length - 1];
        for (i = 0; i < innerPoints.length; ++i) {
            var p1 = innerPoints[i];

            // polygon area updates easily ...
            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);

            // updating the arc area is a little more involved
            var midPoint = {x : (p1.x + p2.x) / 2,
                            y : (p1.y + p2.y) / 2},
                arc = null;

            for (var j = 0; j < p1.parentIndex.length; ++j) {
                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                    // figure out the angle halfway between the two points
                    // on the current circle
                    var circle = circles[p1.parentIndex[j]],
                        a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                        a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);

                    var angleDiff = (a2 - a1);
                    if (angleDiff < 0) {
                        angleDiff += 2*Math.PI;
                    }

                    // and use that angle to figure out the width of the
                    // arc
                    var a = a2 - angleDiff/2,
                        width = distance(midPoint, {
                            x : circle.x + circle.radius * Math.sin(a),
                            y : circle.y + circle.radius * Math.cos(a)
                        });

                    // clamp the width to the largest is can actually be
                    // (sometimes slightly overflows because of FP errors)
                    if (width > circle.radius * 2) {
                        width = circle.radius * 2;
                    }

                    // pick the circle whose arc has the smallest width
                    if ((arc === null) || (arc.width > width)) {
                        arc = { circle : circle,
                                width : width,
                                p1 : p1,
                                p2 : p2};
                    }
                }
            }

            if (arc !== null) {
                arcs.push(arc);
                arcArea += circleArea(arc.circle.radius, arc.width);
                p2 = p1;
            }
        }
    } else {
        // no intersection points, is either disjoint - or is completely
        // overlapped. figure out which by examining the smallest circle
        var smallest = circles[0];
        for (i = 1; i < circles.length; ++i) {
            if (circles[i].radius < smallest.radius) {
                smallest = circles[i];
            }
        }

        // make sure the smallest circle is completely contained in all
        // the other circles
        var disjoint = false;
        for (i = 0; i < circles.length; ++i) {
            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                disjoint = true;
                break;
            }
        }

        if (disjoint) {
            arcArea = polygonArea = 0;

        } else {
            arcArea = smallest.radius * smallest.radius * Math.PI;
            arcs.push({circle : smallest,
                       p1: { x: smallest.x,        y : smallest.y + smallest.radius},
                       p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},
                       width : smallest.radius * 2 });
        }
    }

    polygonArea /= 2;
    if (stats) {
        stats.area = arcArea + polygonArea;
        stats.arcArea = arcArea;
        stats.polygonArea = polygonArea;
        stats.arcs = arcs;
        stats.innerPoints = innerPoints;
        stats.intersectionPoints = intersectionPoints;
    }

    return arcArea + polygonArea;
}

/** returns whether a point is contained by all of a list of circles */
function containedInCircles(point, circles) {
    for (var i = 0; i < circles.length; ++i) {
        if (distance(point, circles[i]) > circles[i].radius + SMALL) {
            return false;
        }
    }
    return true;
}

/** Gets all intersection points between a bunch of circles */
function getIntersectionPoints(circles) {
    var ret = [];
    for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
            var intersect = circleCircleIntersection(circles[i],
                                                          circles[j]);
            for (var k = 0; k < intersect.length; ++k) {
                var p = intersect[k];
                p.parentIndex = [i,j];
                ret.push(p);
            }
        }
    }
    return ret;
}

/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */
function circleArea(r, width) {
    return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));
}

/** euclidean distance between two points */
function distance(p1, p2) {
    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +
                     (p1.y - p2.y) * (p1.y - p2.y));
}


/** Returns the overlap area of two circles of radius r1 and r2 - that
have their centers separated by distance d. Simpler faster
circle intersection for only two circles */
function circleOverlap(r1, r2, d) {
    // no overlap
    if (d >= r1 + r2) {
        return 0;
    }

    // completely overlapped
    if (d <= Math.abs(r1 - r2)) {
        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    }

    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
    return circleArea(r1, w1) + circleArea(r2, w2);
}

/** Given two circles (containing a x/y/radius attributes),
returns the intersecting points if possible.
note: doesn't handle cases where there are infinitely many
intersection points (circles are equivalent):, or only one intersection point*/
function circleCircleIntersection(p1, p2) {
    var d = distance(p1, p2),
        r1 = p1.radius,
        r2 = p2.radius;

    // if to far away, or self contained - can't be done
    if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {
        return [];
    }

    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
        h = Math.sqrt(r1 * r1 - a * a),
        x0 = p1.x + a * (p2.x - p1.x) / d,
        y0 = p1.y + a * (p2.y - p1.y) / d,
        rx = -(p2.y - p1.y) * (h / d),
        ry = -(p2.x - p1.x) * (h / d);

    return [{x: x0 + rx, y : y0 - ry },
            {x: x0 - rx, y : y0 + ry }];
}

/** Returns the center of a bunch of points */
function getCenter(points) {
    var center = {x: 0, y: 0};
    for (var i =0; i < points.length; ++i ) {
        center.x += points[i].x;
        center.y += points[i].y;
    }
    center.x /= points.length;
    center.y /= points.length;
    return center;
}

/** finds the zeros of a function, given two starting points (which must
 * have opposite signs */
function bisect(f, a, b, parameters) {
    parameters = parameters || {};
    var maxIterations = parameters.maxIterations || 100,
        tolerance = parameters.tolerance || 1e-10,
        fA = f(a),
        fB = f(b),
        delta = b - a;

    if (fA * fB > 0) {
        throw "Initial bisect points must have opposite signs";
    }

    if (fA === 0) return a;
    if (fB === 0) return b;

    for (var i = 0; i < maxIterations; ++i) {
        delta /= 2;
        var mid = a + delta,
            fMid = f(mid);

        if (fMid * fA >= 0) {
            a = mid;
        }

        if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
            return mid;
        }
    }
    return a + delta;
}

// need some basic operations on vectors, rather than adding a dependency,
// just define here
function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

function dot(a, b) {
    var ret = 0;
    for (var i = 0; i < a.length; ++i) {
        ret += a[i] * b[i];
    }
    return ret;
}

function norm2(a)  {
    return Math.sqrt(dot(a, a));
}

function scale(ret, value, c) {
    for (var i = 0; i < value.length; ++i) {
        ret[i] = value[i] * c;
    }
}

function weightedSum(ret, w1, v1, w2, v2) {
    for (var j = 0; j < ret.length; ++j) {
        ret[j] = w1 * v1[j] + w2 * v2[j];
    }
}

/** minimizes a function using the downhill simplex method */
function nelderMead(f, x0, parameters) {
    parameters = parameters || {};

    var maxIterations = parameters.maxIterations || x0.length * 200,
        nonZeroDelta = parameters.nonZeroDelta || 1.05,
        zeroDelta = parameters.zeroDelta || 0.001,
        minErrorDelta = parameters.minErrorDelta || 1e-6,
        minTolerance = parameters.minErrorDelta || 1e-5,
        rho = (parameters.rho !== undefined) ? parameters.rho : 1,
        chi = (parameters.chi !== undefined) ? parameters.chi : 2,
        psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
        sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
        maxDiff;

    // initialize simplex.
    var N = x0.length,
        simplex = new Array(N + 1);
    simplex[0] = x0;
    simplex[0].fx = f(x0);
    simplex[0].id = 0;
    for (var i = 0; i < N; ++i) {
        var point = x0.slice();
        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
        simplex[i+1] = point;
        simplex[i+1].fx = f(point);
        simplex[i+1].id = i+1;
    }

    function updateSimplex(value) {
        for (var i = 0; i < value.length; i++) {
            simplex[N][i] = value[i];
        }
        simplex[N].fx = value.fx;
    }

    var sortOrder = function(a, b) { return a.fx - b.fx; };

    var centroid = x0.slice(),
        reflected = x0.slice(),
        contracted = x0.slice(),
        expanded = x0.slice();

    for (var iteration = 0; iteration < maxIterations; ++iteration) {
        simplex.sort(sortOrder);

        if (parameters.history) {
            // copy the simplex (since later iterations will mutate) and
            // sort it to have a consistent order between iterations
            var sortedSimplex = simplex.map(function (x) {
                var state = x.slice();
                state.fx = x.fx;
                state.id = x.id;
                return state;
            });
            sortedSimplex.sort(function(a,b) { return a.id - b.id; });

            parameters.history.push({x: simplex[0].slice(),
                                     fx: simplex[0].fx,
                                     simplex: sortedSimplex});
        }

        maxDiff = 0;
        for (i = 0; i < N; ++i) {
            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
        }

        if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
            (maxDiff < minTolerance)) {
            break;
        }

        // compute the centroid of all but the worst point in the simplex
        for (i = 0; i < N; ++i) {
            centroid[i] = 0;
            for (var j = 0; j < N; ++j) {
                centroid[i] += simplex[j][i];
            }
            centroid[i] /= N;
        }

        // reflect the worst point past the centroid  and compute loss at reflected
        // point
        var worst = simplex[N];
        weightedSum(reflected, 1+rho, centroid, -rho, worst);
        reflected.fx = f(reflected);

        // if the reflected point is the best seen, then possibly expand
        if (reflected.fx < simplex[0].fx) {
            weightedSum(expanded, 1+chi, centroid, -chi, worst);
            expanded.fx = f(expanded);
            if (expanded.fx < reflected.fx) {
                updateSimplex(expanded);
            }  else {
                updateSimplex(reflected);
            }
        }

        // if the reflected point is worse than the second worst, we need to
        // contract
        else if (reflected.fx >= simplex[N-1].fx) {
            var shouldReduce = false;

            if (reflected.fx > worst.fx) {
                // do an inside contraction
                weightedSum(contracted, 1+psi, centroid, -psi, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < worst.fx) {
                    updateSimplex(contracted);
                } else {
                    shouldReduce = true;
                }
            } else {
                // do an outside contraction
                weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < reflected.fx) {
                    updateSimplex(contracted);
                } else {
                    shouldReduce = true;
                }
            }

            if (shouldReduce) {
                // if we don't contract here, we're done
                if (sigma >= 1) break;

                // do a reduction
                for (i = 1; i < simplex.length; ++i) {
                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                    simplex[i].fx = f(simplex[i]);
                }
            }
        } else {
            updateSimplex(reflected);
        }
    }

    simplex.sort(sortOrder);
    return {fx : simplex[0].fx,
            x : simplex[0]};
}

/// searches along line 'pk' for a point that satifies the wolfe conditions
/// See 'Numerical Optimization' by Nocedal and Wright p59-60
/// f : objective function
/// pk : search direction
/// current: object containing current gradient/loss
/// next: output: contains next gradient/loss
/// returns a: step size taken
function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
    var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
        phi = phi0, phi_old = phi0,
        phiPrime = phiPrime0,
        a0 = 0;

    a = a || 1;
    c1 = c1 || 1e-6;
    c2 = c2 || 0.1;

    function zoom(a_lo, a_high, phi_lo) {
        for (var iteration = 0; iteration < 16; ++iteration) {
            a = (a_lo + a_high)/2;
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);

            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (phi >= phi_lo)) {
                a_high = a;

            } else  {
                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                    return a;
                }

                if (phiPrime * (a_high - a_lo) >=0) {
                    a_high = a_lo;
                }

                a_lo = a;
                phi_lo = phi;
            }
        }

        return 0;
    }

    for (var iteration = 0; iteration < 10; ++iteration) {
        weightedSum(next.x, 1.0, current.x, a, pk);
        phi = next.fx = f(next.x, next.fxprime);
        phiPrime = dot(next.fxprime, pk);
        if ((phi > (phi0 + c1 * a * phiPrime0)) ||
            (iteration && (phi >= phi_old))) {
            return zoom(a0, a, phi_old);
        }

        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
            return a;
        }

        if (phiPrime >= 0 ) {
            return zoom(a, a0, phi);
        }

        phi_old = phi;
        a0 = a;
        a *= 2;
    }

    return a;
}

function conjugateGradient(f, initial, params) {
    // allocate all memory up front here, keep out of the loop for perfomance
    // reasons
    var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
        next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
        yk = initial.slice(),
        pk, temp,
        a = 1,
        maxIterations;

    params = params || {};
    maxIterations = params.maxIterations || initial.length * 20;

    current.fx = f(current.x, current.fxprime);
    pk = current.fxprime.slice();
    scale(pk, current.fxprime,-1);

    for (var i = 0; i < maxIterations; ++i) {
        a = wolfeLineSearch(f, pk, current, next, a);

        // todo: history in wrong spot?
        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        if (!a) {
            // faiiled to find point that satifies wolfe conditions.
            // reset direction for next iteration
            scale(pk, current.fxprime, -1);

        } else {
            // update direction using Polak鈥揜ibiere CG method
            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

            var delta_k = dot(current.fxprime, current.fxprime),
                beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

            weightedSum(pk, beta_k, pk, -1, next.fxprime);

            temp = current;
            current = next;
            next = temp;
        }

        if (norm2(current.fxprime) <= 1e-5) {
            break;
        }
    }

    if (params.history) {
        params.history.push({x: current.x.slice(),
                             fx: current.fx,
                             fxprime: current.fxprime.slice(),
                             alpha: a});
    }

    return current;
}

/** given a list of set objects, and their corresponding overlaps.
updates the (x, y, radius) attribute on each set such that their positions
roughly correspond to the desired overlaps */
function venn(areas, parameters) {
    parameters = parameters || {};
    parameters.maxIterations = parameters.maxIterations || 500;
    var initialLayout = parameters.initialLayout || bestInitialLayout;
    var loss = parameters.lossFunction || lossFunction;

    // add in missing pairwise areas as having 0 size
    areas = addMissingAreas(areas);

    // initial layout is done greedily
    var circles = initialLayout(areas, parameters);

    // transform x/y coordinates to a vector to optimize
    var initial = [], setids = [], setid;
    for (setid in circles) {
        if (circles.hasOwnProperty(setid)) {
            initial.push(circles[setid].x);
            initial.push(circles[setid].y);
            setids.push(setid);
        }
    }

    // optimize initial layout from our loss function
    var solution = nelderMead(
        function(values) {
            var current = {};
            for (var i = 0; i < setids.length; ++i) {
                var setid = setids[i];
                current[setid] = {x: values[2 * i],
                                  y: values[2 * i + 1],
                                  radius : circles[setid].radius,
                                 // size : circles[setid].size
                                 };
            }
            return loss(current, areas);
        },
        initial,
        parameters);

    // transform solution vector back to x/y points
    var positions = solution.x;
    for (var i = 0; i < setids.length; ++i) {
        setid = setids[i];
        circles[setid].x = positions[2 * i];
        circles[setid].y = positions[2 * i + 1];
    }

    return circles;
}

var SMALL$1 = 1e-10;

/** Returns the distance necessary for two circles of radius r1 + r2 to
have the overlap area 'overlap' */
function distanceFromIntersectArea(r1, r2, overlap) {
    // handle complete overlapped circles
    if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {
        return Math.abs(r1 - r2);
    }

    return bisect(function(distance$$1) {
        return circleOverlap(r1, r2, distance$$1) - overlap;
    }, 0, r1 + r2);
}

/** Missing pair-wise intersection area data can cause problems:
 treating as an unknown means that sets will be laid out overlapping,
 which isn't what people expect. To reflect that we want disjoint sets
 here, set the overlap to 0 for all missing pairwise set intersections */
function addMissingAreas(areas) {
    areas = areas.slice();

    // two circle intersections that aren't defined
    var ids = [], pairs = {}, i, j, a, b;
    for (i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.sets.length == 1) {
            ids.push(area.sets[0]);
        } else if (area.sets.length == 2) {
            a = area.sets[0];
            b = area.sets[1];
            pairs[[a, b]] = true;
            pairs[[b, a]] = true;
        }
    }
    ids.sort(function(a, b) { return a > b; });

    for (i = 0; i < ids.length; ++i) {
        a = ids[i];
        for (j = i + 1; j < ids.length; ++j) {
            b = ids[j];
            if (!([a, b] in pairs)) {
                areas.push({'sets': [a, b],
                            'size': 0});
            }
        }
    }
    return areas;
}

/// Returns two matrices, one of the euclidean distances between the sets
/// and the other indicating if there are subset or disjoint set relationships
function getDistanceMatrices(areas, sets, setids) {
    // initialize an empty distance matrix between all the points
    var distances = zerosM(sets.length, sets.length),
        constraints = zerosM(sets.length, sets.length);

    // compute required distances between all the sets such that
    // the areas match
    areas.filter(function(x) { return x.sets.length == 2; })
        .map(function(current) {
        var left = setids[current.sets[0]],
            right = setids[current.sets[1]],
            r1 = Math.sqrt(sets[left].size / Math.PI),
            r2 = Math.sqrt(sets[right].size / Math.PI),
            distance$$1 = distanceFromIntersectArea(r1, r2, current.size);

        distances[left][right] = distances[right][left] = distance$$1;

        // also update constraints to indicate if its a subset or disjoint
        // relationship
        var c = 0;
        if (current.size + 1e-10 >= Math.min(sets[left].size,
                                             sets[right].size)) {
            c = 1;
        } else if (current.size <= 1e-10) {
            c = -1;
        }
        constraints[left][right] = constraints[right][left] = c;
    });

    return {distances: distances, constraints: constraints};
}

/// computes the gradient and loss simulatenously for our constrained MDS optimizer
function constrainedMDSGradient(x, fxprime, distances, constraints) {
    var loss = 0, i;
    for (i = 0; i < fxprime.length; ++i) {
        fxprime[i] = 0;
    }

    for (i = 0; i < distances.length; ++i) {
        var xi = x[2 * i], yi = x[2 * i + 1];
        for (var j = i + 1; j < distances.length; ++j) {
            var xj = x[2 * j], yj = x[2 * j + 1],
                dij = distances[i][j],
                constraint = constraints[i][j];

            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),
                distance$$1 = Math.sqrt(squaredDistance),
                delta = squaredDistance - dij * dij;

            if (((constraint > 0) && (distance$$1 <= dij)) ||
                ((constraint < 0) && (distance$$1 >= dij))) {
                continue;
            }

            loss += 2 * delta * delta;

            fxprime[2*i]     += 4 * delta * (xi - xj);
            fxprime[2*i + 1] += 4 * delta * (yi - yj);

            fxprime[2*j]     += 4 * delta * (xj - xi);
            fxprime[2*j + 1] += 4 * delta * (yj - yi);
        }
    }
    return loss;
}

/// takes the best working variant of either constrained MDS or greedy
function bestInitialLayout(areas, params) {
    var initial = greedyLayout(areas, params);
    var loss = params.lossFunction || lossFunction;

    // greedylayout is sufficient for all 2/3 circle cases. try out
    // constrained MDS for higher order problems, take its output
    // if it outperforms. (greedy is aesthetically better on 2/3 circles
    // since it axis aligns)
    if (areas.length >= 8) {
        var constrained  = constrainedMDSLayout(areas, params),
            constrainedLoss = loss(constrained, areas),
            greedyLoss = loss(initial, areas);

        if (constrainedLoss + 1e-8 < greedyLoss) {
            initial = constrained;
        }
    }
    return initial;
}

/// use the constrained MDS variant to generate an initial layout
function constrainedMDSLayout(areas, params) {
    params = params || {};
    var restarts = params.restarts || 10;

    // bidirectionally map sets to a rowid  (so we can create a matrix)
    var sets = [], setids = {}, i;
    for (i = 0; i < areas.length; ++i ) {
        var area = areas[i];
        if (area.sets.length == 1) {
            setids[area.sets[0]] = sets.length;
            sets.push(area);
        }
    }

    var matrices = getDistanceMatrices(areas, sets, setids),
        distances = matrices.distances,
        constraints = matrices.constraints;

    // keep distances bounded, things get messed up otherwise.
    // TODO: proper preconditioner?
    var norm = norm2(distances.map(norm2))/(distances.length);
    distances = distances.map(function (row) {
        return row.map(function (value) { return value / norm; });});

    var obj = function(x, fxprime) {
        return constrainedMDSGradient(x, fxprime, distances, constraints);
    };

    var best, current;
    for (i = 0; i < restarts; ++i) {
        var initial = zeros(distances.length*2).map(Math.random);

        current = conjugateGradient(obj, initial, params);
        if (!best || (current.fx < best.fx)) {
            best = current;
        }
    }
    var positions = best.x;

    // translate rows back to (x,y,radius) coordinates
    var circles = {};
    for (i = 0; i < sets.length; ++i) {
        var set = sets[i];
        circles[set.sets[0]] = {
            x: positions[2*i] * norm,
            y: positions[2*i + 1] * norm,
            radius:  Math.sqrt(set.size / Math.PI)
        };
    }

    if (params.history) {
        for (i = 0; i < params.history.length; ++i) {
            scale(params.history[i].x, norm);
        }
    }
    return circles;
}

/** Lays out a Venn diagram greedily, going from most overlapped sets to
least overlapped, attempting to position each new set such that the
overlapping areas to already positioned sets are basically right */
function greedyLayout(areas, params) {
    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
    // define a circle for each set
    var circles = {}, setOverlaps = {}, set;
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.sets.length == 1) {
            set = area.sets[0];
            circles[set] = {x: 1e10, y: 1e10,
                            rowid: circles.length,
                            size: area.size,
                            radius: Math.sqrt(area.size / Math.PI)};
            setOverlaps[set] = [];
        }
    }
    areas = areas.filter(function(a) { return a.sets.length == 2; });

    // map each set to a list of all the other sets that overlap it
    for (i = 0; i < areas.length; ++i) {
        var current = areas[i];
        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
        var left = current.sets[0], right = current.sets[1];

        // completely overlapped circles shouldn't be positioned early here
        if (current.size + SMALL$1 >= Math.min(circles[left].size,
                                             circles[right].size)) {
            weight = 0;
        }

        setOverlaps[left].push ({set:right, size:current.size, weight:weight});
        setOverlaps[right].push({set:left,  size:current.size, weight:weight});
    }

    // get list of most overlapped sets
    var mostOverlapped = [];
    for (set in setOverlaps) {
        if (setOverlaps.hasOwnProperty(set)) {
            var size = 0;
            for (i = 0; i < setOverlaps[set].length; ++i) {
                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
            }

            mostOverlapped.push({set: set, size:size});
        }
    }

    // sort by size desc
    function sortOrder(a,b) {
        return b.size - a.size;
    }
    mostOverlapped.sort(sortOrder);

    // keep track of what sets have been laid out
    var positioned = {};
    function isPositioned(element) {
        return element.set in positioned;
    }

    // adds a point to the output
    function positionSet(point, index) {
        circles[index].x = point.x;
        circles[index].y = point.y;
        positioned[index] = true;
    }

    // add most overlapped set at (0,0)
    positionSet({x: 0, y: 0}, mostOverlapped[0].set);

    // get distances between all points. TODO, necessary?
    // answer: probably not
    // var distances = venn.getDistanceMatrices(circles, areas).distances;
    for (i = 1; i < mostOverlapped.length; ++i) {
        var setIndex = mostOverlapped[i].set,
            overlap = setOverlaps[setIndex].filter(isPositioned);
        set = circles[setIndex];
        overlap.sort(sortOrder);

        if (overlap.length === 0) {
            // this shouldn't happen anymore with addMissingAreas
            throw "ERROR: missing pairwise overlap information";
        }

        var points = [];
        for (var j = 0; j < overlap.length; ++j) {
            // get appropriate distance from most overlapped already added set
            var p1 = circles[overlap[j].set],
                d1 = distanceFromIntersectArea(set.radius, p1.radius,
                                               overlap[j].size);

            // sample positions at 90 degrees for maximum aesthetics
            points.push({x : p1.x + d1, y : p1.y});
            points.push({x : p1.x - d1, y : p1.y});
            points.push({y : p1.y + d1, x : p1.x});
            points.push({y : p1.y - d1, x : p1.x});

            // if we have at least 2 overlaps, then figure out where the
            // set should be positioned analytically and try those too
            for (var k = j + 1; k < overlap.length; ++k) {
                var p2 = circles[overlap[k].set],
                    d2 = distanceFromIntersectArea(set.radius, p2.radius,
                                                   overlap[k].size);

                var extraPoints = circleCircleIntersection(
                    { x: p1.x, y: p1.y, radius: d1},
                    { x: p2.x, y: p2.y, radius: d2});

                for (var l = 0; l < extraPoints.length; ++l) {
                    points.push(extraPoints[l]);
                }
            }
        }

        // we have some candidate positions for the set, examine loss
        // at each position to figure out where to put it at
        var bestLoss = 1e50, bestPoint = points[0];
        for (j = 0; j < points.length; ++j) {
            circles[setIndex].x = points[j].x;
            circles[setIndex].y = points[j].y;
            var localLoss = loss(circles, areas);
            if (localLoss < bestLoss) {
                bestLoss = localLoss;
                bestPoint = points[j];
            }
        }

        positionSet(bestPoint, setIndex);
    }

    return circles;
}

/** Given a bunch of sets, and the desired overlaps between these sets - computes
the distance from the actual overlaps to the desired overlaps. Note that
this method ignores overlaps of more than 2 circles */
function lossFunction(sets, overlaps) {
    var output = 0;

    function getCircles(indices) {
        return indices.map(function(i) { return sets[i]; });
    }

    for (var i = 0; i < overlaps.length; ++i) {
        var area = overlaps[i], overlap;
        if (area.sets.length == 1) {
            continue;
        } else if (area.sets.length == 2) {
            var left = sets[area.sets[0]],
                right = sets[area.sets[1]];
            overlap = circleOverlap(left.radius, right.radius,
                                    distance(left, right));
        } else {
            overlap = intersectionArea(getCircles(area.sets));
        }

        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
        output += weight * (overlap - area.size) * (overlap - area.size);
    }

    return output;
}

// orientates a bunch of circles to point in orientation
function orientateCircles(circles, orientation, orientationOrder) {
    if (orientationOrder === null) {
        circles.sort(function (a, b) { return b.radius - a.radius; });
    } else {
        circles.sort(orientationOrder);
    }

    var i;
    // shift circles so largest circle is at (0, 0)
    if (circles.length > 0) {
        var largestX = circles[0].x,
            largestY = circles[0].y;

        for (i = 0; i < circles.length; ++i) {
            circles[i].x -= largestX;
            circles[i].y -= largestY;
        }
    }

    if (circles.length == 2) {
        // if the second circle is a subset of the first, arrange so that
        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120
        var dist = distance(circles[0], circles[1]);
        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
            circles[1].y = circles[0].y;
        }
    }

    // rotate circles so that second largest is at an angle of 'orientation'
    // from largest
    if (circles.length > 1) {
        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,
            c = Math.cos(rotation),
            s = Math.sin(rotation), x, y;

        for (i = 0; i < circles.length; ++i) {
            x = circles[i].x;
            y = circles[i].y;
            circles[i].x = c * x - s * y;
            circles[i].y = s * x + c * y;
        }
    }

    // mirror solution if third solution is above plane specified by
    // first two circles
    if (circles.length > 2) {
        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;
        while (angle < 0) { angle += 2* Math.PI; }
        while (angle > 2*Math.PI) { angle -= 2* Math.PI; }
        if (angle > Math.PI) {
            var slope = circles[1].y / (1e-10 + circles[1].x);
            for (i = 0; i < circles.length; ++i) {
                var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);
                circles[i].x = 2 * d - circles[i].x;
                circles[i].y = 2 * d * slope - circles[i].y;
            }
        }
    }
}

function disjointCluster(circles) {
    // union-find clustering to get disjoint sets
    circles.map(function(circle) { circle.parent = circle; });

    // path compression step in union find
    function find(circle) {
        if (circle.parent !== circle) {
            circle.parent = find(circle.parent);
        }
        return circle.parent;
    }

    function union(x, y) {
        var xRoot = find(x), yRoot = find(y);
        xRoot.parent = yRoot;
    }

    // get the union of all overlapping sets
    for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
            var maxDistance = circles[i].radius + circles[j].radius;
            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {
                union(circles[j], circles[i]);
            }
        }
    }

    // find all the disjoint clusters and group them together
    var disjointClusters = {}, setid;
    for (i = 0; i < circles.length; ++i) {
        setid = find(circles[i]).parent.setid;
        if (!(setid in disjointClusters)) {
            disjointClusters[setid] = [];
        }
        disjointClusters[setid].push(circles[i]);
    }

    // cleanup bookkeeping
    circles.map(function(circle) { delete circle.parent; });

    // return in more usable form
    var ret = [];
    for (setid in disjointClusters) {
        if (disjointClusters.hasOwnProperty(setid)) {
            ret.push(disjointClusters[setid]);
        }
    }
    return ret;
}

function getBoundingBox(circles) {
    var minMax = function(d) {
        var hi = Math.max.apply(null, circles.map(
                                function(c) { return c[d] + c.radius; } )),
            lo = Math.min.apply(null, circles.map(
                                function(c) { return c[d] - c.radius;} ));
        return {max:hi, min:lo};
    };

    return {xRange: minMax('x'), yRange: minMax('y')};
}

function normalizeSolution(solution, orientation, orientationOrder) {
    if (orientation === null){
        orientation = Math.PI/2;
    }

    // work with a list instead of a dictionary, and take a copy so we
    // don't mutate input
    var circles = [], i, setid;
    for (setid in solution) {
        if (solution.hasOwnProperty(setid)) {
            var previous = solution[setid];
            circles.push({x: previous.x,
                          y: previous.y,
                          radius: previous.radius,
                          setid: setid});
        }
    }

    // get all the disjoint clusters
    var clusters = disjointCluster(circles);

    // orientate all disjoint sets, get sizes
    for (i = 0; i < clusters.length; ++i) {
        orientateCircles(clusters[i], orientation, orientationOrder);
        var bounds = getBoundingBox(clusters[i]);
        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
        clusters[i].bounds = bounds;
    }
    clusters.sort(function(a, b) { return b.size - a.size; });

    // orientate the largest at 0,0, and get the bounds
    circles = clusters[0];
    var returnBounds = circles.bounds;

    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;

    function addCluster(cluster, right, bottom) {
        if (!cluster) return;

        var bounds = cluster.bounds, xOffset, yOffset, centreing;

        if (right) {
            xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;
        } else {
            xOffset = returnBounds.xRange.max  - bounds.xRange.max;
            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -
                        (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
            if (centreing < 0) xOffset += centreing;
        }

        if (bottom) {
            yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;
        } else {
            yOffset = returnBounds.yRange.max  - bounds.yRange.max;
            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -
                        (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
            if (centreing < 0) yOffset += centreing;
        }

        for (var j = 0; j < cluster.length; ++j) {
            cluster[j].x += xOffset;
            cluster[j].y += yOffset;
            circles.push(cluster[j]);
        }
    }

    var index = 1;
    while (index < clusters.length) {
        addCluster(clusters[index], true, false);
        addCluster(clusters[index+1], false, true);
        addCluster(clusters[index+2], true, true);
        index += 3;

        // have one cluster (in top left). lay out next three relative
        // to it in a grid
        returnBounds = getBoundingBox(circles);
    }

    // convert back to solution form
    var ret = {};
    for (i = 0; i < circles.length; ++i) {
        ret[circles[i].setid] = circles[i];
    }
    return ret;
}

/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
a rectangle of width/height - with padding around the borders. also
centers the diagram in the available space at the same time */
function scaleSolution(solution, width, height, padding) {
    var circles = [], setids = [];
    for (var setid in solution) {
        if (solution.hasOwnProperty(setid)) {
            setids.push(setid);
            circles.push(solution[setid]);
        }
    }

    width -= 2*padding;
    height -= 2*padding;

    var bounds = getBoundingBox(circles),
        xRange = bounds.xRange,
        yRange = bounds.yRange;

    if ((xRange.max == xRange.min) ||
        (yRange.max == yRange.min)) {
        console.log("not scaling solution: zero size detected");
        return solution;
    }

    var xScaling = width  / (xRange.max - xRange.min),
        yScaling = height / (yRange.max - yRange.min),
        scaling = Math.min(yScaling, xScaling),

        // while we're at it, center the diagram too
        xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,
        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;

    var scaled = {};
    for (var i = 0; i < circles.length; ++i) {
        var circle = circles[i];
        scaled[setids[i]] = {
            radius: scaling * circle.radius,
            x: padding + xOffset + (circle.x - xRange.min) * scaling,
            y: padding + yOffset + (circle.y - yRange.min) * scaling,
        };
    }

    return scaled;
}

/*global console:true*/

function VennDiagram() {
    var width = 600,
        height = 350,
        padding = 15,
        duration = 1000,
        orientation = Math.PI / 2,
        normalize = true,
        wrap = true,
        styled = true,
        fontSize = null,
        orientationOrder = null,

        // mimic the behaviour of d3.scale.category10 from the previous
        // version of d3
        colourMap = {},

        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0
        // since we can support older versions of d3 as long as we don't force this,
        // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10
        colourScheme = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"],
        colourIndex = 0,
        colours = function(key) {
            if (key in colourMap) {
                return colourMap[key];
            }
            var ret = colourMap[key] = colourScheme[colourIndex];
            colourIndex += 1;
            if (colourIndex >= colourScheme.length) {
                colourIndex = 0;
            }
            return ret;
        },
        layoutFunction = venn,
        loss = lossFunction;


    function chart(selection) {
        var data = selection.datum();

        // handle 0-sized sets by removing from input
        var toremove = {};
        data.forEach(function(datum) {
            if ((datum.size == 0) && datum.sets.length == 1) {
                toremove[datum.sets[0]] = 1;
            }
        });
        data = data.filter(function(datum) {
            return !datum.sets.some(function(set) { return set in toremove; });
        });

        var circles = {};
        var textCentres = {};

        if (data.length > 0) {
            var solution = layoutFunction(data, {lossFunction: loss});

            if (normalize) {
                solution = normalizeSolution(solution,
                                            orientation,
                                            orientationOrder);
            }

            circles = scaleSolution(solution, width, height, padding);
            textCentres = computeTextCentres(circles, data);
        }

        // Figure out the current label for each set. These can change
        // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)
        var labels = {};
        data.forEach(function(datum) {
            if (datum.label) {
                labels[datum.sets] = datum.label;
            }
        });

        function label(d) {
            if (d.sets in labels) {
                return labels[d.sets];
            }
            if (d.sets.length == 1) {
                return '' + d.sets[0];
            }
        }

        // create svg if not already existing
        selection.selectAll("svg").data([circles]).enter().append("svg");

        var svg = selection.select("svg")
            .attr("width", width)
            .attr("height", height);

        // to properly transition intersection areas, we need the
        // previous circles locations. load from elements
        var previous = {}, hasPrevious = false;
        svg.selectAll(".venn-area path").each(function (d) {
            var path = d3Selection.select(this).attr("d");
            if ((d.sets.length == 1) && path) {
                hasPrevious = true;
                previous[d.sets[0]] = circleFromPath(path);
            }
        });

        // interpolate intersection area paths between previous and
        // current paths
        var pathTween = function(d) {
            return function(t) {
                var c = d.sets.map(function(set) {
                    var start = previous[set], end = circles[set];
                    if (!start) {
                        start = {x : width/2, y : height/2, radius : 1};
                    }
                    if (!end) {
                        end = {x : width/2, y : height/2, radius : 1};
                    }
                    return {'x' : start.x * (1 - t) + end.x * t,
                            'y' : start.y * (1 - t) + end.y * t,
                            'radius' : start.radius * (1 - t) + end.radius * t};
                });
                return intersectionAreaPath(c);
            };
        };

        // update data, joining on the set ids
        var nodes = svg.selectAll(".venn-area")
            .data(data, function(d) { return d.sets; });

        // create new nodes
        var enter = nodes.enter()
            .append('g')
            .attr("class", function(d) {
                return "venn-area venn-" +
                    (d.sets.length == 1 ? "circle" : "intersection");
            })
            .attr("data-venn-sets", function(d) {
                return d.sets.join("_");
            });

        var enterPath = enter.append("path"),
            enterText = enter.append("text")
            .attr("class", "label")
            .text(function (d) { return label(d); } )
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("x", width/2)
            .attr("y", height/2);


        // apply minimal style if wanted
        if (styled) {
            enterPath.style("fill-opacity", "0")
                .filter(function (d) { return d.sets.length == 1; } )
                .style("fill", function(d) { return colours(d.sets); })
                .style("fill-opacity", ".25");

            enterText
                .style("fill", function(d) { return d.sets.length == 1 ? colours(d.sets) : "#444"; });
        }

        // update existing, using pathTween if necessary
        var update = selection;
        if (hasPrevious) {
            update = selection.transition("venn").duration(duration);
            update.selectAll("path")
                .attrTween("d", pathTween);
        } else {
            update.selectAll("path")
                .attr("d", function(d) {
                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));
                });
        }

        var updateText = update.selectAll("text")
            .filter(function (d) { return d.sets in textCentres; })
            .text(function (d) { return label(d); } )
            .attr("x", function(d) { return Math.floor(textCentres[d.sets].x);})
            .attr("y", function(d) { return Math.floor(textCentres[d.sets].y);});

        if (wrap) {
            if (hasPrevious) {
                // d3 4.0 uses 'on' for events on transitions,
                // but d3 3.0 used 'each' instead. switch appropiately
                if ('on' in updateText) {
                    updateText.on("end", wrapText(circles, label));
                } else {
                    updateText.each("end", wrapText(circles, label));
                }
            } else {
                updateText.each(wrapText(circles, label));
            }
        }

        // remove old
        var exit = nodes.exit().transition('venn').duration(duration).remove();
        exit.selectAll("path")
            .attrTween("d", pathTween);

        var exitText = exit.selectAll("text")
            .attr("x", width/2)
            .attr("y", height/2);

        // if we've been passed a fontSize explicitly, use it to
        // transition
        if (fontSize !== null) {
            enterText.style("font-size", "0px");
            updateText.style("font-size", fontSize);
            exitText.style("font-size", "0px");
        }


        return {'circles': circles,
                'textCentres': textCentres,
                'nodes': nodes,
                'enter': enter,
                'update': update,
                'exit': exit};
    }

    chart.wrap = function(_) {
        if (!arguments.length) return wrap;
        wrap = _;
        return chart;
    };

    chart.width = function(_) {
        if (!arguments.length) return width;
        width = _;
        return chart;
    };

    chart.height = function(_) {
        if (!arguments.length) return height;
        height = _;
        return chart;
    };

    chart.padding = function(_) {
        if (!arguments.length) return padding;
        padding = _;
        return chart;
    };

    chart.colours = function(_) {
        if (!arguments.length) return colours;
        colours = _;
        return chart;
    };

    chart.fontSize = function(_) {
        if (!arguments.length) return fontSize;
        fontSize = _;
        return chart;
    };

    chart.duration = function(_) {
        if (!arguments.length) return duration;
        duration = _;
        return chart;
    };

    chart.layoutFunction = function(_) {
        if (!arguments.length) return layoutFunction;
        layoutFunction = _;
        return chart;
    };

    chart.normalize = function(_) {
        if (!arguments.length) return normalize;
        normalize = _;
        return chart;
    };

    chart.styled = function(_) {
        if (!arguments.length) return styled;
        styled = _;
        return chart;
    };

    chart.orientation = function(_) {
        if (!arguments.length) return orientation;
        orientation = _;
        return chart;
    };

    chart.orientationOrder = function(_) {
        if (!arguments.length) return orientationOrder;
        orientationOrder = _;
        return chart;
    };

    chart.lossFunction = function(_) {
      if (!arguments.length) return loss;
      loss = _;
      return chart;
    };

    return chart;
}
// sometimes text doesn't fit inside the circle, if thats the case lets wrap
// the text here such that it fits
// todo: looks like this might be merged into d3 (
// https://github.com/mbostock/d3/issues/1642),
// also worth checking out is
// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/
// this seems to be one of those things that should be easy but isn't
function wrapText(circles, labeller) {
    return function() {
        var text = d3Selection.select(this),
            data = text.datum(),
            width = circles[data.sets[0]].radius || 50,
            label = labeller(data) || '';

            var words = label.split(/\s+/).reverse(),
            maxLines = 3,
            minChars = (label.length + words.length) / maxLines,
            word = words.pop(),
            line = [word],
            joined,
            lineNumber = 0,
            lineHeight = 1.1, // ems
            tspan = text.text(null).append("tspan").text(word);

        while (true) {
            word = words.pop();
            if (!word) break;
            line.push(word);
            joined = line.join(" ");
            tspan.text(joined);
            if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").text(word);
                lineNumber++;
            }
        }

        var initial = 0.35 - lineNumber * lineHeight / 2,
            x = text.attr("x"),
            y = text.attr("y");

        text.selectAll("tspan")
            .attr("x", x)
            .attr("y", y)
            .attr("dy", function(d, i) {
                 return (initial + i * lineHeight) + "em";
            });
    };
}

function circleMargin(current, interior, exterior) {
    var margin = interior[0].radius - distance(interior[0], current), i, m;
    for (i = 1; i < interior.length; ++i) {
        m = interior[i].radius - distance(interior[i], current);
        if (m <= margin) {
            margin = m;
        }
    }

    for (i = 0; i < exterior.length; ++i) {
        m = distance(exterior[i], current) - exterior[i].radius;
        if (m <= margin) {
            margin = m;
        }
    }
    return margin;
}

// compute the center of some circles by maximizing the margin of
// the center point relative to the circles (interior) after subtracting
// nearby circles (exterior)
function computeTextCentre(interior, exterior) {
    // get an initial estimate by sampling around the interior circles
    // and taking the point with the biggest margin
    var points = [], i;
    for (i = 0; i < interior.length; ++i) {
        var c = interior[i];
        points.push({x: c.x, y: c.y});
        points.push({x: c.x + c.radius/2, y: c.y});
        points.push({x: c.x - c.radius/2, y: c.y});
        points.push({x: c.x, y: c.y + c.radius/2});
        points.push({x: c.x, y: c.y - c.radius/2});
    }
    var initial = points[0], margin = circleMargin(points[0], interior, exterior);
    for (i = 1; i < points.length; ++i) {
        var m = circleMargin(points[i], interior, exterior);
        if (m >= margin) {
            initial = points[i];
            margin = m;
        }
    }

    // maximize the margin numerically
    var solution = nelderMead(
                function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },
                [initial.x, initial.y],
                {maxIterations:500, minErrorDelta:1e-10}).x;
    var ret = {x: solution[0], y: solution[1]};

    // check solution, fallback as needed (happens if fully overlapped
    // etc)
    var valid = true;
    for (i = 0; i < interior.length; ++i) {
        if (distance(ret, interior[i]) > interior[i].radius) {
            valid = false;
            break;
        }
    }

    for (i = 0; i < exterior.length; ++i) {
        if (distance(ret, exterior[i]) < exterior[i].radius) {
            valid = false;
            break;
        }
    }

    if (!valid) {
        if (interior.length == 1) {
            ret = {x: interior[0].x, y: interior[0].y};
        } else {
            var areaStats = {};
            intersectionArea(interior, areaStats);

            if (areaStats.arcs.length === 0) {
                ret = {'x': 0, 'y': -1000, disjoint:true};

            } else if (areaStats.arcs.length == 1) {
                ret = {'x': areaStats.arcs[0].circle.x,
                       'y': areaStats.arcs[0].circle.y};

            } else if (exterior.length) {
                // try again without other circles
                ret = computeTextCentre(interior, []);

            } else {
                // take average of all the points in the intersection
                // polygon. this should basically never happen
                // and has some issues:
                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777
                ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));
            }
        }
    }

    return ret;
}

// given a dictionary of {setid : circle}, returns
// a dictionary of setid to list of circles that completely overlap it
function getOverlappingCircles(circles) {
    var ret = {}, circleids = [];
    for (var circleid in circles) {
        circleids.push(circleid);
        ret[circleid] = [];
    }
    for (var i  = 0; i < circleids.length; i++) {
        var a = circles[circleids[i]];
        for (var j = i + 1; j < circleids.length; ++j) {
            var b = circles[circleids[j]],
                d = distance(a, b);

            if (d + b.radius <= a.radius + 1e-10) {
                ret[circleids[j]].push(circleids[i]);

            } else if (d + a.radius <= b.radius + 1e-10) {
                ret[circleids[i]].push(circleids[j]);
            }
        }
    }
    return ret;
}

function computeTextCentres(circles, areas) {
    var ret = {}, overlapped = getOverlappingCircles(circles);
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i].sets, areaids = {}, exclude = {};
        for (var j = 0; j < area.length; ++j) {
            areaids[area[j]] = true;
            var overlaps = overlapped[area[j]];
            // keep track of any circles that overlap this area,
            // and don't consider for purposes of computing the text
            // centre
            for (var k = 0; k < overlaps.length; ++k) {
                exclude[overlaps[k]] = true;
            }
        }

        var interior = [], exterior = [];
        for (var setid in circles) {
            if (setid in areaids) {
                interior.push(circles[setid]);
            } else if (!(setid in exclude)) {
                exterior.push(circles[setid]);
            }
        }
        var centre = computeTextCentre(interior, exterior);
        ret[area] = centre;
        if (centre.disjoint && (areas[i].size > 0)) {
            console.log("WARNING: area " + area + " not represented on screen");
        }
    }
    return  ret;
}

// sorts all areas in the venn diagram, so that
// a particular area is on top (relativeTo) - and
// all other areas are so that the smallest areas are on top
function sortAreas(div, relativeTo) {

    // figure out sets that are completly overlapped by relativeTo
    var overlaps = getOverlappingCircles(div.selectAll("svg").datum());
    var exclude = {};
    for (var i = 0; i < relativeTo.sets.length; ++i) {
        var check = relativeTo.sets[i];
        for (var setid in overlaps) {
            var overlap = overlaps[setid];
            for (var j = 0; j < overlap.length; ++j) {
                if (overlap[j] == check) {
                    exclude[setid] = true;
                    break;
                }
            }
        }
    }

    // checks that all sets are in exclude;
    function shouldExclude(sets) {
        for (var i = 0; i < sets.length; ++i) {
            if (!(sets[i] in exclude)) {
                return false;
            }
        }
        return true;
    }

    // need to sort div's so that Z order is correct
    div.selectAll("g").sort(function (a, b) {
        // highest order set intersections first
        if (a.sets.length != b.sets.length) {
            return a.sets.length - b.sets.length;
        }

        if (a == relativeTo) {
            return shouldExclude(b.sets) ? -1 : 1;
        }
        if (b == relativeTo) {
            return shouldExclude(a.sets) ? 1 : -1;
        }

        // finally by size
        return b.size - a.size;
    });
}

function circlePath(x, y, r) {
    var ret = [];
    ret.push("\nM", x, y);
    ret.push("\nm", -r, 0);
    ret.push("\na", r, r, 0, 1, 0, r *2, 0);
    ret.push("\na", r, r, 0, 1, 0,-r *2, 0);
    return ret.join(" ");
}

// inverse of the circlePath function, returns a circle object from an svg path
function circleFromPath(path) {
    var tokens = path.split(' ');
    return {'x' : parseFloat(tokens[1]),
            'y' : parseFloat(tokens[2]),
            'radius' : -parseFloat(tokens[4])
            };
}

/** returns a svg path of the intersection area of a bunch of circles */
function intersectionAreaPath(circles) {
    var stats = {};
    intersectionArea(circles, stats);
    var arcs = stats.arcs;

    if (arcs.length === 0) {
        return "M 0 0";

    } else if (arcs.length == 1) {
        var circle = arcs[0].circle;
        return circlePath(circle.x, circle.y, circle.radius);

    } else {
        // draw path around arcs
        var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
        for (var i = 0; i < arcs.length; ++i) {
            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
            ret.push("\nA", r, r, 0, wide ? 1 : 0, 1,
                     arc.p1.x, arc.p1.y);
        }
        return ret.join(" ");
    }
}

exports.intersectionArea = intersectionArea;
exports.circleCircleIntersection = circleCircleIntersection;
exports.circleOverlap = circleOverlap;
exports.circleArea = circleArea;
exports.distance = distance;
exports.venn = venn;
exports.greedyLayout = greedyLayout;
exports.scaleSolution = scaleSolution;
exports.normalizeSolution = normalizeSolution;
exports.bestInitialLayout = bestInitialLayout;
exports.lossFunction = lossFunction;
exports.disjointCluster = disjointCluster;
exports.distanceFromIntersectArea = distanceFromIntersectArea;
exports.VennDiagram = VennDiagram;
exports.wrapText = wrapText;
exports.computeTextCentres = computeTextCentres;
exports.computeTextCentre = computeTextCentre;
exports.sortAreas = sortAreas;
exports.circlePath = circlePath;
exports.circleFromPath = circleFromPath;
exports.intersectionAreaPath = intersectionAreaPath;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(64);
module.exports = __webpack_require__(64);


/***/ })
/******/ ]);
});